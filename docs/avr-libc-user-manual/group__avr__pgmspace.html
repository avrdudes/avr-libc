<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<title>AVR-LibC: &lt;avr/pgmspace.h&gt;: Program Space Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AVR-LibC
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
   <div id="projectbrief">Standard C library for AVR-GCC</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table>
  <tr>
    <td align="left"><a href="https://avrdudes.github.io/avr-libc/"><h2>AVR-LibC Documentation</h2></a></td>
    <td align="center" colspan=4><img src="avr-libc-logo.png" alt="Logo" align="middle" border="0"></td>
    <td align="right"><a href="https://github.com/avrdudes/avr-libc/"><h2>AVR-LibC Development Pages</h2></a></td>
  </tr>
  <tr>
    <td align="center" width="16%"><a href="index.html"><h2>Main Page</h2></a></td>
    <td align="center" width="16%"><a href="pages.html"><h2>User Manual</h2></a></td>
    <td align="center" width="16%"><a href="modules.html"><h2>Library Reference</h2></a></td>
    <td align="center" width="16%"><a href="FAQ.html"><h2>FAQ</h2></a></td>
    <td align="center" width="16%"><a href="group__demos.html"><h2>Example Projects</h2></a></td>
    <td align="center" width="16%"><a href="files.html"><h2>File List</h2></a></td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">&lt;avr/pgmspace.h&gt;: Program Space Utilities</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae59d3b5091405672ec394d3903ee60c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gae59d3b5091405672ec394d3903ee60c5">PROGMEM_FAR</a>&#160;&#160;&#160;__attribute__((__section__(&quot;.progmemx.data&quot;)))</td></tr>
<tr class="separator:gae59d3b5091405672ec394d3903ee60c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75acaba9e781937468d0911423bc0c35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>&#160;&#160;&#160;__attribute__((__progmem__))</td></tr>
<tr class="separator:ga75acaba9e781937468d0911423bc0c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73809107539df84eaf01f6a4dea4fbff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga73809107539df84eaf01f6a4dea4fbff">PSTR</a>(str)&#160;&#160;&#160;({ static const <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> char c[] = (str); &amp;c[0]; })</td></tr>
<tr class="separator:ga73809107539df84eaf01f6a4dea4fbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22972d0aa51e8b8dd64ce1a2b9c78edb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga22972d0aa51e8b8dd64ce1a2b9c78edb">PSTR_FAR</a>(str)&#160;&#160;&#160;({ static const <a class="el" href="group__avr__pgmspace.html#gae59d3b5091405672ec394d3903ee60c5">PROGMEM_FAR</a> char c[] = (str); <a class="el" href="group__avr__pgmspace.html#ga8ddf0e398bde8078aa9395ac77c83f0a">pgm_get_far_address</a>(c[0]); })</td></tr>
<tr class="separator:ga22972d0aa51e8b8dd64ce1a2b9c78edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga296eb4a3e03c26b13e6207ccd15dcb1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga296eb4a3e03c26b13e6207ccd15dcb1e">pgm_read_byte_near</a>(__addr)&#160;&#160;&#160;__LPM ((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(__addr))</td></tr>
<tr class="separator:ga296eb4a3e03c26b13e6207ccd15dcb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a46ba5b6638df8c254964424f10c0fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga5a46ba5b6638df8c254964424f10c0fb">pgm_read_word_near</a>(__addr)&#160;&#160;&#160;__LPM_word ((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(__addr))</td></tr>
<tr class="separator:ga5a46ba5b6638df8c254964424f10c0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga289488b882ba92d0364a9bf65f5dc472"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga289488b882ba92d0364a9bf65f5dc472">pgm_read_dword_near</a>(__addr)&#160;&#160;&#160;    __LPM_dword ((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(__addr))</td></tr>
<tr class="separator:ga289488b882ba92d0364a9bf65f5dc472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22f9d07729cb6af716ec449a129756c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga22f9d07729cb6af716ec449a129756c3">pgm_read_qword_near</a>(__addr)&#160;&#160;&#160;__LPM_qword ((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(__addr))</td></tr>
<tr class="separator:ga22f9d07729cb6af716ec449a129756c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b33ee6ceaf1dd3ebcfa6f4c96f8b27"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga93b33ee6ceaf1dd3ebcfa6f4c96f8b27">pgm_read_float_near</a>(addr)&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga523419c061658fc3a41945208cd3e187">pgm_read_float</a> (addr)</td></tr>
<tr class="separator:ga93b33ee6ceaf1dd3ebcfa6f4c96f8b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59f916fc92569eed66b43f3b55286fdf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga59f916fc92569eed66b43f3b55286fdf">pgm_read_ptr_near</a>(__addr)&#160;&#160;&#160;    ((void*) __LPM_word ((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(__addr)))</td></tr>
<tr class="separator:ga59f916fc92569eed66b43f3b55286fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e89771ca773d9a2eb7bd1696a23af8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga7e89771ca773d9a2eb7bd1696a23af8d">pgm_read_byte_far</a>(__addr)&#160;&#160;&#160;__ELPM (__addr)</td></tr>
<tr class="separator:ga7e89771ca773d9a2eb7bd1696a23af8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa77cd8c6f7c2a4c32c62b69463009700"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaa77cd8c6f7c2a4c32c62b69463009700">pgm_read_word_far</a>(__addr)&#160;&#160;&#160;__ELPM_word (__addr)</td></tr>
<tr class="separator:gaa77cd8c6f7c2a4c32c62b69463009700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce625d37bbc5280d7cd316e8b273a4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga2ce625d37bbc5280d7cd316e8b273a4d">pgm_read_dword_far</a>(__addr)&#160;&#160;&#160;__ELPM_dword (__addr)</td></tr>
<tr class="separator:ga2ce625d37bbc5280d7cd316e8b273a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f304a81b2123b85026c72960c81c51c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga8f304a81b2123b85026c72960c81c51c">pgm_read_qword_far</a>(__addr)&#160;&#160;&#160;__ELPM_qword (__addr)</td></tr>
<tr class="separator:ga8f304a81b2123b85026c72960c81c51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d88a95758ece5f8805cf7c2d04b03cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga5d88a95758ece5f8805cf7c2d04b03cf">pgm_read_ptr_far</a>(__addr)&#160;&#160;&#160;((void*) __ELPM_word (__addr))</td></tr>
<tr class="separator:ga5d88a95758ece5f8805cf7c2d04b03cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae89a4ff0b5a887888fcf83c4701b310b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gae89a4ff0b5a887888fcf83c4701b310b">pgm_read_byte</a>(__addr)&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga296eb4a3e03c26b13e6207ccd15dcb1e">pgm_read_byte_near</a>(__addr)</td></tr>
<tr class="separator:gae89a4ff0b5a887888fcf83c4701b310b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5336313575dfe47dd73f0847fcd21fed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga5336313575dfe47dd73f0847fcd21fed">pgm_read_word</a>(__addr)&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga5a46ba5b6638df8c254964424f10c0fb">pgm_read_word_near</a>(__addr)</td></tr>
<tr class="separator:ga5336313575dfe47dd73f0847fcd21fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d4e9a766022085445c2d5c7f83606c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga7d4e9a766022085445c2d5c7f83606c8">pgm_read_dword</a>(__addr)&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga289488b882ba92d0364a9bf65f5dc472">pgm_read_dword_near</a>(__addr)</td></tr>
<tr class="separator:ga7d4e9a766022085445c2d5c7f83606c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a8ba8129bb0d60d76e04e003bbcf6c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga4a8ba8129bb0d60d76e04e003bbcf6c5">pgm_read_qword</a>(__addr)&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga22f9d07729cb6af716ec449a129756c3">pgm_read_qword_near</a>(__addr)</td></tr>
<tr class="separator:ga4a8ba8129bb0d60d76e04e003bbcf6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e93d1e5bf48f30fd1e30adeb4b7cc0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga8e93d1e5bf48f30fd1e30adeb4b7cc0f">pgm_read_ptr</a>(__addr)&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga59f916fc92569eed66b43f3b55286fdf">pgm_read_ptr_near</a>(__addr)</td></tr>
<tr class="separator:ga8e93d1e5bf48f30fd1e30adeb4b7cc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ddf0e398bde8078aa9395ac77c83f0a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga8ddf0e398bde8078aa9395ac77c83f0a">pgm_get_far_address</a>(var)</td></tr>
<tr class="separator:ga8ddf0e398bde8078aa9395ac77c83f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5b94d15a3754b21474882f0e78b79034"><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga5b94d15a3754b21474882f0e78b79034">pgm_read_char</a> (const char *__addr)</td></tr>
<tr class="separator:ga5b94d15a3754b21474882f0e78b79034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae148456a52c34b0d85a84bb18c30714f"><td class="memItemLeft" align="right" valign="top">static unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gae148456a52c34b0d85a84bb18c30714f">pgm_read_unsigned_char</a> (const unsigned char *__addr)</td></tr>
<tr class="separator:gae148456a52c34b0d85a84bb18c30714f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28c45b5c0bc7f579d6dfd7630cdb3a9f"><td class="memItemLeft" align="right" valign="top">static signed char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga28c45b5c0bc7f579d6dfd7630cdb3a9f">pgm_read_signed_char</a> (const signed char *__addr)</td></tr>
<tr class="separator:ga28c45b5c0bc7f579d6dfd7630cdb3a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47ae26c0b4eaf50c3fc34e42ae29fb50"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga47ae26c0b4eaf50c3fc34e42ae29fb50">pgm_read_u8</a> (const <a class="el" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *__addr)</td></tr>
<tr class="separator:ga47ae26c0b4eaf50c3fc34e42ae29fb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b2f96b2a94448a0115e5e643fc6c833"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#gaef44329758059c91c76d334e8fc09700">int8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga8b2f96b2a94448a0115e5e643fc6c833">pgm_read_i8</a> (const <a class="el" href="group__avr__stdint.html#gaef44329758059c91c76d334e8fc09700">int8_t</a> *__addr)</td></tr>
<tr class="separator:ga8b2f96b2a94448a0115e5e643fc6c833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9687bb7cd57b0ba6438eb2f6ae27d24e"><td class="memItemLeft" align="right" valign="top">static short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga9687bb7cd57b0ba6438eb2f6ae27d24e">pgm_read_short</a> (const short *__addr)</td></tr>
<tr class="separator:ga9687bb7cd57b0ba6438eb2f6ae27d24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b52aacc59d553e1a3650f8eb717bee0"><td class="memItemLeft" align="right" valign="top">static unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga3b52aacc59d553e1a3650f8eb717bee0">pgm_read_unsigned_short</a> (const unsigned short *__addr)</td></tr>
<tr class="separator:ga3b52aacc59d553e1a3650f8eb717bee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029a094fbadc53f1cfa11a7ebd47407e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga029a094fbadc53f1cfa11a7ebd47407e">pgm_read_u16</a> (const <a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> *__addr)</td></tr>
<tr class="separator:ga029a094fbadc53f1cfa11a7ebd47407e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga508e69d5a59c0a6b3003ecf72685bada"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#ga932e6ccc3d54c58f761c1aead83bd6d7">int16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga508e69d5a59c0a6b3003ecf72685bada">pgm_read_i16</a> (const <a class="el" href="group__avr__stdint.html#ga932e6ccc3d54c58f761c1aead83bd6d7">int16_t</a> *__addr)</td></tr>
<tr class="separator:ga508e69d5a59c0a6b3003ecf72685bada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga396a229774c8777cf60fb85838162112"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga396a229774c8777cf60fb85838162112">pgm_read_int</a> (const int *__addr)</td></tr>
<tr class="separator:ga396a229774c8777cf60fb85838162112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecfb85f02df17cb0684f9aff0d20e8f1"><td class="memItemLeft" align="right" valign="top">static signed&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaecfb85f02df17cb0684f9aff0d20e8f1">pgm_read_signed</a> (const signed *__addr)</td></tr>
<tr class="separator:gaecfb85f02df17cb0684f9aff0d20e8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69db18ec4b44bc5715f0fd360682c62"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaa69db18ec4b44bc5715f0fd360682c62">pgm_read_unsigned</a> (const unsigned *__addr)</td></tr>
<tr class="separator:gaa69db18ec4b44bc5715f0fd360682c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27574d768f21f7b751e9d2c816ddc63a"><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga27574d768f21f7b751e9d2c816ddc63a">pgm_read_signed_int</a> (const signed int *__addr)</td></tr>
<tr class="separator:ga27574d768f21f7b751e9d2c816ddc63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9606b280e7fc6b7cc1291b33b39a4bb"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaf9606b280e7fc6b7cc1291b33b39a4bb">pgm_read_unsigned_int</a> (const unsigned int *__addr)</td></tr>
<tr class="separator:gaf9606b280e7fc6b7cc1291b33b39a4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f97fed6250082fc1b7f70b54e076d1"><td class="memItemLeft" align="right" valign="top">static __int24&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga25f97fed6250082fc1b7f70b54e076d1">pgm_read_i24</a> (const __int24 *__addr)</td></tr>
<tr class="separator:ga25f97fed6250082fc1b7f70b54e076d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf016e9a49726aba810b165c4ea1c1506"><td class="memItemLeft" align="right" valign="top">static __uint24&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaf016e9a49726aba810b165c4ea1c1506">pgm_read_u24</a> (const __uint24 *__addr)</td></tr>
<tr class="separator:gaf016e9a49726aba810b165c4ea1c1506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedbf976492486d27c6ba89d17ed56064"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaedbf976492486d27c6ba89d17ed56064">pgm_read_u32</a> (const <a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a> *__addr)</td></tr>
<tr class="separator:gaedbf976492486d27c6ba89d17ed56064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d4ea3a7b9fa6cc2d62f57d402dc176b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#gadb828ef50c2dbb783109824e94cf6c47">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga1d4ea3a7b9fa6cc2d62f57d402dc176b">pgm_read_i32</a> (const <a class="el" href="group__avr__stdint.html#gadb828ef50c2dbb783109824e94cf6c47">int32_t</a> *__addr)</td></tr>
<tr class="separator:ga1d4ea3a7b9fa6cc2d62f57d402dc176b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829821d018ee3f61c4bbf2140eba9198"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga829821d018ee3f61c4bbf2140eba9198">pgm_read_long</a> (const long *__addr)</td></tr>
<tr class="separator:ga829821d018ee3f61c4bbf2140eba9198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ddeb788e72818f5a1a139ddb852323"><td class="memItemLeft" align="right" valign="top">static unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gab7ddeb788e72818f5a1a139ddb852323">pgm_read_unsigned_long</a> (const unsigned long *__addr)</td></tr>
<tr class="separator:gab7ddeb788e72818f5a1a139ddb852323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa78bc190a11225ede4afacb0399c96d1"><td class="memItemLeft" align="right" valign="top">static long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaa78bc190a11225ede4afacb0399c96d1">pgm_read_long_long</a> (const long long *__addr)</td></tr>
<tr class="separator:gaa78bc190a11225ede4afacb0399c96d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404a486439b0705ed4be84a7ead8bafd"><td class="memItemLeft" align="right" valign="top">static unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga404a486439b0705ed4be84a7ead8bafd">pgm_read_unsigned_long_long</a> (const unsigned long long *__addr)</td></tr>
<tr class="separator:ga404a486439b0705ed4be84a7ead8bafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cf7af3eb5541c64ba5dc4e2a3a59628"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#gad27ed092432b64ff558d2254c278720f">uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga7cf7af3eb5541c64ba5dc4e2a3a59628">pgm_read_u64</a> (const <a class="el" href="group__avr__stdint.html#gad27ed092432b64ff558d2254c278720f">uint64_t</a> *__addr)</td></tr>
<tr class="separator:ga7cf7af3eb5541c64ba5dc4e2a3a59628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25798fe932592e74cef67faf7afc199a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#ga831d6234342279926bb11bad3a37add9">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga25798fe932592e74cef67faf7afc199a">pgm_read_i64</a> (const <a class="el" href="group__avr__stdint.html#ga831d6234342279926bb11bad3a37add9">int64_t</a> *__addr)</td></tr>
<tr class="separator:ga25798fe932592e74cef67faf7afc199a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga523419c061658fc3a41945208cd3e187"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga523419c061658fc3a41945208cd3e187">pgm_read_float</a> (const float *__addr)</td></tr>
<tr class="separator:ga523419c061658fc3a41945208cd3e187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fc51493bab01665c8a3da37d2dcaebe"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga7fc51493bab01665c8a3da37d2dcaebe">pgm_read_double</a> (const double *__addr)</td></tr>
<tr class="separator:ga7fc51493bab01665c8a3da37d2dcaebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02567ea773c3f9e26430b9e37ab50cc7"><td class="memItemLeft" align="right" valign="top">static long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga02567ea773c3f9e26430b9e37ab50cc7">pgm_read_long_double</a> (const long double *__addr)</td></tr>
<tr class="separator:ga02567ea773c3f9e26430b9e37ab50cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8043af24b7c725ddc74c293b09c5dbf5"><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga8043af24b7c725ddc74c293b09c5dbf5">pgm_read_char_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga8043af24b7c725ddc74c293b09c5dbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c798b5aa6e056166b3bee5f90eb741a"><td class="memItemLeft" align="right" valign="top">static unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga1c798b5aa6e056166b3bee5f90eb741a">pgm_read_unsigned_char_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga1c798b5aa6e056166b3bee5f90eb741a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0e2265866e17bed2027c72860fb4ff8"><td class="memItemLeft" align="right" valign="top">static signed char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gab0e2265866e17bed2027c72860fb4ff8">pgm_read_signed_char_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:gab0e2265866e17bed2027c72860fb4ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5afa392e390a4c27c156ba15cd878161"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga5afa392e390a4c27c156ba15cd878161">pgm_read_u8_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga5afa392e390a4c27c156ba15cd878161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb49613a95b19bc8d8813993f0bd870"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#gaef44329758059c91c76d334e8fc09700">int8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga2bb49613a95b19bc8d8813993f0bd870">pgm_read_i8_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga2bb49613a95b19bc8d8813993f0bd870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad157d9fd55b4de10f02e3dc2e3d62621"><td class="memItemLeft" align="right" valign="top">static short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gad157d9fd55b4de10f02e3dc2e3d62621">pgm_read_short_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:gad157d9fd55b4de10f02e3dc2e3d62621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85fc77f3987ddf780b1f0b20086f1c68"><td class="memItemLeft" align="right" valign="top">static unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga85fc77f3987ddf780b1f0b20086f1c68">pgm_read_unsigned_short_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga85fc77f3987ddf780b1f0b20086f1c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07bb7e20850f034b26e6e900c60a1a35"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga07bb7e20850f034b26e6e900c60a1a35">pgm_read_u16_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga07bb7e20850f034b26e6e900c60a1a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d41b1c5dcf4bcc9d65f99d1cf97668a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#ga932e6ccc3d54c58f761c1aead83bd6d7">int16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga9d41b1c5dcf4bcc9d65f99d1cf97668a">pgm_read_i16_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga9d41b1c5dcf4bcc9d65f99d1cf97668a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga900da8fbfc76178d800a922da1c67ea2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga900da8fbfc76178d800a922da1c67ea2">pgm_read_int_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga900da8fbfc76178d800a922da1c67ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0577a34263cd3c37b4a154a5a8b52122"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga0577a34263cd3c37b4a154a5a8b52122">pgm_read_unsigned_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga0577a34263cd3c37b4a154a5a8b52122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadca607b1ed0af71fd1df3a3d6b8503b2"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gadca607b1ed0af71fd1df3a3d6b8503b2">pgm_read_unsigned_int_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:gadca607b1ed0af71fd1df3a3d6b8503b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fea32a5e9f52715c52df92220404a0f"><td class="memItemLeft" align="right" valign="top">static signed&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga0fea32a5e9f52715c52df92220404a0f">pgm_read_signed_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga0fea32a5e9f52715c52df92220404a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a2734585587aa59b76a57875431c560"><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga0a2734585587aa59b76a57875431c560">pgm_read_signed_int_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga0a2734585587aa59b76a57875431c560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4f9683df0de180139d26ac369d37b19"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gae4f9683df0de180139d26ac369d37b19">pgm_read_long_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:gae4f9683df0de180139d26ac369d37b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81a349025a44de8491f58c2989bb4d69"><td class="memItemLeft" align="right" valign="top">static unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga81a349025a44de8491f58c2989bb4d69">pgm_read_unsigned_long_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga81a349025a44de8491f58c2989bb4d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae550ae9cac2b2df6130b5f25ac3d4b8a"><td class="memItemLeft" align="right" valign="top">static __int24&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gae550ae9cac2b2df6130b5f25ac3d4b8a">pgm_read_i24_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:gae550ae9cac2b2df6130b5f25ac3d4b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce2813c0460890edf7c83c9b17ac601"><td class="memItemLeft" align="right" valign="top">static __uint24&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga2ce2813c0460890edf7c83c9b17ac601">pgm_read_u24_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga2ce2813c0460890edf7c83c9b17ac601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15391d44604ab305a56cbadb290ca6d4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga15391d44604ab305a56cbadb290ca6d4">pgm_read_u32_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga15391d44604ab305a56cbadb290ca6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e31bd96327999a481dc8c297bd3e00"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#gadb828ef50c2dbb783109824e94cf6c47">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga84e31bd96327999a481dc8c297bd3e00">pgm_read_i32_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga84e31bd96327999a481dc8c297bd3e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c95e3362c4632255148873f33bb926f"><td class="memItemLeft" align="right" valign="top">static long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga2c95e3362c4632255148873f33bb926f">pgm_read_long_long_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga2c95e3362c4632255148873f33bb926f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3e21a45aa8cc56cad5f0735e56c7fad"><td class="memItemLeft" align="right" valign="top">static unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaa3e21a45aa8cc56cad5f0735e56c7fad">pgm_read_unsigned_long_long_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:gaa3e21a45aa8cc56cad5f0735e56c7fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6933190c1b8b726ac2c757a4a2c9ed60"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#gad27ed092432b64ff558d2254c278720f">uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga6933190c1b8b726ac2c757a4a2c9ed60">pgm_read_u64_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga6933190c1b8b726ac2c757a4a2c9ed60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga991b7d0d6881b735a069c6529c9839fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__avr__stdint.html#ga831d6234342279926bb11bad3a37add9">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga991b7d0d6881b735a069c6529c9839fe">pgm_read_i64_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga991b7d0d6881b735a069c6529c9839fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9b9da50d9eaa5f9400165f8fa6f04d"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga3d9b9da50d9eaa5f9400165f8fa6f04d">pgm_read_float_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga3d9b9da50d9eaa5f9400165f8fa6f04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77d1707bafeb66cf7e93f522fe41fbea"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga77d1707bafeb66cf7e93f522fe41fbea">pgm_read_double_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:ga77d1707bafeb66cf7e93f522fe41fbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf597f7e5845c61395ba134a133350367"><td class="memItemLeft" align="right" valign="top">static long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaf597f7e5845c61395ba134a133350367">pgm_read_long_double_far</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __addr)</td></tr>
<tr class="separator:gaf597f7e5845c61395ba134a133350367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f0b73a84e00da51ae135affc706b34"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga44f0b73a84e00da51ae135affc706b34">memchr_P</a> (const void *, int __val, size_t __len)</td></tr>
<tr class="separator:ga44f0b73a84e00da51ae135affc706b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad6ef1bae7b79248b407bd5386144f5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaad6ef1bae7b79248b407bd5386144f5a">memcmp_P</a> (const void *, const void *, size_t)</td></tr>
<tr class="separator:gaad6ef1bae7b79248b407bd5386144f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga469016cff9c68b19838ad26e099b0fc3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga469016cff9c68b19838ad26e099b0fc3">memccpy_P</a> (void *, const void *, int __val, size_t)</td></tr>
<tr class="separator:ga469016cff9c68b19838ad26e099b0fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad92fa2ebe26e65fa424051047d21a0eb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gad92fa2ebe26e65fa424051047d21a0eb">memcpy_P</a> (void *, const void *, size_t)</td></tr>
<tr class="separator:gad92fa2ebe26e65fa424051047d21a0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c55bcabfac7853d1c42c428926a28c0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga4c55bcabfac7853d1c42c428926a28c0">memmem_P</a> (const void *, size_t, const void *, size_t)</td></tr>
<tr class="separator:ga4c55bcabfac7853d1c42c428926a28c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dd5ea616f34e8fdc2ae4fa9452d8a88"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga8dd5ea616f34e8fdc2ae4fa9452d8a88">memrchr_P</a> (const void *, int __val, size_t __len)</td></tr>
<tr class="separator:ga8dd5ea616f34e8fdc2ae4fa9452d8a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c1bae2b20f7d5ec00411c6378b8ed70"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga5c1bae2b20f7d5ec00411c6378b8ed70">strcat_P</a> (char *, const char *)</td></tr>
<tr class="separator:ga5c1bae2b20f7d5ec00411c6378b8ed70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga105078f0de82663d9cfe4963e6bc677e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga105078f0de82663d9cfe4963e6bc677e">strchr_P</a> (const char *, int __val)</td></tr>
<tr class="separator:ga105078f0de82663d9cfe4963e6bc677e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0934ce6517882f4146be5a7db9b23d6b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga0934ce6517882f4146be5a7db9b23d6b">strchrnul_P</a> (const char *, int __val)</td></tr>
<tr class="separator:ga0934ce6517882f4146be5a7db9b23d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1992debc7afba2e8ed9849e70875fb83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga1992debc7afba2e8ed9849e70875fb83">strcmp_P</a> (const char *, const char *)</td></tr>
<tr class="separator:ga1992debc7afba2e8ed9849e70875fb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5749897c91c479d02054fc02128de482"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga5749897c91c479d02054fc02128de482">strcpy_P</a> (char *, const char *)</td></tr>
<tr class="separator:ga5749897c91c479d02054fc02128de482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31710e9558b5dcfde425bb6de1da8f5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga31710e9558b5dcfde425bb6de1da8f5f">strcasecmp_P</a> (const char *, const char *)</td></tr>
<tr class="separator:ga31710e9558b5dcfde425bb6de1da8f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a2c0f8f5304d1e917823fcd8820beab"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga1a2c0f8f5304d1e917823fcd8820beab">strcasestr_P</a> (const char *, const char *)</td></tr>
<tr class="separator:ga1a2c0f8f5304d1e917823fcd8820beab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga341edaff751570df305fbc0c88191315"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga341edaff751570df305fbc0c88191315">strcspn_P</a> (const char *__s, const char *__reject)</td></tr>
<tr class="separator:ga341edaff751570df305fbc0c88191315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85328d5e578db3c60f9753cb1769dc96"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga85328d5e578db3c60f9753cb1769dc96">strlcat_P</a> (char *, const char *, size_t)</td></tr>
<tr class="separator:ga85328d5e578db3c60f9753cb1769dc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab95a4e6a4b527ee389c72bdabb991e08"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gab95a4e6a4b527ee389c72bdabb991e08">strlcpy_P</a> (char *, const char *, size_t)</td></tr>
<tr class="separator:gab95a4e6a4b527ee389c72bdabb991e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e4dec5f576bb5feaa30acc4768bbf3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga56e4dec5f576bb5feaa30acc4768bbf3">strnlen_P</a> (const char *, size_t)</td></tr>
<tr class="separator:ga56e4dec5f576bb5feaa30acc4768bbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6338572ed08352818ef6bd66d2bb05f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaa6338572ed08352818ef6bd66d2bb05f">strncmp_P</a> (const char *, const char *, size_t)</td></tr>
<tr class="separator:gaa6338572ed08352818ef6bd66d2bb05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga607e22360bf8fb4aea9b6640ebad9877"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga607e22360bf8fb4aea9b6640ebad9877">strncasecmp_P</a> (const char *, const char *, size_t)</td></tr>
<tr class="separator:ga607e22360bf8fb4aea9b6640ebad9877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8641381919448f62d9caa5bd81b84fbf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga8641381919448f62d9caa5bd81b84fbf">strncat_P</a> (char *, const char *, size_t)</td></tr>
<tr class="separator:ga8641381919448f62d9caa5bd81b84fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ed6a0ea90901b8ee8478b86d1b1c99a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga1ed6a0ea90901b8ee8478b86d1b1c99a">strncpy_P</a> (char *, const char *, size_t)</td></tr>
<tr class="separator:ga1ed6a0ea90901b8ee8478b86d1b1c99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b96ce3d46ddf902f2725b40154d8172"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga3b96ce3d46ddf902f2725b40154d8172">strpbrk_P</a> (const char *__s, const char *__accept)</td></tr>
<tr class="separator:ga3b96ce3d46ddf902f2725b40154d8172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75ac2cdafe9afac8c75d4abf8703f2da"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga75ac2cdafe9afac8c75d4abf8703f2da">strrchr_P</a> (const char *, int __val)</td></tr>
<tr class="separator:ga75ac2cdafe9afac8c75d4abf8703f2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga150a5b9ebbf493789834679bdc734857"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga150a5b9ebbf493789834679bdc734857">strsep_P</a> (char **__sp, const char *__delim)</td></tr>
<tr class="separator:ga150a5b9ebbf493789834679bdc734857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga619dc6dea5e2364f796735e1c5e4eee2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga619dc6dea5e2364f796735e1c5e4eee2">strspn_P</a> (const char *__s, const char *__accept)</td></tr>
<tr class="separator:ga619dc6dea5e2364f796735e1c5e4eee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab5ebf9615b5cf97686913850161a42f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaab5ebf9615b5cf97686913850161a42f">strstr_P</a> (const char *, const char *)</td></tr>
<tr class="separator:gaab5ebf9615b5cf97686913850161a42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c3f78c82b898b95834b7f1d695eb95e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga9c3f78c82b898b95834b7f1d695eb95e">strtok_P</a> (char *__s, const char *__delim)</td></tr>
<tr class="separator:ga9c3f78c82b898b95834b7f1d695eb95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48e69ae320350218ad89b18f01df120d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga48e69ae320350218ad89b18f01df120d">strtok_rP</a> (char *__s, const char *__delim, char **__last)</td></tr>
<tr class="separator:ga48e69ae320350218ad89b18f01df120d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ce249cbcdb9ff968c76a2d917072da9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga4ce249cbcdb9ff968c76a2d917072da9">strlen_PF</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src)</td></tr>
<tr class="separator:ga4ce249cbcdb9ff968c76a2d917072da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d8784b274a123972f1b99a4a0a6a0f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga80d8784b274a123972f1b99a4a0a6a0f">strnlen_PF</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src, size_t len)</td></tr>
<tr class="separator:ga80d8784b274a123972f1b99a4a0a6a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13cc6cd0692aeccaac2789350a16412b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga13cc6cd0692aeccaac2789350a16412b">memcpy_PF</a> (void *dest, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src, size_t len)</td></tr>
<tr class="separator:ga13cc6cd0692aeccaac2789350a16412b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5af73767ca6defbec02736072dfb30"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gacd5af73767ca6defbec02736072dfb30">strcpy_PF</a> (char *dest, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src)</td></tr>
<tr class="separator:gacd5af73767ca6defbec02736072dfb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae01ef4b7da280c394f6d2ca37597b8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga4ae01ef4b7da280c394f6d2ca37597b8">strncpy_PF</a> (char *dest, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src, size_t len)</td></tr>
<tr class="separator:ga4ae01ef4b7da280c394f6d2ca37597b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9530b4f628b49635c4085c269da8867a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga9530b4f628b49635c4085c269da8867a">strcat_PF</a> (char *dest, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src)</td></tr>
<tr class="separator:ga9530b4f628b49635c4085c269da8867a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf632b479b04d0c98caf94de85dc11f3e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaf632b479b04d0c98caf94de85dc11f3e">strlcat_PF</a> (char *dst, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src, size_t siz)</td></tr>
<tr class="separator:gaf632b479b04d0c98caf94de85dc11f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga903fbfd9dcf93630e7a5da710d170da0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga903fbfd9dcf93630e7a5da710d170da0">strncat_PF</a> (char *dest, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src, size_t len)</td></tr>
<tr class="separator:ga903fbfd9dcf93630e7a5da710d170da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13122ebb8bdc98e8da463ec258635220"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga13122ebb8bdc98e8da463ec258635220">strcmp_PF</a> (const char *s1, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> s2)</td></tr>
<tr class="separator:ga13122ebb8bdc98e8da463ec258635220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad02f2464a15d8b17308d91a6a6b35f9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gad02f2464a15d8b17308d91a6a6b35f9d">strncmp_PF</a> (const char *s1, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> s2, size_t n)</td></tr>
<tr class="separator:gad02f2464a15d8b17308d91a6a6b35f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8074edb4084248aaf1db54fe9acfc043"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga8074edb4084248aaf1db54fe9acfc043">strcasecmp_PF</a> (const char *s1, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> s2)</td></tr>
<tr class="separator:ga8074edb4084248aaf1db54fe9acfc043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac18e2d0d9cb78d71088b735567b94e4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gac18e2d0d9cb78d71088b735567b94e4b">strncasecmp_PF</a> (const char *s1, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> s2, size_t n)</td></tr>
<tr class="separator:gac18e2d0d9cb78d71088b735567b94e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae90f8c9f2c3433f0031a7dd5c449527d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gae90f8c9f2c3433f0031a7dd5c449527d">strchr_PF</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>, int __val)</td></tr>
<tr class="separator:gae90f8c9f2c3433f0031a7dd5c449527d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0786ca7dc919f41f4586689aa77b04ef"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga0786ca7dc919f41f4586689aa77b04ef">strstr_PF</a> (const char *s1, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> s2)</td></tr>
<tr class="separator:ga0786ca7dc919f41f4586689aa77b04ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6674a08f95d5daedce3079b96be63008"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga6674a08f95d5daedce3079b96be63008">strlcpy_PF</a> (char *dst, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src, size_t siz)</td></tr>
<tr class="separator:ga6674a08f95d5daedce3079b96be63008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f94c167fb27d0969a08e21f664ec067"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga6f94c167fb27d0969a08e21f664ec067">memcmp_PF</a> (const void *, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>, size_t)</td></tr>
<tr class="separator:ga6f94c167fb27d0969a08e21f664ec067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2fb71ebed915074ec815d9d8f876c52"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gae2fb71ebed915074ec815d9d8f876c52">strlen_P</a> (const char *s)</td></tr>
<tr class="separator:gae2fb71ebed915074ec815d9d8f876c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b5aef1b070b61c565d3576482c20c6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4b5aef1b070b61c565d3576482c20c6f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga4b5aef1b070b61c565d3576482c20c6f">pgm_read&lt; T &gt;</a> (const T *addr)</td></tr>
<tr class="separator:ga4b5aef1b070b61c565d3576482c20c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9533143f6be341f476071a8523470a44"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9533143f6be341f476071a8523470a44"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga9533143f6be341f476071a8523470a44">pgm_read_far&lt; T &gt;</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> addr)</td></tr>
<tr class="separator:ga9533143f6be341f476071a8523470a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io_8h.html">avr/io.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</span></div>
<div class="ttc" id="aio_8h_html"><div class="ttname"><a href="io_8h.html">io.h</a></div></div>
<div class="ttc" id="apgmspace_8h_html"><div class="ttname"><a href="pgmspace_8h.html">pgmspace.h</a></div></div>
</div><!-- fragment --><p>The functions in this module provide interfaces for a program to access data stored in program space (flash memory) of the device.</p>
<dl class="section note"><dt>Note</dt><dd>These functions are an attempt to provide some compatibility with header files that come with IAR C, to make porting applications between different compilers easier. This is not 100% compatibility though (GCC does not have full support for multiple address spaces yet).</dd>
<dd>
If you are working with strings which are completely based in RAM, use the standard string functions described in <a class="el" href="group__avr__string.html">&lt;string.h&gt;: Strings</a>.</dd>
<dd>
If possible, put your constant tables in the lower 64 KB and use <a class="el" href="group__avr__pgmspace.html#ga296eb4a3e03c26b13e6207ccd15dcb1e">pgm_read_byte_near()</a> or <a class="el" href="group__avr__pgmspace.html#ga5a46ba5b6638df8c254964424f10c0fb">pgm_read_word_near()</a> instead of <a class="el" href="group__avr__pgmspace.html#ga7e89771ca773d9a2eb7bd1696a23af8d">pgm_read_byte_far()</a> or <a class="el" href="group__avr__pgmspace.html#gaa77cd8c6f7c2a4c32c62b69463009700">pgm_read_word_far()</a> since it is more efficient that way, and you can still use the upper 64K for executable code. All functions that are suffixed with a <code>_P</code> <em>require</em> their arguments to be in the lower 64 KB of the flash ROM, as they do not use ELPM instructions. This is normally not a big concern as the linker setup arranges any program space constants declared using the macros from this header file so they are placed right after the interrupt vectors, and in front of any executable code. However, it can become a problem if there are too many of these constants, or for bootloaders on devices with more than 64 KB of ROM. <em>All these functions will not work in that situation.</em></dd>
<dd>
For <b>Xmega</b> devices, make sure the NVM controller command register (<code>NVM.CMD</code> or <code>NVM_CMD</code>) is set to 0x00 (NOP) before using any of these functions. </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga8ddf0e398bde8078aa9395ac77c83f0a" name="ga8ddf0e398bde8078aa9395ac77c83f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ddf0e398bde8078aa9395ac77c83f0a">&#9670;&#160;</a></span>pgm_get_far_address</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_get_far_address</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">var</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(({                                      \</div>
<div class="line">    <a class="code hl_typedef" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> __tmp;                              \</div>
<div class="line">                                                      \</div>
<div class="line">    __asm__ __volatile__ (                            \</div>
<div class="line">        <span class="stringliteral">&quot;ldi    %A0, lo8(%1)&quot;</span>           <span class="stringliteral">&quot;\n\t&quot;</span>        \</div>
<div class="line">        <span class="stringliteral">&quot;ldi    %B0, hi8(%1)&quot;</span>           <span class="stringliteral">&quot;\n\t&quot;</span>        \</div>
<div class="line">        <span class="stringliteral">&quot;ldi    %C0, hh8(%1)&quot;</span>           <span class="stringliteral">&quot;\n\t&quot;</span>        \</div>
<div class="line">        <span class="stringliteral">&quot;clr    %D0&quot;</span>                                  \</div>
<div class="line">        :   <span class="stringliteral">&quot;=d&quot;</span> (__tmp)                              \</div>
<div class="line">        :   <span class="stringliteral">&quot;i&quot;</span>  (&amp;(var))                             \</div>
<div class="line">    );                                                \</div>
<div class="line">    __tmp;                                            \</div>
<div class="line">}))</div>
<div class="ttc" id="agroup__avr__inttypes_html_ga72b6692e3f3123903c1a0d9a960c59b1"><div class="ttname"><a href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a></div><div class="ttdeci">uint32_t uint_farptr_t</div><div class="ttdef"><b>Definition:</b> inttypes.h:83</div></div>
</div><!-- fragment --><p>This macro evaluates to a <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> 32-bit "far" pointer (only 24 bits used) to data even beyond the 64 KiB limit for the 16-bit ordinary pointer. It is similar to the '&amp;' operator, with some limitations. Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Section .progmemx.data is located after all the code sections.</span></div>
<div class="line">__attribute__((section(<span class="stringliteral">&quot;.progmemx.data&quot;</span>)))</div>
<div class="line">const <span class="keywordtype">int</span> data[] = { 2, 3, 5, 7, 9, 11 };</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> get_data (<a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> idx)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> pdata = <a class="code hl_define" href="group__avr__pgmspace.html#ga8ddf0e398bde8078aa9395ac77c83f0a">pgm_get_far_address</a> (data[0]);</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="group__avr__pgmspace.html#ga900da8fbfc76178d800a922da1c67ea2">pgm_read_int_far</a> (pdata + idx * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__pgmspace_html_ga8ddf0e398bde8078aa9395ac77c83f0a"><div class="ttname"><a href="group__avr__pgmspace.html#ga8ddf0e398bde8078aa9395ac77c83f0a">pgm_get_far_address</a></div><div class="ttdeci">#define pgm_get_far_address(var)</div><div class="ttdef"><b>Definition:</b> pgmspace.h:1243</div></div>
<div class="ttc" id="agroup__avr__pgmspace_html_ga900da8fbfc76178d800a922da1c67ea2"><div class="ttname"><a href="group__avr__pgmspace.html#ga900da8fbfc76178d800a922da1c67ea2">pgm_read_int_far</a></div><div class="ttdeci">static int pgm_read_int_far(uint_farptr_t __addr)</div></div>
<div class="ttc" id="agroup__avr__stdint_html_gaba7bc1797add20fe3efdf37ced1182c5"><div class="ttname"><a href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a></div><div class="ttdeci">unsigned char uint8_t</div><div class="ttdef"><b>Definition:</b> stdint.h:83</div></div>
</div><!-- fragment --><p>Comments:</p>
<ul>
<li>The overhead is minimal and it's mainly due to the 32-bit size operation.</li>
<li>24 bit sizes guarantees the code compatibility for use in future devices.</li>
<li><code>var</code> has to be resolved at link-time as an existing symbol, i.e. a simple variable name, an array name, or an array or structure element provided the offset is known at compile-time, and <code>var</code> is located in static storage, etc.</li>
<li>The returned value is the symbol's <a class="el" href="mem_sections.html#sec_vma">VMA</a> (virtual memory address) determined by the linker and falls in the corresponding memory region. The AVR Harvard architecture requires non-overlapping VMA areas for the multiple <a class="el" href="mem_sections.html#sec_memory_regions">memory regions</a> in the processor: Flash ROM, RAM, and EEPROM. Typical offset for these are <code>0x0</code>, <code>0x800xx0</code>, and <code>0x810000</code> respectively, derived from the linker script used and linker options. </li>
</ul>

</div>
</div>
<a id="gae89a4ff0b5a887888fcf83c4701b310b" name="gae89a4ff0b5a887888fcf83c4701b310b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae89a4ff0b5a887888fcf83c4701b310b">&#9670;&#160;</a></span>pgm_read_byte</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_byte</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga296eb4a3e03c26b13e6207ccd15dcb1e">pgm_read_byte_near</a>(__addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a byte from the program space with a 16-bit (near) nyte-address. </p>

</div>
</div>
<a id="ga7e89771ca773d9a2eb7bd1696a23af8d" name="ga7e89771ca773d9a2eb7bd1696a23af8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e89771ca773d9a2eb7bd1696a23af8d">&#9670;&#160;</a></span>pgm_read_byte_far</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_byte_far</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;__ELPM (__addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a byte from the program space with a 32-bit (far) byte-address. </p>

</div>
</div>
<a id="ga296eb4a3e03c26b13e6207ccd15dcb1e" name="ga296eb4a3e03c26b13e6207ccd15dcb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga296eb4a3e03c26b13e6207ccd15dcb1e">&#9670;&#160;</a></span>pgm_read_byte_near</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_byte_near</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;__LPM ((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(__addr))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a byte from the program space with a 16-bit (near) byte-address. </p>

</div>
</div>
<a id="ga7d4e9a766022085445c2d5c7f83606c8" name="ga7d4e9a766022085445c2d5c7f83606c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d4e9a766022085445c2d5c7f83606c8">&#9670;&#160;</a></span>pgm_read_dword</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_dword</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga289488b882ba92d0364a9bf65f5dc472">pgm_read_dword_near</a>(__addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a double word from the program space with a 16-bit (near) byte-address. </p>

</div>
</div>
<a id="ga2ce625d37bbc5280d7cd316e8b273a4d" name="ga2ce625d37bbc5280d7cd316e8b273a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ce625d37bbc5280d7cd316e8b273a4d">&#9670;&#160;</a></span>pgm_read_dword_far</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_dword_far</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;__ELPM_dword (__addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a double word from the program space with a 32-bit (far) byte-address. </p>

</div>
</div>
<a id="ga289488b882ba92d0364a9bf65f5dc472" name="ga289488b882ba92d0364a9bf65f5dc472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga289488b882ba92d0364a9bf65f5dc472">&#9670;&#160;</a></span>pgm_read_dword_near</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_dword_near</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;    __LPM_dword ((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(__addr))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a double word from the program space with a 16-bit (near) byte-address. </p>

</div>
</div>
<a id="ga93b33ee6ceaf1dd3ebcfa6f4c96f8b27" name="ga93b33ee6ceaf1dd3ebcfa6f4c96f8b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93b33ee6ceaf1dd3ebcfa6f4c96f8b27">&#9670;&#160;</a></span>pgm_read_float_near</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_float_near</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga523419c061658fc3a41945208cd3e187">pgm_read_float</a> (addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a <code>float</code> from the program space with a 16-bit (near) byte-address. </p>

</div>
</div>
<a id="ga8e93d1e5bf48f30fd1e30adeb4b7cc0f" name="ga8e93d1e5bf48f30fd1e30adeb4b7cc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e93d1e5bf48f30fd1e30adeb4b7cc0f">&#9670;&#160;</a></span>pgm_read_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_ptr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga59f916fc92569eed66b43f3b55286fdf">pgm_read_ptr_near</a>(__addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a pointer from the program space with a 16-bit (near) byte-address. </p>

</div>
</div>
<a id="ga5d88a95758ece5f8805cf7c2d04b03cf" name="ga5d88a95758ece5f8805cf7c2d04b03cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d88a95758ece5f8805cf7c2d04b03cf">&#9670;&#160;</a></span>pgm_read_ptr_far</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_ptr_far</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;((void*) __ELPM_word (__addr))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a pointer from the program space with a 32-bit (far) byte-address. </p>

</div>
</div>
<a id="ga59f916fc92569eed66b43f3b55286fdf" name="ga59f916fc92569eed66b43f3b55286fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59f916fc92569eed66b43f3b55286fdf">&#9670;&#160;</a></span>pgm_read_ptr_near</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_ptr_near</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;    ((void*) __LPM_word ((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(__addr)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a pointer from the program space with a 16-bit (near) byte-address. </p>

</div>
</div>
<a id="ga4a8ba8129bb0d60d76e04e003bbcf6c5" name="ga4a8ba8129bb0d60d76e04e003bbcf6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a8ba8129bb0d60d76e04e003bbcf6c5">&#9670;&#160;</a></span>pgm_read_qword</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_qword</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga22f9d07729cb6af716ec449a129756c3">pgm_read_qword_near</a>(__addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a quad-word from the program space with a 16-bit (near) byte-address. </p>

</div>
</div>
<a id="ga8f304a81b2123b85026c72960c81c51c" name="ga8f304a81b2123b85026c72960c81c51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f304a81b2123b85026c72960c81c51c">&#9670;&#160;</a></span>pgm_read_qword_far</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_qword_far</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;__ELPM_qword (__addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a quad-word from the program space with a 32-bit (far) byte-address. </p>

</div>
</div>
<a id="ga22f9d07729cb6af716ec449a129756c3" name="ga22f9d07729cb6af716ec449a129756c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22f9d07729cb6af716ec449a129756c3">&#9670;&#160;</a></span>pgm_read_qword_near</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_qword_near</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;__LPM_qword ((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(__addr))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a quad-word from the program space with a 16-bit (near) byte-address. </p>

</div>
</div>
<a id="ga5336313575dfe47dd73f0847fcd21fed" name="ga5336313575dfe47dd73f0847fcd21fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5336313575dfe47dd73f0847fcd21fed">&#9670;&#160;</a></span>pgm_read_word</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_word</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga5a46ba5b6638df8c254964424f10c0fb">pgm_read_word_near</a>(__addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a word from the program space with a 16-bit (near) byte-address. </p>

</div>
</div>
<a id="gaa77cd8c6f7c2a4c32c62b69463009700" name="gaa77cd8c6f7c2a4c32c62b69463009700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa77cd8c6f7c2a4c32c62b69463009700">&#9670;&#160;</a></span>pgm_read_word_far</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_word_far</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;__ELPM_word (__addr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a word from the program space with a 32-bit (far) byte-address. </p>

</div>
</div>
<a id="ga5a46ba5b6638df8c254964424f10c0fb" name="ga5a46ba5b6638df8c254964424f10c0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a46ba5b6638df8c254964424f10c0fb">&#9670;&#160;</a></span>pgm_read_word_near</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_word_near</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__addr</td><td>)</td>
          <td>&#160;&#160;&#160;__LPM_word ((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(__addr))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a word from the program space with a 16-bit (near) byte-address. </p>

</div>
</div>
<a id="ga75acaba9e781937468d0911423bc0c35" name="ga75acaba9e781937468d0911423bc0c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75acaba9e781937468d0911423bc0c35">&#9670;&#160;</a></span>PROGMEM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROGMEM&#160;&#160;&#160;__attribute__((__progmem__))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attribute to use in order to declare an object being located in flash ROM. </p>

</div>
</div>
<a id="gae59d3b5091405672ec394d3903ee60c5" name="gae59d3b5091405672ec394d3903ee60c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae59d3b5091405672ec394d3903ee60c5">&#9670;&#160;</a></span>PROGMEM_FAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROGMEM_FAR&#160;&#160;&#160;__attribute__((__section__(&quot;.progmemx.data&quot;)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attribute to use in order to declare an object being located in far flash ROM. This is similar to <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>, except that it puts the static storage object in section <code><a class="el" href="mem_sections.html#sec_dot_progmemx">.progmemx.data</a></code>. In order to access the object, the <code>pgm_read_*_far</code> and <code>_PF</code> functions declare in this header can be used. In order to get its address, see <a class="el" href="group__avr__pgmspace.html#ga8ddf0e398bde8078aa9395ac77c83f0a">pgm_get_far_address()</a>.</p>
<p>It only makes sense to put read-only objects in this section, though the compiler does not diagnose when this is not the case. </p>

</div>
</div>
<a id="ga73809107539df84eaf01f6a4dea4fbff" name="ga73809107539df84eaf01f6a4dea4fbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73809107539df84eaf01f6a4dea4fbff">&#9670;&#160;</a></span>PSTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSTR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">str</td><td>)</td>
          <td>&#160;&#160;&#160;({ static const <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> char c[] = (str); &amp;c[0]; })</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to declare a static pointer to a string in program space. </p>

</div>
</div>
<a id="ga22972d0aa51e8b8dd64ce1a2b9c78edb" name="ga22972d0aa51e8b8dd64ce1a2b9c78edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22972d0aa51e8b8dd64ce1a2b9c78edb">&#9670;&#160;</a></span>PSTR_FAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSTR_FAR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">str</td><td>)</td>
          <td>&#160;&#160;&#160;({ static const <a class="el" href="group__avr__pgmspace.html#gae59d3b5091405672ec394d3903ee60c5">PROGMEM_FAR</a> char c[] = (str); <a class="el" href="group__avr__pgmspace.html#ga8ddf0e398bde8078aa9395ac77c83f0a">pgm_get_far_address</a>(c[0]); })</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to define a string literal in far program space, and to return its address of type <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga469016cff9c68b19838ad26e099b0fc3" name="ga469016cff9c68b19838ad26e099b0fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga469016cff9c68b19838ad26e099b0fc3">&#9670;&#160;</a></span>memccpy_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memccpy_P </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to <a class="el" href="group__avr__string.html#ga8f2913a691990ae107e9687b8949b553" title="Copy memory area.">memccpy()</a> except that <code>src</code> is pointer to a string in program space. </p>

</div>
</div>
<a id="ga44f0b73a84e00da51ae135affc706b34" name="ga44f0b73a84e00da51ae135affc706b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44f0b73a84e00da51ae135affc706b34">&#9670;&#160;</a></span>memchr_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * memchr_P </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan flash memory for a character. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga44f0b73a84e00da51ae135affc706b34" title="Scan flash memory for a character.">memchr_P()</a> function scans the first <code>len</code> bytes of the flash memory area pointed to by <code>s</code> for the character <code>val</code>. The first byte to match <code>val</code> (interpreted as an unsigned character) stops the operation.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga44f0b73a84e00da51ae135affc706b34" title="Scan flash memory for a character.">memchr_P()</a> function returns a pointer to the matching byte or <code>NULL</code> if the character does not occur in the given memory area. </dd></dl>

</div>
</div>
<a id="gaad6ef1bae7b79248b407bd5386144f5a" name="gaad6ef1bae7b79248b407bd5386144f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad6ef1bae7b79248b407bd5386144f5a">&#9670;&#160;</a></span>memcmp_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int memcmp_P </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare memory areas. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#gaad6ef1bae7b79248b407bd5386144f5a" title="Compare memory areas.">memcmp_P()</a> function compares the first <code>len</code> bytes of the memory areas <code>s1</code> and flash <code>s2</code>. The comparision is performed using unsigned char operations.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#gaad6ef1bae7b79248b407bd5386144f5a" title="Compare memory areas.">memcmp_P()</a> function returns an integer less than, equal to, or greater than zero if the first <code>len</code> bytes of <code>s1</code> is found, respectively, to be less than, to match, or be greater than the first <code>len</code> bytes of <code>s2</code>. </dd></dl>

</div>
</div>
<a id="ga6f94c167fb27d0969a08e21f664ec067" name="ga6f94c167fb27d0969a08e21f664ec067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f94c167fb27d0969a08e21f664ec067">&#9670;&#160;</a></span>memcmp_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int memcmp_PF </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare memory areas. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga6f94c167fb27d0969a08e21f664ec067" title="Compare memory areas.">memcmp_PF()</a> function compares the first <code>len</code> bytes of the memory areas <code>s1</code> and flash <code>s2</code>. The comparision is performed using unsigned char operations. It is an equivalent of <a class="el" href="group__avr__pgmspace.html#gaad6ef1bae7b79248b407bd5386144f5a" title="Compare memory areas.">memcmp_P()</a> function, except that it is capable working on all FLASH including the exteded area above 64kB.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga6f94c167fb27d0969a08e21f664ec067" title="Compare memory areas.">memcmp_PF()</a> function returns an integer less than, equal to, or greater than zero if the first <code>len</code> bytes of <code>s1</code> is found, respectively, to be less than, to match, or be greater than the first <code>len</code> bytes of <code>s2</code>. </dd></dl>

</div>
</div>
<a id="gad92fa2ebe26e65fa424051047d21a0eb" name="gad92fa2ebe26e65fa424051047d21a0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad92fa2ebe26e65fa424051047d21a0eb">&#9670;&#160;</a></span>memcpy_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memcpy_P </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__pgmspace.html#gad92fa2ebe26e65fa424051047d21a0eb">memcpy_P()</a> function is similar to <a class="el" href="group__avr__string.html#ga5f60008005ea7557430149926cf583d7" title="Copy a memory area.">memcpy()</a>, except the src string resides in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#gad92fa2ebe26e65fa424051047d21a0eb">memcpy_P()</a> function returns a pointer to dest. </dd></dl>

</div>
</div>
<a id="ga13cc6cd0692aeccaac2789350a16412b" name="ga13cc6cd0692aeccaac2789350a16412b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13cc6cd0692aeccaac2789350a16412b">&#9670;&#160;</a></span>memcpy_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memcpy_PF </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a memory block from flash to SRAM. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga13cc6cd0692aeccaac2789350a16412b" title="Copy a memory block from flash to SRAM.">memcpy_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga5f60008005ea7557430149926cf583d7" title="Copy a memory area.">memcpy()</a>, except the data is copied from the program space and is addressed using a far pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A pointer to the destination buffer </td></tr>
    <tr><td class="paramname">src</td><td>A far pointer to the origin of data in flash memory </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga13cc6cd0692aeccaac2789350a16412b" title="Copy a memory block from flash to SRAM.">memcpy_PF()</a> function returns a pointer to <em>dst</em>. The contents of RAMPZ SFR are undefined when the function returns. </dd></dl>

</div>
</div>
<a id="ga4c55bcabfac7853d1c42c428926a28c0" name="ga4c55bcabfac7853d1c42c428926a28c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c55bcabfac7853d1c42c428926a28c0">&#9670;&#160;</a></span>memmem_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memmem_P </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__pgmspace.html#ga4c55bcabfac7853d1c42c428926a28c0">memmem_P()</a> function is similar to <a class="el" href="group__avr__string.html#gac178bf2dc3d9273f5c54719e04130c2b">memmem()</a> except that <code>s2</code> is pointer to a string in program space. </p>

</div>
</div>
<a id="ga8dd5ea616f34e8fdc2ae4fa9452d8a88" name="ga8dd5ea616f34e8fdc2ae4fa9452d8a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dd5ea616f34e8fdc2ae4fa9452d8a88">&#9670;&#160;</a></span>memrchr_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void memrchr_P </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__pgmspace.html#ga8dd5ea616f34e8fdc2ae4fa9452d8a88">memrchr_P()</a> function is like the <a class="el" href="group__avr__pgmspace.html#ga44f0b73a84e00da51ae135affc706b34" title="Scan flash memory for a character.">memchr_P()</a> function, except that it searches backwards from the end of the <code>len</code> bytes pointed to by <code>src</code> instead of forwards from the front. (Glibc, GNU extension.)</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga8dd5ea616f34e8fdc2ae4fa9452d8a88">memrchr_P()</a> function returns a pointer to the matching byte or <code>NULL</code> if the character does not occur in the given memory area. </dd></dl>

</div>
</div>
<a id="ga4b5aef1b070b61c565d3576482c20c6f" name="ga4b5aef1b070b61c565d3576482c20c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b5aef1b070b61c565d3576482c20c6f">&#9670;&#160;</a></span>pgm_read&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pgm_read&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read an object of type <code>T</code> from program memory address <code>addr</code> and return it. This template is only available when macro <code>__pgm_read_template__</code> is defined. </p>

</div>
</div>
<a id="ga5b94d15a3754b21474882f0e78b79034" name="ga5b94d15a3754b21474882f0e78b79034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b94d15a3754b21474882f0e78b79034">&#9670;&#160;</a></span>pgm_read_char()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char pgm_read_char </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>char</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga8043af24b7c725ddc74c293b09c5dbf5" name="ga8043af24b7c725ddc74c293b09c5dbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8043af24b7c725ddc74c293b09c5dbf5">&#9670;&#160;</a></span>pgm_read_char_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char pgm_read_char_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>char</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga7fc51493bab01665c8a3da37d2dcaebe" name="ga7fc51493bab01665c8a3da37d2dcaebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fc51493bab01665c8a3da37d2dcaebe">&#9670;&#160;</a></span>pgm_read_double()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pgm_read_double </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>double</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga77d1707bafeb66cf7e93f522fe41fbea" name="ga77d1707bafeb66cf7e93f522fe41fbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77d1707bafeb66cf7e93f522fe41fbea">&#9670;&#160;</a></span>pgm_read_double_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double pgm_read_double_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>double</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga9533143f6be341f476071a8523470a44" name="ga9533143f6be341f476071a8523470a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9533143f6be341f476071a8523470a44">&#9670;&#160;</a></span>pgm_read_far&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pgm_read_far&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read an object of type <code>T</code> from program memory address <code>addr</code> and return it. This template is only available when macro <code>__pgm_read_template__</code> is defined. </p>

</div>
</div>
<a id="ga523419c061658fc3a41945208cd3e187" name="ga523419c061658fc3a41945208cd3e187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga523419c061658fc3a41945208cd3e187">&#9670;&#160;</a></span>pgm_read_float()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pgm_read_float </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>float</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga3d9b9da50d9eaa5f9400165f8fa6f04d" name="ga3d9b9da50d9eaa5f9400165f8fa6f04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d9b9da50d9eaa5f9400165f8fa6f04d">&#9670;&#160;</a></span>pgm_read_float_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float pgm_read_float_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>float</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga508e69d5a59c0a6b3003ecf72685bada" name="ga508e69d5a59c0a6b3003ecf72685bada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga508e69d5a59c0a6b3003ecf72685bada">&#9670;&#160;</a></span>pgm_read_i16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#ga932e6ccc3d54c58f761c1aead83bd6d7">int16_t</a> pgm_read_i16 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__avr__stdint.html#ga932e6ccc3d54c58f761c1aead83bd6d7">int16_t</a> *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>int16_t</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga9d41b1c5dcf4bcc9d65f99d1cf97668a" name="ga9d41b1c5dcf4bcc9d65f99d1cf97668a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d41b1c5dcf4bcc9d65f99d1cf97668a">&#9670;&#160;</a></span>pgm_read_i16_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#ga932e6ccc3d54c58f761c1aead83bd6d7">int16_t</a> pgm_read_i16_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>int16_t</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga25f97fed6250082fc1b7f70b54e076d1" name="ga25f97fed6250082fc1b7f70b54e076d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25f97fed6250082fc1b7f70b54e076d1">&#9670;&#160;</a></span>pgm_read_i24()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__int24 pgm_read_i24 </td>
          <td>(</td>
          <td class="paramtype">const __int24 *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>__int24</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="gae550ae9cac2b2df6130b5f25ac3d4b8a" name="gae550ae9cac2b2df6130b5f25ac3d4b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae550ae9cac2b2df6130b5f25ac3d4b8a">&#9670;&#160;</a></span>pgm_read_i24_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__int24 pgm_read_i24_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>__int24</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga1d4ea3a7b9fa6cc2d62f57d402dc176b" name="ga1d4ea3a7b9fa6cc2d62f57d402dc176b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d4ea3a7b9fa6cc2d62f57d402dc176b">&#9670;&#160;</a></span>pgm_read_i32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#gadb828ef50c2dbb783109824e94cf6c47">int32_t</a> pgm_read_i32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__avr__stdint.html#gadb828ef50c2dbb783109824e94cf6c47">int32_t</a> *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>int32_t</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga84e31bd96327999a481dc8c297bd3e00" name="ga84e31bd96327999a481dc8c297bd3e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84e31bd96327999a481dc8c297bd3e00">&#9670;&#160;</a></span>pgm_read_i32_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#gadb828ef50c2dbb783109824e94cf6c47">int32_t</a> pgm_read_i32_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>int32_t</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga25798fe932592e74cef67faf7afc199a" name="ga25798fe932592e74cef67faf7afc199a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25798fe932592e74cef67faf7afc199a">&#9670;&#160;</a></span>pgm_read_i64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#ga831d6234342279926bb11bad3a37add9">int64_t</a> pgm_read_i64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__avr__stdint.html#ga831d6234342279926bb11bad3a37add9">int64_t</a> *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>int64_t</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga991b7d0d6881b735a069c6529c9839fe" name="ga991b7d0d6881b735a069c6529c9839fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga991b7d0d6881b735a069c6529c9839fe">&#9670;&#160;</a></span>pgm_read_i64_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#ga831d6234342279926bb11bad3a37add9">int64_t</a> pgm_read_i64_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>int64_t</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga8b2f96b2a94448a0115e5e643fc6c833" name="ga8b2f96b2a94448a0115e5e643fc6c833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b2f96b2a94448a0115e5e643fc6c833">&#9670;&#160;</a></span>pgm_read_i8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#gaef44329758059c91c76d334e8fc09700">int8_t</a> pgm_read_i8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__avr__stdint.html#gaef44329758059c91c76d334e8fc09700">int8_t</a> *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>int8_t</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga2bb49613a95b19bc8d8813993f0bd870" name="ga2bb49613a95b19bc8d8813993f0bd870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bb49613a95b19bc8d8813993f0bd870">&#9670;&#160;</a></span>pgm_read_i8_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#gaef44329758059c91c76d334e8fc09700">int8_t</a> pgm_read_i8_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>int8_t</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga396a229774c8777cf60fb85838162112" name="ga396a229774c8777cf60fb85838162112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga396a229774c8777cf60fb85838162112">&#9670;&#160;</a></span>pgm_read_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pgm_read_int </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>int</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga900da8fbfc76178d800a922da1c67ea2" name="ga900da8fbfc76178d800a922da1c67ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga900da8fbfc76178d800a922da1c67ea2">&#9670;&#160;</a></span>pgm_read_int_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pgm_read_int_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>int</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga829821d018ee3f61c4bbf2140eba9198" name="ga829821d018ee3f61c4bbf2140eba9198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga829821d018ee3f61c4bbf2140eba9198">&#9670;&#160;</a></span>pgm_read_long()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long pgm_read_long </td>
          <td>(</td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>long</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga02567ea773c3f9e26430b9e37ab50cc7" name="ga02567ea773c3f9e26430b9e37ab50cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02567ea773c3f9e26430b9e37ab50cc7">&#9670;&#160;</a></span>pgm_read_long_double()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long double pgm_read_long_double </td>
          <td>(</td>
          <td class="paramtype">const long double *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>long double</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="gaf597f7e5845c61395ba134a133350367" name="gaf597f7e5845c61395ba134a133350367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf597f7e5845c61395ba134a133350367">&#9670;&#160;</a></span>pgm_read_long_double_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long double pgm_read_long_double_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>long double</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="gae4f9683df0de180139d26ac369d37b19" name="gae4f9683df0de180139d26ac369d37b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4f9683df0de180139d26ac369d37b19">&#9670;&#160;</a></span>pgm_read_long_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long pgm_read_long_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>long</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="gaa78bc190a11225ede4afacb0399c96d1" name="gaa78bc190a11225ede4afacb0399c96d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa78bc190a11225ede4afacb0399c96d1">&#9670;&#160;</a></span>pgm_read_long_long()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long pgm_read_long_long </td>
          <td>(</td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>long long</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga2c95e3362c4632255148873f33bb926f" name="ga2c95e3362c4632255148873f33bb926f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c95e3362c4632255148873f33bb926f">&#9670;&#160;</a></span>pgm_read_long_long_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long pgm_read_long_long_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>long long</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga9687bb7cd57b0ba6438eb2f6ae27d24e" name="ga9687bb7cd57b0ba6438eb2f6ae27d24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9687bb7cd57b0ba6438eb2f6ae27d24e">&#9670;&#160;</a></span>pgm_read_short()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short pgm_read_short </td>
          <td>(</td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>short</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="gad157d9fd55b4de10f02e3dc2e3d62621" name="gad157d9fd55b4de10f02e3dc2e3d62621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad157d9fd55b4de10f02e3dc2e3d62621">&#9670;&#160;</a></span>pgm_read_short_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short pgm_read_short_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>short</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="gaecfb85f02df17cb0684f9aff0d20e8f1" name="gaecfb85f02df17cb0684f9aff0d20e8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecfb85f02df17cb0684f9aff0d20e8f1">&#9670;&#160;</a></span>pgm_read_signed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed pgm_read_signed </td>
          <td>(</td>
          <td class="paramtype">const signed *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>signed</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga28c45b5c0bc7f579d6dfd7630cdb3a9f" name="ga28c45b5c0bc7f579d6dfd7630cdb3a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28c45b5c0bc7f579d6dfd7630cdb3a9f">&#9670;&#160;</a></span>pgm_read_signed_char()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed char pgm_read_signed_char </td>
          <td>(</td>
          <td class="paramtype">const signed char *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>signed char</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="gab0e2265866e17bed2027c72860fb4ff8" name="gab0e2265866e17bed2027c72860fb4ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0e2265866e17bed2027c72860fb4ff8">&#9670;&#160;</a></span>pgm_read_signed_char_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed char pgm_read_signed_char_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>signed char</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga0fea32a5e9f52715c52df92220404a0f" name="ga0fea32a5e9f52715c52df92220404a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fea32a5e9f52715c52df92220404a0f">&#9670;&#160;</a></span>pgm_read_signed_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed pgm_read_signed_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>signed</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga27574d768f21f7b751e9d2c816ddc63a" name="ga27574d768f21f7b751e9d2c816ddc63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27574d768f21f7b751e9d2c816ddc63a">&#9670;&#160;</a></span>pgm_read_signed_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed int pgm_read_signed_int </td>
          <td>(</td>
          <td class="paramtype">const signed int *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>signed int</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga0a2734585587aa59b76a57875431c560" name="ga0a2734585587aa59b76a57875431c560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a2734585587aa59b76a57875431c560">&#9670;&#160;</a></span>pgm_read_signed_int_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed int pgm_read_signed_int_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a <code>signed int</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga029a094fbadc53f1cfa11a7ebd47407e" name="ga029a094fbadc53f1cfa11a7ebd47407e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga029a094fbadc53f1cfa11a7ebd47407e">&#9670;&#160;</a></span>pgm_read_u16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> pgm_read_u16 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>uint16_t</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga07bb7e20850f034b26e6e900c60a1a35" name="ga07bb7e20850f034b26e6e900c60a1a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07bb7e20850f034b26e6e900c60a1a35">&#9670;&#160;</a></span>pgm_read_u16_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> pgm_read_u16_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>uint16_t</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="gaf016e9a49726aba810b165c4ea1c1506" name="gaf016e9a49726aba810b165c4ea1c1506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf016e9a49726aba810b165c4ea1c1506">&#9670;&#160;</a></span>pgm_read_u24()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__uint24 pgm_read_u24 </td>
          <td>(</td>
          <td class="paramtype">const __uint24 *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>__uint24</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga2ce2813c0460890edf7c83c9b17ac601" name="ga2ce2813c0460890edf7c83c9b17ac601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ce2813c0460890edf7c83c9b17ac601">&#9670;&#160;</a></span>pgm_read_u24_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__uint24 pgm_read_u24_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>__uint24</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="gaedbf976492486d27c6ba89d17ed56064" name="gaedbf976492486d27c6ba89d17ed56064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedbf976492486d27c6ba89d17ed56064">&#9670;&#160;</a></span>pgm_read_u32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a> pgm_read_u32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a> *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>uint32_t</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga15391d44604ab305a56cbadb290ca6d4" name="ga15391d44604ab305a56cbadb290ca6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15391d44604ab305a56cbadb290ca6d4">&#9670;&#160;</a></span>pgm_read_u32_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a> pgm_read_u32_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>uint32_t</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga7cf7af3eb5541c64ba5dc4e2a3a59628" name="ga7cf7af3eb5541c64ba5dc4e2a3a59628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cf7af3eb5541c64ba5dc4e2a3a59628">&#9670;&#160;</a></span>pgm_read_u64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#gad27ed092432b64ff558d2254c278720f">uint64_t</a> pgm_read_u64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__avr__stdint.html#gad27ed092432b64ff558d2254c278720f">uint64_t</a> *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>uint64_t</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga6933190c1b8b726ac2c757a4a2c9ed60" name="ga6933190c1b8b726ac2c757a4a2c9ed60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6933190c1b8b726ac2c757a4a2c9ed60">&#9670;&#160;</a></span>pgm_read_u64_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#gad27ed092432b64ff558d2254c278720f">uint64_t</a> pgm_read_u64_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>uint64_t</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga47ae26c0b4eaf50c3fc34e42ae29fb50" name="ga47ae26c0b4eaf50c3fc34e42ae29fb50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47ae26c0b4eaf50c3fc34e42ae29fb50">&#9670;&#160;</a></span>pgm_read_u8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> pgm_read_u8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>uint8_t</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga5afa392e390a4c27c156ba15cd878161" name="ga5afa392e390a4c27c156ba15cd878161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5afa392e390a4c27c156ba15cd878161">&#9670;&#160;</a></span>pgm_read_u8_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> pgm_read_u8_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>uint8_t</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="gaa69db18ec4b44bc5715f0fd360682c62" name="gaa69db18ec4b44bc5715f0fd360682c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa69db18ec4b44bc5715f0fd360682c62">&#9670;&#160;</a></span>pgm_read_unsigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned pgm_read_unsigned </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>unsigned</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="gae148456a52c34b0d85a84bb18c30714f" name="gae148456a52c34b0d85a84bb18c30714f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae148456a52c34b0d85a84bb18c30714f">&#9670;&#160;</a></span>pgm_read_unsigned_char()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char pgm_read_unsigned_char </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>unsigned char</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga1c798b5aa6e056166b3bee5f90eb741a" name="ga1c798b5aa6e056166b3bee5f90eb741a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c798b5aa6e056166b3bee5f90eb741a">&#9670;&#160;</a></span>pgm_read_unsigned_char_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char pgm_read_unsigned_char_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>unsigned char</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga0577a34263cd3c37b4a154a5a8b52122" name="ga0577a34263cd3c37b4a154a5a8b52122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0577a34263cd3c37b4a154a5a8b52122">&#9670;&#160;</a></span>pgm_read_unsigned_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned pgm_read_unsigned_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>unsigned</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="gaf9606b280e7fc6b7cc1291b33b39a4bb" name="gaf9606b280e7fc6b7cc1291b33b39a4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9606b280e7fc6b7cc1291b33b39a4bb">&#9670;&#160;</a></span>pgm_read_unsigned_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pgm_read_unsigned_int </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>unsigned int</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="gadca607b1ed0af71fd1df3a3d6b8503b2" name="gadca607b1ed0af71fd1df3a3d6b8503b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadca607b1ed0af71fd1df3a3d6b8503b2">&#9670;&#160;</a></span>pgm_read_unsigned_int_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int pgm_read_unsigned_int_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>unsigned int</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="gab7ddeb788e72818f5a1a139ddb852323" name="gab7ddeb788e72818f5a1a139ddb852323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7ddeb788e72818f5a1a139ddb852323">&#9670;&#160;</a></span>pgm_read_unsigned_long()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long pgm_read_unsigned_long </td>
          <td>(</td>
          <td class="paramtype">const unsigned long *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>unsigned long</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga81a349025a44de8491f58c2989bb4d69" name="ga81a349025a44de8491f58c2989bb4d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81a349025a44de8491f58c2989bb4d69">&#9670;&#160;</a></span>pgm_read_unsigned_long_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long pgm_read_unsigned_long_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>unsigned long</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga404a486439b0705ed4be84a7ead8bafd" name="ga404a486439b0705ed4be84a7ead8bafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga404a486439b0705ed4be84a7ead8bafd">&#9670;&#160;</a></span>pgm_read_unsigned_long_long()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long pgm_read_unsigned_long_long </td>
          <td>(</td>
          <td class="paramtype">const unsigned long long *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>unsigned long long</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="gaa3e21a45aa8cc56cad5f0735e56c7fad" name="gaa3e21a45aa8cc56cad5f0735e56c7fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3e21a45aa8cc56cad5f0735e56c7fad">&#9670;&#160;</a></span>pgm_read_unsigned_long_long_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long pgm_read_unsigned_long_long_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>unsigned long long</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga3b52aacc59d553e1a3650f8eb717bee0" name="ga3b52aacc59d553e1a3650f8eb717bee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b52aacc59d553e1a3650f8eb717bee0">&#9670;&#160;</a></span>pgm_read_unsigned_short()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short pgm_read_unsigned_short </td>
          <td>(</td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>unsigned short</code> from 16-bit (near) byte-address <code>__addr</code>. The address is in the lower 64 KiB of program memory. </p>

</div>
</div>
<a id="ga85fc77f3987ddf780b1f0b20086f1c68" name="ga85fc77f3987ddf780b1f0b20086f1c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85fc77f3987ddf780b1f0b20086f1c68">&#9670;&#160;</a></span>pgm_read_unsigned_short_far()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short pgm_read_unsigned_short_far </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>__addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an <code>unsigned short</code> from far byte-address <code>__addr</code>. The address is in the program memory. </p>

</div>
</div>
<a id="ga31710e9558b5dcfde425bb6de1da8f5f" name="ga31710e9558b5dcfde425bb6de1da8f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31710e9558b5dcfde425bb6de1da8f5f">&#9670;&#160;</a></span>strcasecmp_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strcasecmp_P </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings ignoring case. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga31710e9558b5dcfde425bb6de1da8f5f" title="Compare two strings ignoring case.">strcasecmp_P()</a> function compares the two strings <code>s1</code> and <code>s2</code>, ignoring the case of the characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>A pointer to a string in the devices SRAM. </td></tr>
    <tr><td class="paramname">s2</td><td>A pointer to a string in the devices Flash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga31710e9558b5dcfde425bb6de1da8f5f" title="Compare two strings ignoring case.">strcasecmp_P()</a> function returns an integer less than, equal to, or greater than zero if <code>s1</code> is found, respectively, to be less than, to match, or be greater than <code>s2</code>. A consequence of the ordering used by <a class="el" href="group__avr__pgmspace.html#ga31710e9558b5dcfde425bb6de1da8f5f" title="Compare two strings ignoring case.">strcasecmp_P()</a> is that if <code>s1</code> is an initial substring of <code>s2</code>, then <code>s1</code> is considered to be "less than" <code>s2</code>. </dd></dl>

</div>
</div>
<a id="ga8074edb4084248aaf1db54fe9acfc043" name="ga8074edb4084248aaf1db54fe9acfc043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8074edb4084248aaf1db54fe9acfc043">&#9670;&#160;</a></span>strcasecmp_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strcasecmp_PF </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings ignoring case. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga8074edb4084248aaf1db54fe9acfc043" title="Compare two strings ignoring case.">strcasecmp_PF()</a> function compares the two strings <em>s1</em> and <em>s2</em>, ignoring the case of the characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>A pointer to the first string in SRAM </td></tr>
    <tr><td class="paramname">s2</td><td>A far pointer to the second string in Flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga8074edb4084248aaf1db54fe9acfc043" title="Compare two strings ignoring case.">strcasecmp_PF()</a> function returns an integer less than, equal to, or greater than zero if <em>s1</em> is found, respectively, to be less than, to match, or be greater than <em>s2</em>. The contents of RAMPZ SFR are undefined when the function returns. </dd></dl>

</div>
</div>
<a id="ga1a2c0f8f5304d1e917823fcd8820beab" name="ga1a2c0f8f5304d1e917823fcd8820beab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a2c0f8f5304d1e917823fcd8820beab">&#9670;&#160;</a></span>strcasestr_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcasestr_P </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This funtion is similar to <a class="el" href="group__avr__string.html#gac75c55f679ed9d632442e90b44336fa4">strcasestr()</a> except that <code>s2</code> is pointer to a string in program space. </p>

</div>
</div>
<a id="ga5c1bae2b20f7d5ec00411c6378b8ed70" name="ga5c1bae2b20f7d5ec00411c6378b8ed70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c1bae2b20f7d5ec00411c6378b8ed70">&#9670;&#160;</a></span>strcat_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcat_P </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__pgmspace.html#ga5c1bae2b20f7d5ec00411c6378b8ed70">strcat_P()</a> function is similar to <a class="el" href="group__avr__string.html#ga1fd2a6e188f02599e5eeb17519f67f3e" title="Concatenate two strings.">strcat()</a> except that the <em>src</em> string must be located in program space (flash).</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga1fd2a6e188f02599e5eeb17519f67f3e" title="Concatenate two strings.">strcat()</a> function returns a pointer to the resulting string <em>dest</em>. </dd></dl>

</div>
</div>
<a id="ga9530b4f628b49635c4085c269da8867a" name="ga9530b4f628b49635c4085c269da8867a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9530b4f628b49635c4085c269da8867a">&#9670;&#160;</a></span>strcat_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcat_PF </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates two strings. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga9530b4f628b49635c4085c269da8867a" title="Concatenates two strings.">strcat_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga1fd2a6e188f02599e5eeb17519f67f3e" title="Concatenate two strings.">strcat()</a> except that the <em>src</em> string must be located in program space (flash) and is addressed using a far pointer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>A pointer to the destination string in SRAM </td></tr>
    <tr><td class="paramname">src</td><td>A far pointer to the string to be appended in Flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga9530b4f628b49635c4085c269da8867a" title="Concatenates two strings.">strcat_PF()</a> function returns a pointer to the resulting string <em>dst</em>. The contents of RAMPZ SFR are undefined when the function returns </dd></dl>

</div>
</div>
<a id="ga105078f0de82663d9cfe4963e6bc677e" name="ga105078f0de82663d9cfe4963e6bc677e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga105078f0de82663d9cfe4963e6bc677e">&#9670;&#160;</a></span>strchr_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * strchr_P </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate character in program space string. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga105078f0de82663d9cfe4963e6bc677e" title="Locate character in program space string.">strchr_P()</a> function locates the first occurrence of <code>val</code> (converted to a char) in the string pointed to by <code>s</code> in program space. The terminating null character is considered to be part of the string.</p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga105078f0de82663d9cfe4963e6bc677e" title="Locate character in program space string.">strchr_P()</a> function is similar to <a class="el" href="group__avr__string.html#gaa437df98a6fbb78201ed32fd82cbac70" title="Locate character in string.">strchr()</a> except that <code>s</code> is pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga105078f0de82663d9cfe4963e6bc677e" title="Locate character in program space string.">strchr_P()</a> function returns a pointer to the matched character or <code>NULL</code> if the character is not found. </dd></dl>

</div>
</div>
<a id="gae90f8c9f2c3433f0031a7dd5c449527d" name="gae90f8c9f2c3433f0031a7dd5c449527d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae90f8c9f2c3433f0031a7dd5c449527d">&#9670;&#160;</a></span>strchr_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> strchr_PF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate character in far program space string. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#gae90f8c9f2c3433f0031a7dd5c449527d" title="Locate character in far program space string.">strchr_PF()</a> function locates the first occurrence of <code>val</code> (converted to a char) in the string pointed to by <code>s</code> in far program space. The terminating null character is considered to be part of the string.</p>
<p>The <a class="el" href="group__avr__pgmspace.html#gae90f8c9f2c3433f0031a7dd5c449527d" title="Locate character in far program space string.">strchr_PF()</a> function is similar to <a class="el" href="group__avr__string.html#gaa437df98a6fbb78201ed32fd82cbac70" title="Locate character in string.">strchr()</a> except that <code>s</code> is a far pointer to a string in program space that's <em>not</em> <em>required</em> to be located in the lower 64 KiB block like it is the case for <a class="el" href="group__avr__pgmspace.html#ga105078f0de82663d9cfe4963e6bc677e" title="Locate character in program space string.">strchr_P()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#gae90f8c9f2c3433f0031a7dd5c449527d" title="Locate character in far program space string.">strchr_PF()</a> function returns a far pointer to the matched character or <code>0</code> if the character is not found. </dd></dl>

</div>
</div>
<a id="ga0934ce6517882f4146be5a7db9b23d6b" name="ga0934ce6517882f4146be5a7db9b23d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0934ce6517882f4146be5a7db9b23d6b">&#9670;&#160;</a></span>strchrnul_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * strchrnul_P </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__pgmspace.html#ga0934ce6517882f4146be5a7db9b23d6b">strchrnul_P()</a> function is like <a class="el" href="group__avr__pgmspace.html#ga105078f0de82663d9cfe4963e6bc677e" title="Locate character in program space string.">strchr_P()</a> except that if <code>c</code> is not found in <code>s</code>, then it returns a pointer to the null byte at the end of <code>s</code>, rather than <code>NULL</code>. (Glibc, GNU extension.)</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga0934ce6517882f4146be5a7db9b23d6b">strchrnul_P()</a> function returns a pointer to the matched character, or a pointer to the null byte at the end of <code>s</code> (i.e., <code>s+strlen</code>(s)) if the character is not found. </dd></dl>

</div>
</div>
<a id="ga1992debc7afba2e8ed9849e70875fb83" name="ga1992debc7afba2e8ed9849e70875fb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1992debc7afba2e8ed9849e70875fb83">&#9670;&#160;</a></span>strcmp_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strcmp_P </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__pgmspace.html#ga1992debc7afba2e8ed9849e70875fb83">strcmp_P()</a> function is similar to <a class="el" href="group__avr__string.html#ga21e4788b4a0ae39b11aa32e9a1079f98" title="Compare two strings.">strcmp()</a> except that <code>s2</code> is pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga1992debc7afba2e8ed9849e70875fb83">strcmp_P()</a> function returns an integer less than, equal to, or greater than zero if <code>s1</code> is found, respectively, to be less than, to match, or be greater than <code>s2</code>. A consequence of the ordering used by <a class="el" href="group__avr__pgmspace.html#ga1992debc7afba2e8ed9849e70875fb83">strcmp_P()</a> is that if <code>s1</code> is an initial substring of <code>s2</code>, then <code>s1</code> is considered to be "less than" <code>s2</code>. </dd></dl>

</div>
</div>
<a id="ga13122ebb8bdc98e8da463ec258635220" name="ga13122ebb8bdc98e8da463ec258635220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13122ebb8bdc98e8da463ec258635220">&#9670;&#160;</a></span>strcmp_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strcmp_PF </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two strings. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga13122ebb8bdc98e8da463ec258635220" title="Compares two strings.">strcmp_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga21e4788b4a0ae39b11aa32e9a1079f98" title="Compare two strings.">strcmp()</a> except that <em>s2</em> is a far pointer to a string in program space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>A pointer to the first string in SRAM </td></tr>
    <tr><td class="paramname">s2</td><td>A far pointer to the second string in Flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga13122ebb8bdc98e8da463ec258635220" title="Compares two strings.">strcmp_PF()</a> function returns an integer less than, equal to, or greater than zero if <em>s1</em> is found, respectively, to be less than, to match, or be greater than <em>s2</em>. The contents of RAMPZ SFR are undefined when the function returns. </dd></dl>

</div>
</div>
<a id="ga5749897c91c479d02054fc02128de482" name="ga5749897c91c479d02054fc02128de482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5749897c91c479d02054fc02128de482">&#9670;&#160;</a></span>strcpy_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcpy_P </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__pgmspace.html#ga5749897c91c479d02054fc02128de482">strcpy_P()</a> function is similar to <a class="el" href="group__avr__string.html#ga54e4f23104fa6f722f9459d2673a1eba" title="Copy a string.">strcpy()</a> except that src is a pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga5749897c91c479d02054fc02128de482">strcpy_P()</a> function returns a pointer to the destination string dest. </dd></dl>

</div>
</div>
<a id="gacd5af73767ca6defbec02736072dfb30" name="gacd5af73767ca6defbec02736072dfb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5af73767ca6defbec02736072dfb30">&#9670;&#160;</a></span>strcpy_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcpy_PF </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a string. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#gacd5af73767ca6defbec02736072dfb30" title="Duplicate a string.">strcpy_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga54e4f23104fa6f722f9459d2673a1eba" title="Copy a string.">strcpy()</a> except that <em>src</em> is a far pointer to a string in program space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>A pointer to the destination string in SRAM </td></tr>
    <tr><td class="paramname">src</td><td>A far pointer to the source string in Flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#gacd5af73767ca6defbec02736072dfb30" title="Duplicate a string.">strcpy_PF()</a> function returns a pointer to the destination string <em>dst</em>. The contents of RAMPZ SFR are undefined when the funcion returns. </dd></dl>

</div>
</div>
<a id="ga341edaff751570df305fbc0c88191315" name="ga341edaff751570df305fbc0c88191315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga341edaff751570df305fbc0c88191315">&#9670;&#160;</a></span>strcspn_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strcspn_P </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>reject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__pgmspace.html#ga341edaff751570df305fbc0c88191315">strcspn_P()</a> function calculates the length of the initial segment of <code>s</code> which consists entirely of characters not in <code>reject</code>. This function is similar to <a class="el" href="group__avr__string.html#gad7ce08c05c71c0248169fb99e5b62b55">strcspn()</a> except that <code>reject</code> is a pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga341edaff751570df305fbc0c88191315">strcspn_P()</a> function returns the number of characters in the initial segment of <code>s</code> which are not in the string <code>reject</code>. The terminating zero is not considered as a part of string. </dd></dl>

</div>
</div>
<a id="ga85328d5e578db3c60f9753cb1769dc96" name="ga85328d5e578db3c60f9753cb1769dc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85328d5e578db3c60f9753cb1769dc96">&#9670;&#160;</a></span>strlcat_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlcat_P </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two strings. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga85328d5e578db3c60f9753cb1769dc96" title="Concatenate two strings.">strlcat_P()</a> function is similar to <a class="el" href="group__avr__string.html#ga63e609bfa0d354dcd7e35b297c2e6fdd" title="Concatenate two strings.">strlcat()</a>, except that the <code>src</code> string must be located in program space (flash).</p>
<p>Appends <code>src</code> to string <code>dst</code> of size <code>siz</code> (unlike <a class="el" href="group__avr__string.html#gafa4a8701698b766f40180c735726cfe7" title="Concatenate two strings.">strncat()</a>, <code>siz</code> is the full size of <code>dst</code>, not space left). At most <code>siz-1</code> characters will be copied. Always NULL terminates (unless <code>siz</code> &lt;= <code>strlen(dst)</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga85328d5e578db3c60f9753cb1769dc96" title="Concatenate two strings.">strlcat_P()</a> function returns strlen(src) + MIN(siz,
strlen(initial dst)). If retval &gt;= siz, truncation occurred. </dd></dl>

</div>
</div>
<a id="gaf632b479b04d0c98caf94de85dc11f3e" name="gaf632b479b04d0c98caf94de85dc11f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf632b479b04d0c98caf94de85dc11f3e">&#9670;&#160;</a></span>strlcat_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlcat_PF </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two strings. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#gaf632b479b04d0c98caf94de85dc11f3e" title="Concatenate two strings.">strlcat_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga63e609bfa0d354dcd7e35b297c2e6fdd" title="Concatenate two strings.">strlcat()</a>, except that the <em>src</em> string must be located in program space (flash) and is addressed using a far pointer.</p>
<p>Appends src to string dst of size <em>n</em> (unlike <a class="el" href="group__avr__string.html#gafa4a8701698b766f40180c735726cfe7" title="Concatenate two strings.">strncat()</a>, <em>n</em> is the full size of <em>dst</em>, not space left). At most <em>n-1</em> characters will be copied. Always NULL terminates (unless <em>n</em> &lt;= strlen(<em>dst</em>)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>A pointer to the destination string in SRAM </td></tr>
    <tr><td class="paramname">src</td><td>A far pointer to the source string in Flash </td></tr>
    <tr><td class="paramname">n</td><td>The total number of bytes allocated to the destination string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#gaf632b479b04d0c98caf94de85dc11f3e" title="Concatenate two strings.">strlcat_PF()</a> function returns strlen(<em>src</em>) + MIN(<em>n</em>, strlen(initial <em>dst</em>)). If retval &gt;= <em>n</em>, truncation occurred. The contents of RAMPZ SFR are undefined when the funcion returns. </dd></dl>

</div>
</div>
<a id="gab95a4e6a4b527ee389c72bdabb991e08" name="gab95a4e6a4b527ee389c72bdabb991e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab95a4e6a4b527ee389c72bdabb991e08">&#9670;&#160;</a></span>strlcpy_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlcpy_P </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string from progmem to RAM. </p>
<p>Copy <code>src</code> to string <code>dst</code> of size <code>siz</code>. At most <code>siz-1</code> characters will be copied. Always NULL terminates (unless <code>siz</code> == 0). The <a class="el" href="group__avr__pgmspace.html#gab95a4e6a4b527ee389c72bdabb991e08" title="Copy a string from progmem to RAM.">strlcpy_P()</a> function is similar to <a class="el" href="group__avr__string.html#ga64bc119cf084d1ecfd95098994597f12" title="Copy a string.">strlcpy()</a> except that the <code>src</code> is pointer to a string in memory space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#gab95a4e6a4b527ee389c72bdabb991e08" title="Copy a string from progmem to RAM.">strlcpy_P()</a> function returns strlen(src). If retval &gt;= siz, truncation occurred. </dd></dl>

</div>
</div>
<a id="ga6674a08f95d5daedce3079b96be63008" name="ga6674a08f95d5daedce3079b96be63008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6674a08f95d5daedce3079b96be63008">&#9670;&#160;</a></span>strlcpy_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlcpy_PF </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string from progmem to RAM. </p>
<p>Copy src to string dst of size siz. At most siz-1 characters will be copied. Always NULL terminates (unless siz == 0).</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga6674a08f95d5daedce3079b96be63008" title="Copy a string from progmem to RAM.">strlcpy_PF()</a> function returns strlen(src). If retval &gt;= siz, truncation occurred. The contents of RAMPZ SFR are undefined when the function returns. </dd></dl>

</div>
</div>
<a id="gae2fb71ebed915074ec815d9d8f876c52" name="gae2fb71ebed915074ec815d9d8f876c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2fb71ebed915074ec815d9d8f876c52">&#9670;&#160;</a></span>strlen_P()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlen_P </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__pgmspace.html#gae2fb71ebed915074ec815d9d8f876c52">strlen_P()</a> function is similar to <a class="el" href="group__avr__string.html#ga219836f542ce53545052bed5353820ca" title="Calculate the length of a string.">strlen()</a>, except that src is a pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#gae2fb71ebed915074ec815d9d8f876c52">strlen_P()</a> function returns the number of characters in src.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__avr__pgmspace.html#gae2fb71ebed915074ec815d9d8f876c52">strlen_P()</a> is implemented as an inline function in the <a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a> header file, which will check if the length of the string is a constant and known at compile time. If it is not known at compile time, the macro will issue a call to __strlen_P() which will then calculate the length of the string as normal. </dd></dl>

</div>
</div>
<a id="ga4ce249cbcdb9ff968c76a2d917072da9" name="ga4ce249cbcdb9ff968c76a2d917072da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ce249cbcdb9ff968c76a2d917072da9">&#9670;&#160;</a></span>strlen_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlen_PF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the length of a string. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga4ce249cbcdb9ff968c76a2d917072da9" title="Obtain the length of a string.">strlen_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga219836f542ce53545052bed5353820ca" title="Calculate the length of a string.">strlen()</a>, except that <em>s</em> is a far pointer to a string in program space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A far pointer to the string in flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga4ce249cbcdb9ff968c76a2d917072da9" title="Obtain the length of a string.">strlen_PF()</a> function returns the number of characters in <em>s</em>. The contents of RAMPZ SFR are undefined when the function returns. </dd></dl>

</div>
</div>
<a id="ga607e22360bf8fb4aea9b6640ebad9877" name="ga607e22360bf8fb4aea9b6640ebad9877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga607e22360bf8fb4aea9b6640ebad9877">&#9670;&#160;</a></span>strncasecmp_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strncasecmp_P </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings ignoring case. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga607e22360bf8fb4aea9b6640ebad9877" title="Compare two strings ignoring case.">strncasecmp_P()</a> function is similar to <a class="el" href="group__avr__pgmspace.html#ga31710e9558b5dcfde425bb6de1da8f5f" title="Compare two strings ignoring case.">strcasecmp_P()</a>, except it only compares the first <code>n</code> characters of <code>s1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>A pointer to a string in the devices SRAM. </td></tr>
    <tr><td class="paramname">s2</td><td>A pointer to a string in the devices Flash. </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of bytes to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga607e22360bf8fb4aea9b6640ebad9877" title="Compare two strings ignoring case.">strncasecmp_P()</a> function returns an integer less than, equal to, or greater than zero if <code>s1</code> (or the first <code>n</code> bytes thereof) is found, respectively, to be less than, to match, or be greater than <code>s2</code>. A consequence of the ordering used by <a class="el" href="group__avr__pgmspace.html#ga607e22360bf8fb4aea9b6640ebad9877" title="Compare two strings ignoring case.">strncasecmp_P()</a> is that if <code>s1</code> is an initial substring of <code>s2</code>, then <code>s1</code> is considered to be "less than" <code>s2</code>. </dd></dl>

</div>
</div>
<a id="gac18e2d0d9cb78d71088b735567b94e4b" name="gac18e2d0d9cb78d71088b735567b94e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac18e2d0d9cb78d71088b735567b94e4b">&#9670;&#160;</a></span>strncasecmp_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strncasecmp_PF </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings ignoring case. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#gac18e2d0d9cb78d71088b735567b94e4b" title="Compare two strings ignoring case.">strncasecmp_PF()</a> function is similar to <a class="el" href="group__avr__pgmspace.html#ga8074edb4084248aaf1db54fe9acfc043" title="Compare two strings ignoring case.">strcasecmp_PF()</a>, except it only compares the first <em>n</em> characters of <em>s1</em> and the string in flash is addressed using a far pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>A pointer to a string in SRAM </td></tr>
    <tr><td class="paramname">s2</td><td>A far pointer to a string in Flash </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of bytes to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#gac18e2d0d9cb78d71088b735567b94e4b" title="Compare two strings ignoring case.">strncasecmp_PF()</a> function returns an integer less than, equal to, or greater than zero if <em>s1</em> (or the first <em>n</em> bytes thereof) is found, respectively, to be less than, to match, or be greater than <em>s2</em>. The contents of RAMPZ SFR are undefined when the function returns. </dd></dl>

</div>
</div>
<a id="ga8641381919448f62d9caa5bd81b84fbf" name="ga8641381919448f62d9caa5bd81b84fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8641381919448f62d9caa5bd81b84fbf">&#9670;&#160;</a></span>strncat_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strncat_P </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two strings. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga8641381919448f62d9caa5bd81b84fbf" title="Concatenate two strings.">strncat_P()</a> function is similar to <a class="el" href="group__avr__string.html#gafa4a8701698b766f40180c735726cfe7" title="Concatenate two strings.">strncat()</a>, except that the <em>src</em> string must be located in program space (flash).</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga8641381919448f62d9caa5bd81b84fbf" title="Concatenate two strings.">strncat_P()</a> function returns a pointer to the resulting string dest. </dd></dl>

</div>
</div>
<a id="ga903fbfd9dcf93630e7a5da710d170da0" name="ga903fbfd9dcf93630e7a5da710d170da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga903fbfd9dcf93630e7a5da710d170da0">&#9670;&#160;</a></span>strncat_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strncat_PF </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two strings. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga903fbfd9dcf93630e7a5da710d170da0" title="Concatenate two strings.">strncat_PF()</a> function is similar to <a class="el" href="group__avr__string.html#gafa4a8701698b766f40180c735726cfe7" title="Concatenate two strings.">strncat()</a>, except that the <em>src</em> string must be located in program space (flash) and is addressed using a far pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>A pointer to the destination string in SRAM </td></tr>
    <tr><td class="paramname">src</td><td>A far pointer to the source string in Flash </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of bytes to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga903fbfd9dcf93630e7a5da710d170da0" title="Concatenate two strings.">strncat_PF()</a> function returns a pointer to the resulting string <em>dst</em>. The contents of RAMPZ SFR are undefined when the function returns. </dd></dl>

</div>
</div>
<a id="gaa6338572ed08352818ef6bd66d2bb05f" name="gaa6338572ed08352818ef6bd66d2bb05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6338572ed08352818ef6bd66d2bb05f">&#9670;&#160;</a></span>strncmp_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strncmp_P </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__pgmspace.html#gaa6338572ed08352818ef6bd66d2bb05f">strncmp_P()</a> function is similar to <a class="el" href="group__avr__pgmspace.html#ga1992debc7afba2e8ed9849e70875fb83">strcmp_P()</a> except it only compares the first (at most) n characters of s1 and s2.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#gaa6338572ed08352818ef6bd66d2bb05f">strncmp_P()</a> function returns an integer less than, equal to, or greater than zero if s1 (or the first n bytes thereof) is found, respectively, to be less than, to match, or be greater than s2. </dd></dl>

</div>
</div>
<a id="gad02f2464a15d8b17308d91a6a6b35f9d" name="gad02f2464a15d8b17308d91a6a6b35f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad02f2464a15d8b17308d91a6a6b35f9d">&#9670;&#160;</a></span>strncmp_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strncmp_PF </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings with limited length. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#gad02f2464a15d8b17308d91a6a6b35f9d" title="Compare two strings with limited length.">strncmp_PF()</a> function is similar to <a class="el" href="group__avr__pgmspace.html#ga13122ebb8bdc98e8da463ec258635220" title="Compares two strings.">strcmp_PF()</a> except it only compares the first (at most) <em>n</em> characters of <em>s1</em> and <em>s2</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>A pointer to the first string in SRAM </td></tr>
    <tr><td class="paramname">s2</td><td>A far pointer to the second string in Flash </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of bytes to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#gad02f2464a15d8b17308d91a6a6b35f9d" title="Compare two strings with limited length.">strncmp_PF()</a> function returns an integer less than, equal to, or greater than zero if <em>s1</em> (or the first <em>n</em> bytes thereof) is found, respectively, to be less than, to match, or be greater than <em>s2</em>. The contents of RAMPZ SFR are undefined when the function returns. </dd></dl>

</div>
</div>
<a id="ga1ed6a0ea90901b8ee8478b86d1b1c99a" name="ga1ed6a0ea90901b8ee8478b86d1b1c99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ed6a0ea90901b8ee8478b86d1b1c99a">&#9670;&#160;</a></span>strncpy_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strncpy_P </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__pgmspace.html#ga1ed6a0ea90901b8ee8478b86d1b1c99a">strncpy_P()</a> function is similar to <a class="el" href="group__avr__pgmspace.html#ga5749897c91c479d02054fc02128de482">strcpy_P()</a> except that not more than n bytes of src are copied. Thus, if there is no null byte among the first n bytes of src, the result will not be null-terminated.</p>
<p>In the case where the length of src is less than that of n, the remainder of dest will be padded with nulls.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga1ed6a0ea90901b8ee8478b86d1b1c99a">strncpy_P()</a> function returns a pointer to the destination string dest. </dd></dl>

</div>
</div>
<a id="ga4ae01ef4b7da280c394f6d2ca37597b8" name="ga4ae01ef4b7da280c394f6d2ca37597b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ae01ef4b7da280c394f6d2ca37597b8">&#9670;&#160;</a></span>strncpy_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strncpy_PF </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a string until a limited length. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga4ae01ef4b7da280c394f6d2ca37597b8" title="Duplicate a string until a limited length.">strncpy_PF()</a> function is similar to <a class="el" href="group__avr__pgmspace.html#gacd5af73767ca6defbec02736072dfb30" title="Duplicate a string.">strcpy_PF()</a> except that not more than <em>n</em> bytes of <em>src</em> are copied. Thus, if there is no null byte among the first <em>n</em> bytes of <em>src</em>, the result will not be null-terminated.</p>
<p>In the case where the length of <em>src</em> is less than that of <em>n</em>, the remainder of <em>dst</em> will be padded with nulls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>A pointer to the destination string in SRAM </td></tr>
    <tr><td class="paramname">src</td><td>A far pointer to the source string in Flash </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga4ae01ef4b7da280c394f6d2ca37597b8" title="Duplicate a string until a limited length.">strncpy_PF()</a> function returns a pointer to the destination string <em>dst</em>. The contents of RAMPZ SFR are undefined when the function returns. </dd></dl>

</div>
</div>
<a id="ga56e4dec5f576bb5feaa30acc4768bbf3" name="ga56e4dec5f576bb5feaa30acc4768bbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56e4dec5f576bb5feaa30acc4768bbf3">&#9670;&#160;</a></span>strnlen_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strnlen_P </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the length of a fixed-size string. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga56e4dec5f576bb5feaa30acc4768bbf3" title="Determine the length of a fixed-size string.">strnlen_P()</a> function is similar to <a class="el" href="group__avr__string.html#gaddfb5fb346ea0c5aac48c4f9dde6525b" title="Determine the length of a fixed-size string.">strnlen()</a>, except that <code>src</code> is a pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The strnlen_P function returns strlen_P(src), if that is less than <code>len</code>, or <code>len</code> if there is no '\0' character among the first <code>len</code> characters pointed to by <code>src</code>. </dd></dl>

</div>
</div>
<a id="ga80d8784b274a123972f1b99a4a0a6a0f" name="ga80d8784b274a123972f1b99a4a0a6a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80d8784b274a123972f1b99a4a0a6a0f">&#9670;&#160;</a></span>strnlen_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strnlen_PF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the length of a fixed-size string. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga80d8784b274a123972f1b99a4a0a6a0f" title="Determine the length of a fixed-size string.">strnlen_PF()</a> function is similar to <a class="el" href="group__avr__string.html#gaddfb5fb346ea0c5aac48c4f9dde6525b" title="Determine the length of a fixed-size string.">strnlen()</a>, except that <em>s</em> is a far pointer to a string in program space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A far pointer to the string in Flash </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of length to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The strnlen_PF function returns strlen_P(<em>s</em>), if that is less than <em>len</em>, or <em>len</em> if there is no '\0' character among the first <em>len</em> characters pointed to by <em>s</em>. The contents of RAMPZ SFR are undefined when the function returns. </dd></dl>

</div>
</div>
<a id="ga3b96ce3d46ddf902f2725b40154d8172" name="ga3b96ce3d46ddf902f2725b40154d8172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b96ce3d46ddf902f2725b40154d8172">&#9670;&#160;</a></span>strpbrk_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strpbrk_P </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>accept</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__pgmspace.html#ga3b96ce3d46ddf902f2725b40154d8172">strpbrk_P()</a> function locates the first occurrence in the string <code>s</code> of any of the characters in the flash string <code>accept</code>. This function is similar to <a class="el" href="group__avr__string.html#ga4f04d57afe38e7d3b6a87411a7847d62">strpbrk()</a> except that <code>accept</code> is a pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga3b96ce3d46ddf902f2725b40154d8172">strpbrk_P()</a> function returns a pointer to the character in <code>s</code> that matches one of the characters in <code>accept</code>, or <code>NULL</code> if no such character is found. The terminating zero is not considered as a part of string: if one or both args are empty, the result will <code>NULL</code>. </dd></dl>

</div>
</div>
<a id="ga75ac2cdafe9afac8c75d4abf8703f2da" name="ga75ac2cdafe9afac8c75d4abf8703f2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75ac2cdafe9afac8c75d4abf8703f2da">&#9670;&#160;</a></span>strrchr_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * strrchr_P </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate character in string. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga75ac2cdafe9afac8c75d4abf8703f2da" title="Locate character in string.">strrchr_P()</a> function returns a pointer to the last occurrence of the character <code>val</code> in the flash string <code>s</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga75ac2cdafe9afac8c75d4abf8703f2da" title="Locate character in string.">strrchr_P()</a> function returns a pointer to the matched character or <code>NULL</code> if the character is not found. </dd></dl>

</div>
</div>
<a id="ga150a5b9ebbf493789834679bdc734857" name="ga150a5b9ebbf493789834679bdc734857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga150a5b9ebbf493789834679bdc734857">&#9670;&#160;</a></span>strsep_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strsep_P </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a string into tokens. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga150a5b9ebbf493789834679bdc734857" title="Parse a string into tokens.">strsep_P()</a> function locates, in the string referenced by <code>*sp</code>, the first occurrence of any character in the string <code>delim</code> (or the terminating '\0' character) and replaces it with a '\0'. The location of the next character after the delimiter character (or <code>NULL</code>, if the end of the string was reached) is stored in <code>*sp</code>. An ``empty'' field, i.e. one caused by two adjacent delimiter characters, can be detected by comparing the location referenced by the pointer returned in <code>*sp</code> to '\0'. This function is similar to <a class="el" href="group__avr__string.html#gaff88adec2ad0446259766197ec3863de" title="Parse a string into tokens.">strsep()</a> except that <code>delim</code> is a pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga150a5b9ebbf493789834679bdc734857" title="Parse a string into tokens.">strsep_P()</a> function returns a pointer to the original value of <code>*sp</code>. If <code>*sp</code> is initially <code>NULL</code>, <a class="el" href="group__avr__pgmspace.html#ga150a5b9ebbf493789834679bdc734857" title="Parse a string into tokens.">strsep_P()</a> returns <code>NULL</code>. </dd></dl>

</div>
</div>
<a id="ga619dc6dea5e2364f796735e1c5e4eee2" name="ga619dc6dea5e2364f796735e1c5e4eee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga619dc6dea5e2364f796735e1c5e4eee2">&#9670;&#160;</a></span>strspn_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strspn_P </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>accept</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__pgmspace.html#ga619dc6dea5e2364f796735e1c5e4eee2">strspn_P()</a> function calculates the length of the initial segment of <code>s</code> which consists entirely of characters in <code>accept</code>. This function is similar to <a class="el" href="group__avr__string.html#gae1aaee71cf6ce8eb7ce0a17788df791e">strspn()</a> except that <code>accept</code> is a pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga619dc6dea5e2364f796735e1c5e4eee2">strspn_P()</a> function returns the number of characters in the initial segment of <code>s</code> which consist only of characters from <code>accept</code>. The terminating zero is not considered as a part of string. </dd></dl>

</div>
</div>
<a id="gaab5ebf9615b5cf97686913850161a42f" name="gaab5ebf9615b5cf97686913850161a42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab5ebf9615b5cf97686913850161a42f">&#9670;&#160;</a></span>strstr_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strstr_P </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate a substring. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#gaab5ebf9615b5cf97686913850161a42f" title="Locate a substring.">strstr_P()</a> function finds the first occurrence of the substring <code>s2</code> in the string <code>s1</code>. The terminating '\0' characters are not compared. The <a class="el" href="group__avr__pgmspace.html#gaab5ebf9615b5cf97686913850161a42f" title="Locate a substring.">strstr_P()</a> function is similar to <a class="el" href="group__avr__string.html#ga1c61c16078e8815acaa3a304e1a42fa6" title="Locate a substring.">strstr()</a> except that <code>s2</code> is pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#gaab5ebf9615b5cf97686913850161a42f" title="Locate a substring.">strstr_P()</a> function returns a pointer to the beginning of the substring, or NULL if the substring is not found. If <code>s2</code> points to a string of zero length, the function returns <code>s1</code>. </dd></dl>

</div>
</div>
<a id="ga0786ca7dc919f41f4586689aa77b04ef" name="ga0786ca7dc919f41f4586689aa77b04ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0786ca7dc919f41f4586689aa77b04ef">&#9670;&#160;</a></span>strstr_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strstr_PF </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate a substring. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga0786ca7dc919f41f4586689aa77b04ef" title="Locate a substring.">strstr_PF()</a> function finds the first occurrence of the substring <code>s2</code> in the string <code>s1</code>. The terminating '\0' characters are not compared. The <a class="el" href="group__avr__pgmspace.html#ga0786ca7dc919f41f4586689aa77b04ef" title="Locate a substring.">strstr_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga1c61c16078e8815acaa3a304e1a42fa6" title="Locate a substring.">strstr()</a> except that <code>s2</code> is a far pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga0786ca7dc919f41f4586689aa77b04ef" title="Locate a substring.">strstr_PF()</a> function returns a pointer to the beginning of the substring, or NULL if the substring is not found. If <code>s2</code> points to a string of zero length, the function returns <code>s1</code>. The contents of RAMPZ SFR are undefined when the function returns. </dd></dl>

</div>
</div>
<a id="ga9c3f78c82b898b95834b7f1d695eb95e" name="ga9c3f78c82b898b95834b7f1d695eb95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c3f78c82b898b95834b7f1d695eb95e">&#9670;&#160;</a></span>strtok_P()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strtok_P </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the string into tokens. </p>
<p><a class="el" href="group__avr__pgmspace.html#ga9c3f78c82b898b95834b7f1d695eb95e" title="Parses the string into tokens.">strtok_P()</a> parses the string <code>s</code> into tokens. The first call to <a class="el" href="group__avr__pgmspace.html#ga9c3f78c82b898b95834b7f1d695eb95e" title="Parses the string into tokens.">strtok_P()</a> should have <code>s</code> as its first argument. Subsequent calls should have the first argument set to NULL. If a token ends with a delimiter, this delimiting character is overwritten with a '\0' and a pointer to the next character is saved for the next call to <a class="el" href="group__avr__pgmspace.html#ga9c3f78c82b898b95834b7f1d695eb95e" title="Parses the string into tokens.">strtok_P()</a>. The delimiter string <code>delim</code> may be different for each call.</p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga9c3f78c82b898b95834b7f1d695eb95e" title="Parses the string into tokens.">strtok_P()</a> function is similar to <a class="el" href="group__avr__string.html#ga6ace85338eafe22a0ff52c00eb9779b8" title="Parses the string s into tokens.">strtok()</a> except that <code>delim</code> is pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga9c3f78c82b898b95834b7f1d695eb95e" title="Parses the string into tokens.">strtok_P()</a> function returns a pointer to the next token or NULL when no more tokens are found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__avr__pgmspace.html#ga9c3f78c82b898b95834b7f1d695eb95e" title="Parses the string into tokens.">strtok_P()</a> is NOT reentrant. For a reentrant version of this function see <a class="el" href="group__avr__pgmspace.html#ga48e69ae320350218ad89b18f01df120d" title="Parses string into tokens.">strtok_rP()</a>. </dd></dl>

</div>
</div>
<a id="ga48e69ae320350218ad89b18f01df120d" name="ga48e69ae320350218ad89b18f01df120d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48e69ae320350218ad89b18f01df120d">&#9670;&#160;</a></span>strtok_rP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strtok_rP </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses string into tokens. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga48e69ae320350218ad89b18f01df120d" title="Parses string into tokens.">strtok_rP()</a> function parses <code>string</code> into tokens. The first call to <a class="el" href="group__avr__pgmspace.html#ga48e69ae320350218ad89b18f01df120d" title="Parses string into tokens.">strtok_rP()</a> should have string as its first argument. Subsequent calls should have the first argument set to NULL. If a token ends with a delimiter, this delimiting character is overwritten with a '\0' and a pointer to the next character is saved for the next call to <a class="el" href="group__avr__pgmspace.html#ga48e69ae320350218ad89b18f01df120d" title="Parses string into tokens.">strtok_rP()</a>. The delimiter string <code>delim</code> may be different for each call. <code>last</code> is a user allocated char* pointer. It must be the same while parsing the same string. <a class="el" href="group__avr__pgmspace.html#ga48e69ae320350218ad89b18f01df120d" title="Parses string into tokens.">strtok_rP()</a> is a reentrant version of <a class="el" href="group__avr__pgmspace.html#ga9c3f78c82b898b95834b7f1d695eb95e" title="Parses the string into tokens.">strtok_P()</a>.</p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga48e69ae320350218ad89b18f01df120d" title="Parses string into tokens.">strtok_rP()</a> function is similar to <a class="el" href="group__avr__string.html#gac0dbc25e8b202114031a4aa2a7c5177b" title="Parses string into tokens.">strtok_r()</a> except that <code>delim</code> is pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga48e69ae320350218ad89b18f01df120d" title="Parses string into tokens.">strtok_rP()</a> function returns a pointer to the next token or NULL when no more tokens are found. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 9 2024 00:30:42 for AVR-LibC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.6
</small></address>
</body>
</html>
