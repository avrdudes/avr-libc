<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<title>AVR-LibC: &lt;string.h&gt;: Strings</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AVR-LibC
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
   <div id="projectbrief">Standard C library for AVR-GCC</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table>
  <tr>
    <td align="left"><a href="https://avrdudes.github.io/avr-libc/"><h2>AVR-LibC Documentation</h2></a></td>
    <td align="center" colspan=4><img src="avr-libc-logo.png" alt="Logo" align="middle" border="0"></td>
    <td align="right"><a href="https://github.com/avrdudes/avr-libc/"><h2>AVR-LibC Development Pages</h2></a></td>
  </tr>
  <tr>
    <td align="center" width="16%"><a href="index.html"><h2>Main Page</h2></a></td>
    <td align="center" width="16%"><a href="pages.html"><h2>User Manual</h2></a></td>
    <td align="center" width="16%"><a href="modules.html"><h2>Library Reference</h2></a></td>
    <td align="center" width="16%"><a href="FAQ.html"><h2>FAQ</h2></a></td>
    <td align="center" width="16%"><a href="group__demos.html"><h2>Example Projects</h2></a></td>
    <td align="center" width="16%"><a href="files.html"><h2>File List</h2></a></td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">&lt;string.h&gt;: Strings</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaedb0e7bb7333d6122472acddb5df20ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gaedb0e7bb7333d6122472acddb5df20ac">_FFS</a>(x)</td></tr>
<tr class="separator:gaedb0e7bb7333d6122472acddb5df20ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab978764fd2814cd14f9f1a3620aa4ca2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gab978764fd2814cd14f9f1a3620aa4ca2">ffs</a> (int __val)</td></tr>
<tr class="separator:gab978764fd2814cd14f9f1a3620aa4ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc4734579c84c1b33a9ba9433f2063e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gacc4734579c84c1b33a9ba9433f2063e4">ffsl</a> (long __val)</td></tr>
<tr class="separator:gacc4734579c84c1b33a9ba9433f2063e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9ad8d36c2a662f6f3ff420fb0f25826"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gad9ad8d36c2a662f6f3ff420fb0f25826">ffsll</a> (long long __val)</td></tr>
<tr class="separator:gad9ad8d36c2a662f6f3ff420fb0f25826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f2913a691990ae107e9687b8949b553"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga8f2913a691990ae107e9687b8949b553">memccpy</a> (void *, const void *, int, size_t)</td></tr>
<tr class="separator:ga8f2913a691990ae107e9687b8949b553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03899ab0dbc0ffda05c93934929e5ea1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga03899ab0dbc0ffda05c93934929e5ea1">memchr</a> (const void *, int, size_t)</td></tr>
<tr class="separator:ga03899ab0dbc0ffda05c93934929e5ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0849c52baadd8269575bc57e2273d862"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga0849c52baadd8269575bc57e2273d862">memcmp</a> (const void *, const void *, size_t)</td></tr>
<tr class="separator:ga0849c52baadd8269575bc57e2273d862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f60008005ea7557430149926cf583d7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga5f60008005ea7557430149926cf583d7">memcpy</a> (void *, const void *, size_t)</td></tr>
<tr class="separator:ga5f60008005ea7557430149926cf583d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac178bf2dc3d9273f5c54719e04130c2b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gac178bf2dc3d9273f5c54719e04130c2b">memmem</a> (const void *, size_t, const void *, size_t)</td></tr>
<tr class="separator:gac178bf2dc3d9273f5c54719e04130c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8efa99bafd35937d045832774bf57486"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga8efa99bafd35937d045832774bf57486">memmove</a> (void *, const void *, size_t)</td></tr>
<tr class="separator:ga8efa99bafd35937d045832774bf57486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0e052578dccb34646360cada11e73a5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gac0e052578dccb34646360cada11e73a5">memrchr</a> (const void *, int, size_t)</td></tr>
<tr class="separator:gac0e052578dccb34646360cada11e73a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f49550cc1e16fff2d707f91667eb80c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga8f49550cc1e16fff2d707f91667eb80c">memset</a> (void *, int, size_t)</td></tr>
<tr class="separator:ga8f49550cc1e16fff2d707f91667eb80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fd2a6e188f02599e5eeb17519f67f3e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga1fd2a6e188f02599e5eeb17519f67f3e">strcat</a> (char *, const char *)</td></tr>
<tr class="separator:ga1fd2a6e188f02599e5eeb17519f67f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa437df98a6fbb78201ed32fd82cbac70"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gaa437df98a6fbb78201ed32fd82cbac70">strchr</a> (const char *, int)</td></tr>
<tr class="separator:gaa437df98a6fbb78201ed32fd82cbac70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c6749c32d75e0dcb7c03a2216857b83"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga3c6749c32d75e0dcb7c03a2216857b83">strchrnul</a> (const char *, int)</td></tr>
<tr class="separator:ga3c6749c32d75e0dcb7c03a2216857b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21e4788b4a0ae39b11aa32e9a1079f98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga21e4788b4a0ae39b11aa32e9a1079f98">strcmp</a> (const char *, const char *)</td></tr>
<tr class="separator:ga21e4788b4a0ae39b11aa32e9a1079f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e4f23104fa6f722f9459d2673a1eba"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga54e4f23104fa6f722f9459d2673a1eba">strcpy</a> (char *, const char *)</td></tr>
<tr class="separator:ga54e4f23104fa6f722f9459d2673a1eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ca23db677fbf51663c03060776457d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga91ca23db677fbf51663c03060776457d">strcasecmp</a> (const char *, const char *)</td></tr>
<tr class="separator:ga91ca23db677fbf51663c03060776457d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac75c55f679ed9d632442e90b44336fa4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gac75c55f679ed9d632442e90b44336fa4">strcasestr</a> (const char *, const char *)</td></tr>
<tr class="separator:gac75c55f679ed9d632442e90b44336fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7ce08c05c71c0248169fb99e5b62b55"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gad7ce08c05c71c0248169fb99e5b62b55">strcspn</a> (const char *__s, const char *__reject)</td></tr>
<tr class="separator:gad7ce08c05c71c0248169fb99e5b62b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8569f20e38a030b5a28fd951abec2c9b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga8569f20e38a030b5a28fd951abec2c9b">strdup</a> (const char *s1)</td></tr>
<tr class="separator:ga8569f20e38a030b5a28fd951abec2c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1dd96623292aa543d16c28d1b6ce211"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gae1dd96623292aa543d16c28d1b6ce211">strndup</a> (const char *s, size_t n)</td></tr>
<tr class="separator:gae1dd96623292aa543d16c28d1b6ce211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e609bfa0d354dcd7e35b297c2e6fdd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga63e609bfa0d354dcd7e35b297c2e6fdd">strlcat</a> (char *, const char *, size_t)</td></tr>
<tr class="separator:ga63e609bfa0d354dcd7e35b297c2e6fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64bc119cf084d1ecfd95098994597f12"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga64bc119cf084d1ecfd95098994597f12">strlcpy</a> (char *, const char *, size_t)</td></tr>
<tr class="separator:ga64bc119cf084d1ecfd95098994597f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219836f542ce53545052bed5353820ca"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga219836f542ce53545052bed5353820ca">strlen</a> (const char *)</td></tr>
<tr class="separator:ga219836f542ce53545052bed5353820ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga119342b34031ba4ee28f4e38a22c5f0d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga119342b34031ba4ee28f4e38a22c5f0d">strlwr</a> (char *)</td></tr>
<tr class="separator:ga119342b34031ba4ee28f4e38a22c5f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa4a8701698b766f40180c735726cfe7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gafa4a8701698b766f40180c735726cfe7">strncat</a> (char *, const char *, size_t)</td></tr>
<tr class="separator:gafa4a8701698b766f40180c735726cfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7329b6bdb6e5510268fec1d24657574e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga7329b6bdb6e5510268fec1d24657574e">strncmp</a> (const char *, const char *, size_t)</td></tr>
<tr class="separator:ga7329b6bdb6e5510268fec1d24657574e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81577c743915e4fb8759ef9081f10838"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga81577c743915e4fb8759ef9081f10838">strncpy</a> (char *, const char *, size_t)</td></tr>
<tr class="separator:ga81577c743915e4fb8759ef9081f10838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03072fec48339478ee6ceeda36d977a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga03072fec48339478ee6ceeda36d977a4">strncasecmp</a> (const char *, const char *, size_t)</td></tr>
<tr class="separator:ga03072fec48339478ee6ceeda36d977a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddfb5fb346ea0c5aac48c4f9dde6525b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gaddfb5fb346ea0c5aac48c4f9dde6525b">strnlen</a> (const char *, size_t)</td></tr>
<tr class="separator:gaddfb5fb346ea0c5aac48c4f9dde6525b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f04d57afe38e7d3b6a87411a7847d62"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga4f04d57afe38e7d3b6a87411a7847d62">strpbrk</a> (const char *__s, const char *__accept)</td></tr>
<tr class="separator:ga4f04d57afe38e7d3b6a87411a7847d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2e9dea8db309f9c1fd453ff2b35ec0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga4f2e9dea8db309f9c1fd453ff2b35ec0">strrchr</a> (const char *, int)</td></tr>
<tr class="separator:ga4f2e9dea8db309f9c1fd453ff2b35ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfdb3ab0c1f988f86d04d706d8e0ce3f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gacfdb3ab0c1f988f86d04d706d8e0ce3f">strrev</a> (char *)</td></tr>
<tr class="separator:gacfdb3ab0c1f988f86d04d706d8e0ce3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff88adec2ad0446259766197ec3863de"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gaff88adec2ad0446259766197ec3863de">strsep</a> (char **, const char *)</td></tr>
<tr class="separator:gaff88adec2ad0446259766197ec3863de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1aaee71cf6ce8eb7ce0a17788df791e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gae1aaee71cf6ce8eb7ce0a17788df791e">strspn</a> (const char *__s, const char *__accept)</td></tr>
<tr class="separator:gae1aaee71cf6ce8eb7ce0a17788df791e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c61c16078e8815acaa3a304e1a42fa6"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga1c61c16078e8815acaa3a304e1a42fa6">strstr</a> (const char *, const char *)</td></tr>
<tr class="separator:ga1c61c16078e8815acaa3a304e1a42fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ace85338eafe22a0ff52c00eb9779b8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#ga6ace85338eafe22a0ff52c00eb9779b8">strtok</a> (char *, const char *)</td></tr>
<tr class="separator:ga6ace85338eafe22a0ff52c00eb9779b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0dbc25e8b202114031a4aa2a7c5177b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gac0dbc25e8b202114031a4aa2a7c5177b">strtok_r</a> (char *, const char *, char **)</td></tr>
<tr class="separator:gac0dbc25e8b202114031a4aa2a7c5177b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa50fa5cd42285f7c3980a3b0eafe77b5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__string.html#gaa50fa5cd42285f7c3980a3b0eafe77b5">strupr</a> (char *)</td></tr>
<tr class="separator:gaa50fa5cd42285f7c3980a3b0eafe77b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span> </div>
<div class="ttc" id="astring_8h_html"><div class="ttname"><a href="string_8h.html">string.h</a></div></div>
</div><!-- fragment --><p>The string functions perform string operations on <code>NULL</code> terminated strings.</p>
<dl class="section note"><dt>Note</dt><dd>If the strings you are working on resident in program space (flash), you will need to use the string functions described in <a class="el" href="group__avr__pgmspace.html">&lt;avr/pgmspace.h&gt;: Program Space Utilities</a>. </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaedb0e7bb7333d6122472acddb5df20ac" name="gaedb0e7bb7333d6122472acddb5df20ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedb0e7bb7333d6122472acddb5df20ac">&#9670;&#160;</a></span>_FFS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _FFS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro finds the first (least significant) bit set in the input value.</p>
<p>This macro is very similar to the function <a class="el" href="group__avr__string.html#gab978764fd2814cd14f9f1a3620aa4ca2" title="This function finds the first (least significant) bit set in the input value.">ffs()</a> except that it evaluates its argument at compile-time, so it should only be applied to compile-time constant expressions where it will reduce to a constant itself. Application of this macro to expressions that are not constant at compile-time is not recommended, and might result in a huge amount of code generated.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#gaedb0e7bb7333d6122472acddb5df20ac">_FFS()</a> macro returns the position of the first (least significant) bit set in the word val, or 0 if no bits are set. The least significant bit is position 1. Only 16 bits of argument are evaluted. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab978764fd2814cd14f9f1a3620aa4ca2" name="gab978764fd2814cd14f9f1a3620aa4ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab978764fd2814cd14f9f1a3620aa4ca2">&#9670;&#160;</a></span>ffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ffs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds the first (least significant) bit set in the input value. </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#gab978764fd2814cd14f9f1a3620aa4ca2" title="This function finds the first (least significant) bit set in the input value.">ffs()</a> function returns the position of the first (least significant) bit set in the word <code>val</code>, or 0 if no bits are set. The least significant bit is position 1.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For expressions that are constant at compile time, consider using the <a class="el" href="group__avr__string.html#gaedb0e7bb7333d6122472acddb5df20ac">_FFS</a> macro instead. </dd></dl>

</div>
</div>
<a id="gacc4734579c84c1b33a9ba9433f2063e4" name="gacc4734579c84c1b33a9ba9433f2063e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc4734579c84c1b33a9ba9433f2063e4">&#9670;&#160;</a></span>ffsl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ffsl </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>__val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__avr__string.html#gab978764fd2814cd14f9f1a3620aa4ca2" title="This function finds the first (least significant) bit set in the input value.">ffs()</a>, for an argument of type long. </p>

</div>
</div>
<a id="gad9ad8d36c2a662f6f3ff420fb0f25826" name="gad9ad8d36c2a662f6f3ff420fb0f25826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9ad8d36c2a662f6f3ff420fb0f25826">&#9670;&#160;</a></span>ffsll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ffsll </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>__val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group__avr__string.html#gab978764fd2814cd14f9f1a3620aa4ca2" title="This function finds the first (least significant) bit set in the input value.">ffs()</a>, for an argument of type <code>long long</code>. </p>

</div>
</div>
<a id="ga8f2913a691990ae107e9687b8949b553" name="ga8f2913a691990ae107e9687b8949b553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f2913a691990ae107e9687b8949b553">&#9670;&#160;</a></span>memccpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memccpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy memory area. </p>
<p>The <a class="el" href="group__avr__string.html#ga8f2913a691990ae107e9687b8949b553" title="Copy memory area.">memccpy()</a> function copies no more than <code>len</code> bytes from memory area <code>src</code> to memory area <code>dest</code>, stopping when the character <code>val</code> is found.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga8f2913a691990ae107e9687b8949b553" title="Copy memory area.">memccpy()</a> function returns a pointer to the next character in <code>dest</code> after <code>val</code>, or <code>NULL</code> if <code>val</code> was not found in the first <code>len</code> characters of <code>src</code>. </dd></dl>

</div>
</div>
<a id="ga03899ab0dbc0ffda05c93934929e5ea1" name="ga03899ab0dbc0ffda05c93934929e5ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03899ab0dbc0ffda05c93934929e5ea1">&#9670;&#160;</a></span>memchr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memchr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan memory for a character. </p>
<p>The <a class="el" href="group__avr__string.html#ga03899ab0dbc0ffda05c93934929e5ea1" title="Scan memory for a character.">memchr()</a> function scans the first len bytes of the memory area pointed to by src for the character val. The first byte to match val (interpreted as an unsigned character) stops the operation.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga03899ab0dbc0ffda05c93934929e5ea1" title="Scan memory for a character.">memchr()</a> function returns a pointer to the matching byte or NULL if the character does not occur in the given memory area. </dd></dl>

</div>
</div>
<a id="ga0849c52baadd8269575bc57e2273d862" name="ga0849c52baadd8269575bc57e2273d862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0849c52baadd8269575bc57e2273d862">&#9670;&#160;</a></span>memcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int memcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare memory areas. </p>
<p>The <a class="el" href="group__avr__string.html#ga0849c52baadd8269575bc57e2273d862" title="Compare memory areas.">memcmp()</a> function compares the first len bytes of the memory areas s1 and s2. The comparision is performed using unsigned char operations.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga0849c52baadd8269575bc57e2273d862" title="Compare memory areas.">memcmp()</a> function returns an integer less than, equal to, or greater than zero if the first len bytes of s1 is found, respectively, to be less than, to match, or be greater than the first len bytes of s2.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Be sure to store the result in a 16 bit variable since you may get incorrect results if you use an unsigned char or char due to truncation.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not -mint8 compatible, although if you only care about testing for equality, this function should be safe to use. </dd></dl>

</div>
</div>
<a id="ga5f60008005ea7557430149926cf583d7" name="ga5f60008005ea7557430149926cf583d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f60008005ea7557430149926cf583d7">&#9670;&#160;</a></span>memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a memory area. </p>
<p>The <a class="el" href="group__avr__string.html#ga5f60008005ea7557430149926cf583d7" title="Copy a memory area.">memcpy()</a> function copies len bytes from memory area src to memory area dest. The memory areas may not overlap. Use <a class="el" href="group__avr__string.html#ga8efa99bafd35937d045832774bf57486" title="Copy memory area.">memmove()</a> if the memory areas do overlap.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga5f60008005ea7557430149926cf583d7" title="Copy a memory area.">memcpy()</a> function returns a pointer to dest. </dd></dl>

</div>
</div>
<a id="gac178bf2dc3d9273f5c54719e04130c2b" name="gac178bf2dc3d9273f5c54719e04130c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac178bf2dc3d9273f5c54719e04130c2b">&#9670;&#160;</a></span>memmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memmem </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__string.html#gac178bf2dc3d9273f5c54719e04130c2b">memmem()</a> function finds the start of the first occurrence of the substring <code>s2</code> of length <code>len2</code> in the memory area <code>s1</code> of length <code>len1</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#gac178bf2dc3d9273f5c54719e04130c2b">memmem()</a> function returns a pointer to the beginning of the substring, or <code>NULL</code> if the substring is not found. If <code>len2</code> is zero, the function returns <code>s1</code>. </dd></dl>

</div>
</div>
<a id="ga8efa99bafd35937d045832774bf57486" name="ga8efa99bafd35937d045832774bf57486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8efa99bafd35937d045832774bf57486">&#9670;&#160;</a></span>memmove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memmove </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy memory area. </p>
<p>The <a class="el" href="group__avr__string.html#ga8efa99bafd35937d045832774bf57486" title="Copy memory area.">memmove()</a> function copies len bytes from memory area src to memory area dest. The memory areas may overlap.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga8efa99bafd35937d045832774bf57486" title="Copy memory area.">memmove()</a> function returns a pointer to dest. </dd></dl>

</div>
</div>
<a id="gac0e052578dccb34646360cada11e73a5" name="gac0e052578dccb34646360cada11e73a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0e052578dccb34646360cada11e73a5">&#9670;&#160;</a></span>memrchr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memrchr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__string.html#gac0e052578dccb34646360cada11e73a5">memrchr()</a> function is like the <a class="el" href="group__avr__string.html#ga03899ab0dbc0ffda05c93934929e5ea1" title="Scan memory for a character.">memchr()</a> function, except that it searches backwards from the end of the <code>len</code> bytes pointed to by <code>src</code> instead of forwards from the front. (Glibc, GNU extension.)</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#gac0e052578dccb34646360cada11e73a5">memrchr()</a> function returns a pointer to the matching byte or <code>NULL</code> if the character does not occur in the given memory area. </dd></dl>

</div>
</div>
<a id="ga8f49550cc1e16fff2d707f91667eb80c" name="ga8f49550cc1e16fff2d707f91667eb80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f49550cc1e16fff2d707f91667eb80c">&#9670;&#160;</a></span>memset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill memory with a constant byte. </p>
<p>The <a class="el" href="group__avr__string.html#ga8f49550cc1e16fff2d707f91667eb80c" title="Fill memory with a constant byte.">memset()</a> function fills the first len bytes of the memory area pointed to by dest with the constant byte val.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga8f49550cc1e16fff2d707f91667eb80c" title="Fill memory with a constant byte.">memset()</a> function returns a pointer to the memory area dest. </dd></dl>

</div>
</div>
<a id="ga91ca23db677fbf51663c03060776457d" name="ga91ca23db677fbf51663c03060776457d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91ca23db677fbf51663c03060776457d">&#9670;&#160;</a></span>strcasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strcasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings ignoring case. </p>
<p>The <a class="el" href="group__avr__string.html#ga91ca23db677fbf51663c03060776457d" title="Compare two strings ignoring case.">strcasecmp()</a> function compares the two strings <code>s1</code> and <code>s2</code>, ignoring the case of the characters.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga91ca23db677fbf51663c03060776457d" title="Compare two strings ignoring case.">strcasecmp()</a> function returns an integer less than, equal to, or greater than zero if <code>s1</code> is found, respectively, to be less than, to match, or be greater than <code>s2</code>. A consequence of the ordering used by <a class="el" href="group__avr__string.html#ga91ca23db677fbf51663c03060776457d" title="Compare two strings ignoring case.">strcasecmp()</a> is that if <code>s1</code> is an initial substring of <code>s2</code>, then <code>s1</code> is considered to be "less than" <code>s2</code>. </dd></dl>

</div>
</div>
<a id="gac75c55f679ed9d632442e90b44336fa4" name="gac75c55f679ed9d632442e90b44336fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac75c55f679ed9d632442e90b44336fa4">&#9670;&#160;</a></span>strcasestr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcasestr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__string.html#gac75c55f679ed9d632442e90b44336fa4">strcasestr()</a> function finds the first occurrence of the substring <code>s2</code> in the string <code>s1</code>. This is like <a class="el" href="group__avr__string.html#ga1c61c16078e8815acaa3a304e1a42fa6" title="Locate a substring.">strstr()</a>, except that it ignores case of alphabetic symbols in searching for the substring. (Glibc, GNU extension.)</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#gac75c55f679ed9d632442e90b44336fa4">strcasestr()</a> function returns a pointer to the beginning of the substring, or <code>NULL</code> if the substring is not found. If <code>s2</code> points to a string of zero length, the function returns <code>s1</code>. </dd></dl>

</div>
</div>
<a id="ga1fd2a6e188f02599e5eeb17519f67f3e" name="ga1fd2a6e188f02599e5eeb17519f67f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fd2a6e188f02599e5eeb17519f67f3e">&#9670;&#160;</a></span>strcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two strings. </p>
<p>The <a class="el" href="group__avr__string.html#ga1fd2a6e188f02599e5eeb17519f67f3e" title="Concatenate two strings.">strcat()</a> function appends the src string to the dest string overwriting the '\0' character at the end of dest, and then adds a terminating '\0' character. The strings may not overlap, and the dest string must have enough space for the result.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga1fd2a6e188f02599e5eeb17519f67f3e" title="Concatenate two strings.">strcat()</a> function returns a pointer to the resulting string dest. </dd></dl>

</div>
</div>
<a id="gaa437df98a6fbb78201ed32fd82cbac70" name="gaa437df98a6fbb78201ed32fd82cbac70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa437df98a6fbb78201ed32fd82cbac70">&#9670;&#160;</a></span>strchr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strchr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate character in string. </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#gaa437df98a6fbb78201ed32fd82cbac70" title="Locate character in string.">strchr()</a> function returns a pointer to the first occurrence of the character <code>val</code> in the string <code>src</code>, or <code>NULL</code> if the character is not found. <br  />
<br  />
 Here "character" means "byte" &ndash; these functions do not work with wide or multi-byte characters. </dd></dl>

</div>
</div>
<a id="ga3c6749c32d75e0dcb7c03a2216857b83" name="ga3c6749c32d75e0dcb7c03a2216857b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c6749c32d75e0dcb7c03a2216857b83">&#9670;&#160;</a></span>strchrnul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strchrnul </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__string.html#ga3c6749c32d75e0dcb7c03a2216857b83">strchrnul()</a> function is like <a class="el" href="group__avr__string.html#gaa437df98a6fbb78201ed32fd82cbac70" title="Locate character in string.">strchr()</a> except that if <code>c</code> is not found in <code>s</code>, then it returns a pointer to the null byte at the end of <code>s</code>, rather than <code>NULL</code>. (Glibc, GNU extension.)</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga3c6749c32d75e0dcb7c03a2216857b83">strchrnul()</a> function returns a pointer to the matched character, or a pointer to the null byte at the end of <code>s</code> (i.e., <code>s+strlen</code>(s)) if the character is not found. </dd></dl>

</div>
</div>
<a id="ga21e4788b4a0ae39b11aa32e9a1079f98" name="ga21e4788b4a0ae39b11aa32e9a1079f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21e4788b4a0ae39b11aa32e9a1079f98">&#9670;&#160;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strcmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings. </p>
<p>The <a class="el" href="group__avr__string.html#ga21e4788b4a0ae39b11aa32e9a1079f98" title="Compare two strings.">strcmp()</a> function compares the two strings <code>s1</code> and <code>s2</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga21e4788b4a0ae39b11aa32e9a1079f98" title="Compare two strings.">strcmp()</a> function returns an integer less than, equal to, or greater than zero if <code>s1</code> is found, respectively, to be less than, to match, or be greater than <code>s2</code>. A consequence of the ordering used by <a class="el" href="group__avr__string.html#ga21e4788b4a0ae39b11aa32e9a1079f98" title="Compare two strings.">strcmp()</a> is that if <code>s1</code> is an initial substring of <code>s2</code>, then <code>s1</code> is considered to be "less than" <code>s2</code>. </dd></dl>

</div>
</div>
<a id="ga54e4f23104fa6f722f9459d2673a1eba" name="ga54e4f23104fa6f722f9459d2673a1eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54e4f23104fa6f722f9459d2673a1eba">&#9670;&#160;</a></span>strcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string. </p>
<p>The <a class="el" href="group__avr__string.html#ga54e4f23104fa6f722f9459d2673a1eba" title="Copy a string.">strcpy()</a> function copies the string pointed to by src (including the terminating '\0' character) to the array pointed to by dest. The strings may not overlap, and the destination string dest must be large enough to receive the copy.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga54e4f23104fa6f722f9459d2673a1eba" title="Copy a string.">strcpy()</a> function returns a pointer to the destination string dest.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the destination string of a <a class="el" href="group__avr__string.html#ga54e4f23104fa6f722f9459d2673a1eba" title="Copy a string.">strcpy()</a> is not large enough (that is, if the programmer was stupid/lazy, and failed to check the size before copying) then anything might happen. Overflowing fixed length strings is a favourite cracker technique. </dd></dl>

</div>
</div>
<a id="gad7ce08c05c71c0248169fb99e5b62b55" name="gad7ce08c05c71c0248169fb99e5b62b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7ce08c05c71c0248169fb99e5b62b55">&#9670;&#160;</a></span>strcspn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strcspn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>reject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__string.html#gad7ce08c05c71c0248169fb99e5b62b55">strcspn()</a> function calculates the length of the initial segment of <code>s</code> which consists entirely of characters not in <code>reject</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#gad7ce08c05c71c0248169fb99e5b62b55">strcspn()</a> function returns the number of characters in the initial segment of <code>s</code> which are not in the string <code>reject</code>. The terminating zero is not considered as a part of string. </dd></dl>

</div>
</div>
<a id="ga8569f20e38a030b5a28fd951abec2c9b" name="ga8569f20e38a030b5a28fd951abec2c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8569f20e38a030b5a28fd951abec2c9b">&#9670;&#160;</a></span>strdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strdup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a string. </p>
<p>The <a class="el" href="group__avr__string.html#ga8569f20e38a030b5a28fd951abec2c9b" title="Duplicate a string.">strdup()</a> function allocates memory and copies into it the string addressed by <code>s1</code>, including the terminating null character.</p>
<dl class="section warning"><dt>Warning</dt><dd>The <a class="el" href="group__avr__string.html#ga8569f20e38a030b5a28fd951abec2c9b" title="Duplicate a string.">strdup()</a> function calls malloc() to allocate the memory for the duplicated string! The user is responsible for freeing the memory by calling free().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga8569f20e38a030b5a28fd951abec2c9b" title="Duplicate a string.">strdup()</a> function returns a pointer to the resulting string dest. If malloc() cannot allocate enough storage for the string, <a class="el" href="group__avr__string.html#ga8569f20e38a030b5a28fd951abec2c9b" title="Duplicate a string.">strdup()</a> will return <code>NULL</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Be sure to check the return value of the <a class="el" href="group__avr__string.html#ga8569f20e38a030b5a28fd951abec2c9b" title="Duplicate a string.">strdup()</a> function to make sure that the function has succeeded in allocating the memory! </dd></dl>

</div>
</div>
<a id="ga63e609bfa0d354dcd7e35b297c2e6fdd" name="ga63e609bfa0d354dcd7e35b297c2e6fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63e609bfa0d354dcd7e35b297c2e6fdd">&#9670;&#160;</a></span>strlcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two strings. </p>
<p>Appends <code>src</code> to string <code>dst</code> of size <code>siz</code> (unlike <a class="el" href="group__avr__string.html#gafa4a8701698b766f40180c735726cfe7" title="Concatenate two strings.">strncat()</a>, <code>siz</code> is the full size of <code>dst</code>, not space left). At most <code>siz-1</code> characters will be copied. Always <code>'\0'</code> terminated (unless <code>siz</code> &lt;= <code>strlen(dst)</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga63e609bfa0d354dcd7e35b297c2e6fdd" title="Concatenate two strings.">strlcat()</a> function returns strlen(src) + MIN(siz,
strlen(initial dst)). If retval &gt;= siz, truncation occurred.</dd></dl>
<p>Appends src to string dst of size siz (unlike <a class="el" href="group__avr__string.html#gafa4a8701698b766f40180c735726cfe7" title="Concatenate two strings.">strncat()</a>, siz is the full size of dst, not space left). At most siz-1 characters will be copied. Always NULL terminates (unless siz &lt;= strlen(dst)).</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga63e609bfa0d354dcd7e35b297c2e6fdd" title="Concatenate two strings.">strlcat()</a> function returns strlen(src) + MIN(siz,
strlen(initial dst)). If retval &gt;= siz, truncation occurred. </dd></dl>

</div>
</div>
<a id="ga64bc119cf084d1ecfd95098994597f12" name="ga64bc119cf084d1ecfd95098994597f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64bc119cf084d1ecfd95098994597f12">&#9670;&#160;</a></span>strlcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string. </p>
<p>Copy <code>src</code> to string <code>dst</code> of size <code>siz</code>. At most <code>siz-1</code> characters will be copied. Always '\0' terminated (unless <code>siz</code> == 0).</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga64bc119cf084d1ecfd95098994597f12" title="Copy a string.">strlcpy()</a> function returns strlen(src). If retval &gt;= siz, truncation occurred.</dd></dl>
<p>Copy src to string dst of size siz. At most siz-1 characters will be copied. Always NULL terminates (unless siz == 0).</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga64bc119cf084d1ecfd95098994597f12" title="Copy a string.">strlcpy()</a> function returns strlen(src). If retval &gt;= siz, truncation occurred. </dd></dl>

</div>
</div>
<a id="ga219836f542ce53545052bed5353820ca" name="ga219836f542ce53545052bed5353820ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga219836f542ce53545052bed5353820ca">&#9670;&#160;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the length of a string. </p>
<p>The <a class="el" href="group__avr__string.html#ga219836f542ce53545052bed5353820ca" title="Calculate the length of a string.">strlen()</a> function calculates the length of the string <code>src</code>, not including the terminating '\0' character.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga219836f542ce53545052bed5353820ca" title="Calculate the length of a string.">strlen()</a> function returns the number of characters in <code>src</code>. </dd></dl>

</div>
</div>
<a id="ga119342b34031ba4ee28f4e38a22c5f0d" name="ga119342b34031ba4ee28f4e38a22c5f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga119342b34031ba4ee28f4e38a22c5f0d">&#9670;&#160;</a></span>strlwr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strlwr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to lower case. </p>
<p>The <a class="el" href="group__avr__string.html#ga119342b34031ba4ee28f4e38a22c5f0d" title="Convert a string to lower case.">strlwr()</a> function will convert a string to lower case. Only the upper case alphabetic characters [A .. Z] are converted. Non-alphabetic characters will not be changed.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga119342b34031ba4ee28f4e38a22c5f0d" title="Convert a string to lower case.">strlwr()</a> function returns a pointer to the converted string. Conversion is perfomed in-place. </dd></dl>

</div>
</div>
<a id="ga03072fec48339478ee6ceeda36d977a4" name="ga03072fec48339478ee6ceeda36d977a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03072fec48339478ee6ceeda36d977a4">&#9670;&#160;</a></span>strncasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strncasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings ignoring case. </p>
<p>The <a class="el" href="group__avr__string.html#ga03072fec48339478ee6ceeda36d977a4" title="Compare two strings ignoring case.">strncasecmp()</a> function is similar to <a class="el" href="group__avr__string.html#ga91ca23db677fbf51663c03060776457d" title="Compare two strings ignoring case.">strcasecmp()</a>, except it only compares the first <code>len</code> characters of <code>s1</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga03072fec48339478ee6ceeda36d977a4" title="Compare two strings ignoring case.">strncasecmp()</a> function returns an integer less than, equal to, or greater than zero if <code>s1</code> (or the first <code>len</code> bytes thereof) is found, respectively, to be less than, to match, or be greater than <code>s2</code>. A consequence of the ordering used by <a class="el" href="group__avr__string.html#ga03072fec48339478ee6ceeda36d977a4" title="Compare two strings ignoring case.">strncasecmp()</a> is that if <code>s1</code> is an initial substring of <code>s2</code>, then <code>s1</code> is considered to be "less than" <code>s2</code>. </dd></dl>

</div>
</div>
<a id="gafa4a8701698b766f40180c735726cfe7" name="gafa4a8701698b766f40180c735726cfe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa4a8701698b766f40180c735726cfe7">&#9670;&#160;</a></span>strncat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strncat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two strings. </p>
<p>The <a class="el" href="group__avr__string.html#gafa4a8701698b766f40180c735726cfe7" title="Concatenate two strings.">strncat()</a> function is similar to <a class="el" href="group__avr__string.html#ga1fd2a6e188f02599e5eeb17519f67f3e" title="Concatenate two strings.">strcat()</a>, except that only the first <code>len</code> characters of <code>src</code> are appended to <code>dest</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#gafa4a8701698b766f40180c735726cfe7" title="Concatenate two strings.">strncat()</a> function returns a pointer to the resulting string <code>dest</code>. </dd></dl>

</div>
</div>
<a id="ga7329b6bdb6e5510268fec1d24657574e" name="ga7329b6bdb6e5510268fec1d24657574e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7329b6bdb6e5510268fec1d24657574e">&#9670;&#160;</a></span>strncmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strncmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings. </p>
<p>The <a class="el" href="group__avr__string.html#ga7329b6bdb6e5510268fec1d24657574e" title="Compare two strings.">strncmp()</a> function is similar to <a class="el" href="group__avr__string.html#ga21e4788b4a0ae39b11aa32e9a1079f98" title="Compare two strings.">strcmp()</a>, except it only compares the first (at most) <code>len</code> characters of <code>s1</code> and <code>s2</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga7329b6bdb6e5510268fec1d24657574e" title="Compare two strings.">strncmp()</a> function returns an integer less than, equal to, or greater than zero if <code>s1</code> (or the first <code>len</code> bytes thereof) is found, respectively, to be less than, to match, or be greater than <code>s2</code>. </dd></dl>

</div>
</div>
<a id="ga81577c743915e4fb8759ef9081f10838" name="ga81577c743915e4fb8759ef9081f10838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81577c743915e4fb8759ef9081f10838">&#9670;&#160;</a></span>strncpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strncpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string. </p>
<p>The <a class="el" href="group__avr__string.html#ga81577c743915e4fb8759ef9081f10838" title="Copy a string.">strncpy()</a> function is similar to <a class="el" href="group__avr__string.html#ga54e4f23104fa6f722f9459d2673a1eba" title="Copy a string.">strcpy()</a>, except that not more than <code>len</code> bytes of <code>src</code> are copied. Thus, if there is no null byte among the first <code>len</code> bytes of <code>src</code>, the result will not be null-terminated.</p>
<p>In the case where the length of <code>src</code> is less than that of <code>len</code>, the remainder of <code>dest</code> will be padded with nulls (<code>'\0'</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga81577c743915e4fb8759ef9081f10838" title="Copy a string.">strncpy()</a> function returns a pointer to the destination string <code>dest</code>. </dd></dl>

</div>
</div>
<a id="gae1dd96623292aa543d16c28d1b6ce211" name="gae1dd96623292aa543d16c28d1b6ce211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1dd96623292aa543d16c28d1b6ce211">&#9670;&#160;</a></span>strndup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strndup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a string. </p>
<p>The <a class="el" href="group__avr__string.html#gae1dd96623292aa543d16c28d1b6ce211" title="Duplicate a string.">strndup()</a> function is similar to <a class="el" href="group__avr__string.html#ga8569f20e38a030b5a28fd951abec2c9b" title="Duplicate a string.">strdup()</a>, but copies at most <code>len</code> bytes. If <code>s</code> is longer than <code>len</code>, only <code>len</code> bytes are copied, and a terminating null byte (<code>'\0'</code>) is added.</p>
<p>Memory for the new string is obtained with malloc(), and can be freed with free().</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#gae1dd96623292aa543d16c28d1b6ce211" title="Duplicate a string.">strndup()</a> function returns the location of the newly malloc'ed memory, or <code>NULL</code> if the allocation failed. </dd></dl>

</div>
</div>
<a id="gaddfb5fb346ea0c5aac48c4f9dde6525b" name="gaddfb5fb346ea0c5aac48c4f9dde6525b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddfb5fb346ea0c5aac48c4f9dde6525b">&#9670;&#160;</a></span>strnlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strnlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the length of a fixed-size string. </p>
<p>The <a class="el" href="group__avr__string.html#gaddfb5fb346ea0c5aac48c4f9dde6525b" title="Determine the length of a fixed-size string.">strnlen()</a> function returns the number of characters in the string pointed to by <code>src</code>, not including the terminating '\0' character, but at most <code>len</code>. In doing this, <a class="el" href="group__avr__string.html#gaddfb5fb346ea0c5aac48c4f9dde6525b" title="Determine the length of a fixed-size string.">strnlen()</a> looks only at the first <code>len</code> characters at <code>src</code> and never beyond <code>src</code> + <code>len</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The strnlen function returns strlen(src), if that is less than <code>len</code>, or <code>len</code> if there is no '\0' character among the first <code>len</code> characters pointed to by <code>src</code>. </dd></dl>

</div>
</div>
<a id="ga4f04d57afe38e7d3b6a87411a7847d62" name="ga4f04d57afe38e7d3b6a87411a7847d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f04d57afe38e7d3b6a87411a7847d62">&#9670;&#160;</a></span>strpbrk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strpbrk </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>accept</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__string.html#ga4f04d57afe38e7d3b6a87411a7847d62">strpbrk()</a> function locates the first occurrence in the string <code>s</code> of any of the characters in the string <code>accept</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga4f04d57afe38e7d3b6a87411a7847d62">strpbrk()</a> function returns a pointer to the character in <code>s</code> that matches one of the characters in <code>accept</code>, or <code>NULL</code> if no such character is found. The terminating zero is not considered as a part of string: if one or both args are empty, the result will be <code>NULL</code>. </dd></dl>

</div>
</div>
<a id="ga4f2e9dea8db309f9c1fd453ff2b35ec0" name="ga4f2e9dea8db309f9c1fd453ff2b35ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f2e9dea8db309f9c1fd453ff2b35ec0">&#9670;&#160;</a></span>strrchr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strrchr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate character in string. </p>
<p>The <a class="el" href="group__avr__string.html#ga4f2e9dea8db309f9c1fd453ff2b35ec0" title="Locate character in string.">strrchr()</a> function returns a pointer to the last occurrence of the character val in the string src.</p>
<p>Here "character" means "byte" &ndash; these functions do not work with wide or multi-byte characters.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga4f2e9dea8db309f9c1fd453ff2b35ec0" title="Locate character in string.">strrchr()</a> function returns a pointer to the matched character or <code>NULL</code> if the character is not found. </dd></dl>

</div>
</div>
<a id="gacfdb3ab0c1f988f86d04d706d8e0ce3f" name="gacfdb3ab0c1f988f86d04d706d8e0ce3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfdb3ab0c1f988f86d04d706d8e0ce3f">&#9670;&#160;</a></span>strrev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strrev </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse a string. </p>
<p>The <a class="el" href="group__avr__string.html#gacfdb3ab0c1f988f86d04d706d8e0ce3f" title="Reverse a string.">strrev()</a> function reverses the order of the string.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#gacfdb3ab0c1f988f86d04d706d8e0ce3f" title="Reverse a string.">strrev()</a> function returns a pointer to the beginning of the reversed string. </dd></dl>

</div>
</div>
<a id="gaff88adec2ad0446259766197ec3863de" name="gaff88adec2ad0446259766197ec3863de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff88adec2ad0446259766197ec3863de">&#9670;&#160;</a></span>strsep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strsep </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a string into tokens. </p>
<p>The <a class="el" href="group__avr__string.html#gaff88adec2ad0446259766197ec3863de" title="Parse a string into tokens.">strsep()</a> function locates, in the string referenced by <code>*sp</code>, the first occurrence of any character in the string <code>delim</code> (or the terminating '\0' character) and replaces it with a '\0'. The location of the next character after the delimiter character (or <code>NULL</code>, if the end of the string was reached) is stored in <code>*sp</code>. An ``empty'' field, i.e. one caused by two adjacent delimiter characters, can be detected by comparing the location referenced by the pointer returned in <code>*sp</code> to '\0'.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#gaff88adec2ad0446259766197ec3863de" title="Parse a string into tokens.">strsep()</a> function returns a pointer to the original value of <code>*sp</code>. If <code>*sp</code> is initially <code>NULL</code>, <a class="el" href="group__avr__string.html#gaff88adec2ad0446259766197ec3863de" title="Parse a string into tokens.">strsep()</a> returns <code>NULL</code>. </dd></dl>

</div>
</div>
<a id="gae1aaee71cf6ce8eb7ce0a17788df791e" name="gae1aaee71cf6ce8eb7ce0a17788df791e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1aaee71cf6ce8eb7ce0a17788df791e">&#9670;&#160;</a></span>strspn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strspn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>accept</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__string.html#gae1aaee71cf6ce8eb7ce0a17788df791e">strspn()</a> function calculates the length of the initial segment of <code>s</code> which consists entirely of characters in <code>accept</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#gae1aaee71cf6ce8eb7ce0a17788df791e">strspn()</a> function returns the number of characters in the initial segment of <code>s</code> which consist only of characters from <code>accept</code>. The terminating zero is not considered as a part of string. </dd></dl>

</div>
</div>
<a id="ga1c61c16078e8815acaa3a304e1a42fa6" name="ga1c61c16078e8815acaa3a304e1a42fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c61c16078e8815acaa3a304e1a42fa6">&#9670;&#160;</a></span>strstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strstr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate a substring. </p>
<p>The <a class="el" href="group__avr__string.html#ga1c61c16078e8815acaa3a304e1a42fa6" title="Locate a substring.">strstr()</a> function finds the first occurrence of the substring <code>s2</code> in the string <code>s1</code>. The terminating '\0' characters are not compared.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga1c61c16078e8815acaa3a304e1a42fa6" title="Locate a substring.">strstr()</a> function returns a pointer to the beginning of the substring, or <code>NULL</code> if the substring is not found. If <code>s2</code> points to a string of zero length, the function returns <code>s1</code>. </dd></dl>

</div>
</div>
<a id="ga6ace85338eafe22a0ff52c00eb9779b8" name="ga6ace85338eafe22a0ff52c00eb9779b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ace85338eafe22a0ff52c00eb9779b8">&#9670;&#160;</a></span>strtok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strtok </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the string s into tokens. </p>
<p>strtok parses the string s into tokens. The first call to strtok should have s as its first argument. Subsequent calls should have the first argument set to <code>NULL</code>. If a token ends with a delimiter, this delimiting character is overwritten with a '\0' and a pointer to the next character is saved for the next call to strtok. The delimiter string delim may be different for each call.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#ga6ace85338eafe22a0ff52c00eb9779b8" title="Parses the string s into tokens.">strtok()</a> function returns a pointer to the next token or <code>NULL</code> when no more tokens are found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__avr__string.html#ga6ace85338eafe22a0ff52c00eb9779b8" title="Parses the string s into tokens.">strtok()</a> is NOT reentrant. For a reentrant version of this function see <code><a class="el" href="group__avr__string.html#gac0dbc25e8b202114031a4aa2a7c5177b" title="Parses string into tokens.">strtok_r()</a></code>. </dd></dl>

</div>
</div>
<a id="gac0dbc25e8b202114031a4aa2a7c5177b" name="gac0dbc25e8b202114031a4aa2a7c5177b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0dbc25e8b202114031a4aa2a7c5177b">&#9670;&#160;</a></span>strtok_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strtok_r </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses string into tokens. </p>
<p>strtok_r parses string into tokens. The first call to strtok_r should have string as its first argument. Subsequent calls should have the first argument set to <code>NULL</code>. If a token ends with a delimiter, this delimiting character is overwritten with a '\0' and a pointer to the next character is saved for the next call to strtok_r. The delimiter string <code>delim</code> may be different for each call. <code>last</code> is a user allocated char* pointer. It must be the same while parsing the same string. strtok_r is a reentrant version of <a class="el" href="group__avr__string.html#ga6ace85338eafe22a0ff52c00eb9779b8" title="Parses the string s into tokens.">strtok()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#gac0dbc25e8b202114031a4aa2a7c5177b" title="Parses string into tokens.">strtok_r()</a> function returns a pointer to the next token or <code>NULL</code> when no more tokens are found. </dd></dl>

</div>
</div>
<a id="gaa50fa5cd42285f7c3980a3b0eafe77b5" name="gaa50fa5cd42285f7c3980a3b0eafe77b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa50fa5cd42285f7c3980a3b0eafe77b5">&#9670;&#160;</a></span>strupr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strupr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to upper case. </p>
<p>The <a class="el" href="group__avr__string.html#gaa50fa5cd42285f7c3980a3b0eafe77b5" title="Convert a string to upper case.">strupr()</a> function will convert a string to upper case. Only the lower case alphabetic characters [a .. z] are converted. Non-alphabetic characters will not be changed.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__string.html#gaa50fa5cd42285f7c3980a3b0eafe77b5" title="Convert a string to upper case.">strupr()</a> function returns a pointer to the converted string. The pointer is the same as that passed in since the operation is perform in place. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 9 2024 00:30:42 for AVR-LibC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.6
</small></address>
</body>
</html>
