<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<title>AVR-LibC: Frequently Asked Questions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AVR-LibC
   &#160;<span id="projectnumber">2.3.0</span>
   </div>
   <div id="projectbrief">Standard C library for AVR-GCC</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table>
  <tr>
    <td align="left"><a href="https://avrdudes.github.io/avr-libc/"><h2>AVR-LibC Manual</h2></a></td>
    <td align="center" colspan=4>
      <div class="logo"><img src="avr-libc-logo.png" alt="Logo" align="middle" border="0"></div>
      <div class="invlogo"><img src="avr-libc-logo-inverted.png" alt="Logo" align="middle" border="0"></div>
    </td>
    <td align="right"><a href="https://github.com/avrdudes/avr-libc/"><h2>AVR-LibC Sources</h2></a></td>
  </tr>
  <tr>
    <td align="center" width="14%"><a href="index.html"><h2>Main Page</h2></a></td>
    <td align="center" width="16%"><a href="pages.html"><h2>User Manual</h2></a></td>
    <td align="center" width="22%"><a href="modules.html"><h2>Lib&shy;rary Refe&shy;rence</h2></a></td>
    <td align="center" width="7%"><a href="FAQ.html"><h2>FAQ</h2></a></td>
    <td align="center" width="22%"><a href="group__demos.html"><h2>Exam&shy;ple Pro&shy;jects</h2></a></td>
    <td align="center" width="14%"><a href="Global_01Index.html"><h2>Index</h2></a></td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Frequently Asked Questions </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="faq_index"></a>
FAQ Index</h1>
<p><a id="a0_FAQ" name="a0_FAQ"></a></p>
<ul>
<li><b>Interrupts</b><ul>
<li><a class="el" href="FAQ.html#faq_volatile">Why doesn't my program recognize a variable updated in an interrupt routine?</a></li>
<li><a class="el" href="FAQ.html#faq_16bitio">Why do some 16-bit timer registers sometimes get trashed?</a></li>
<li><a class="el" href="FAQ.html#faq_isr_names">What ISR names are available for my device?</a></li>
<li><a class="el" href="FAQ.html#faq_reentrant">What pitfalls exist when writing reentrant code?</a></li>
<li><a class="el" href="FAQ.html#faq_spman">Why are interrupts re-enabled in the middle of writing the stack pointer?</a></li>
<li><a class="el" href="FAQ.html#faq_cvt">How to use a Compact Vector Table?</a></li>
<li><a class="el" href="FAQ.html#faq_local_isr">How to use a local (static, namespace) function as ISR?</a></li>
</ul>
</li>
<li><b>C/C++</b><ul>
<li><a class="el" href="FAQ.html#faq_cplusplus">Can I use C++ on the AVR?</a></li>
<li><a class="el" href="FAQ.html#faq_optflags">Which -O flag to use?</a></li>
<li><a class="el" href="FAQ.html#faq_varinit">Shouldn't I initialize all my variables?</a></li>
<li><a class="el" href="FAQ.html#faq_flashstrings">Why do all my string literals eat up the SRAM?</a></li>
<li><a class="el" href="FAQ.html#faq_rom_array">How do I put an array of strings completely in ROM?</a></li>
<li><a class="el" href="FAQ.html#faq_startup">How to modify MCUCR or WDTCR early?</a></li>
<li><a class="el" href="FAQ.html#faq_port_pass">How do I pass an IO port as a parameter to a function?</a></li>
<li><a class="el" href="FAQ.html#faq_call_asm_from_c">How to call an assembly function from C/C++?</a></li>
<li><a class="el" href="FAQ.html#faq_call_c_from_asm">How to call a C/C++ function from assembly?</a></li>
<li><a class="el" href="FAQ.html#faq_regbind">How to permanently bind a variable to a register?</a></li>
<li><a class="el" href="FAQ.html#faq_assign_chain">Why is assigning ports in a "chain" a bad idea?</a></li>
<li><a class="el" href="FAQ.html#faq_use_bv">What is all this _BV() stuff about?</a></li>
<li><a class="el" href="FAQ.html#faq_tinyavr_c">Is it really impossible to program the ATtinyXX in C?</a></li>
<li><a class="el" href="FAQ.html#faq_AVRrc">What features are (not) supported on AVRrc Reduced Core devices?</a></li>
</ul>
</li>
<li><b>(Inline) Assembly</b><ul>
<li><a class="el" href="FAQ.html#faq_asmconst">How do I use a #define'd constant in an asm statement?</a></li>
<li><a class="el" href="FAQ.html#faq_asmops">Which AVR-specific assembler operators are available?</a></li>
<li><a class="el" href="FAQ.html#faq_call_asm_from_c">How to call an assembly function from C/C++?</a></li>
<li><a class="el" href="FAQ.html#faq_call_c_from_asm">How to call a C/C++ function from assembly?</a></li>
<li><a class="el" href="FAQ.html#faq_nonabi">How can I use a function that doesn't comply to the ABI?</a></li>
</ul>
</li>
<li><b>Binary Interface</b><ul>
<li><a class="el" href="FAQ.html#faq_reg_usage">What registers are used by the compiler?</a></li>
<li><a class="el" href="FAQ.html#faq_funcptr_gt128kib">On a device with more than 128 KiB of flash, how to make function pointers work?</a></li>
<li><a class="el" href="FAQ.html#faq_eind">How is the EIND special function register handled?</a></li>
<li><a class="el" href="FAQ.html#faq_rampx">How are the RAMPX, RAMPY, RAMPZ and RAMPD registers handled?</a></li>
</ul>
</li>
<li><b>Linking and Binaries</b><ul>
<li><a class="el" href="FAQ.html#faq_reloc_code">How do I relocate code to a fixed address?</a></li>
<li><a class="el" href="FAQ.html#faq_binarydata">How to add a raw binary image to linker output?</a><ul>
<li><a class="el" href="FAQ.html#faq_binarydata_embed">Using #embed</a></li>
<li><a class="el" href="FAQ.html#faq_binarydata_incbin">Using .incbin</a></li>
<li><a class="el" href="FAQ.html#faq_binarydata_objcopy">Using objcopy</a></li>
</ul>
</li>
<li><a class="el" href="FAQ.html#faq_linkerscripts">Why are there five different linker scripts?</a></li>
</ul>
</li>
<li><b>Static Analysis</b><ul>
<li><a class="el" href="FAQ.html#faq_headers">Which header files are included in my program?</a></li>
<li><a class="el" href="FAQ.html#faq_macros">Which macros are defined in my program? Where are they defined, and to what value?</a></li>
<li><a class="el" href="FAQ.html#faq_ramoverlap">How to detect RAM memory and variable overlap problems?</a></li>
</ul>
</li>
<li><b>Debugging</b><ul>
<li><a class="el" href="FAQ.html#faq_gdboptimize">Why does the PC randomly jump around when single-stepping through my program in avr-gdb?</a></li>
<li><a class="el" href="FAQ.html#faq_asmstabs">How do I trace an assembler file in avr-gdb?</a></li>
</ul>
</li>
<li><b>Hardware</b><ul>
<li><a class="el" href="FAQ.html#faq_softreset">How do I perform a software reset of the AVR?</a></li>
<li><a class="el" href="FAQ.html#faq_eeprom_corruption">Why are some addresses of the EEPROM corrupted (usually address zero)?</a></li>
<li><a class="el" href="FAQ.html#faq_fuses">My UART is generating nonsense! My ATmega128 keeps crashing! Port F is completely broken!</a></li>
<li><a class="el" href="FAQ.html#faq_intbits">Why are (many) interrupt flags cleared by writing a logical 1?</a></li>
<li><a class="el" href="FAQ.html#faq_fuselow">Why have "programmed" fuses the bit value 0?</a></li>
<li><a class="el" href="FAQ.html#faq_ext_ram">How to use external RAM?</a></li>
</ul>
</li>
<li><b>Toolchain</b><ul>
<li><a class="el" href="FAQ.html#faq_toolchain_version">What are the versions of the tools in my toolchain?</a></li>
<li><a class="el" href="FAQ.html#faq_toolchain_sources">Where can I find the source code of the tools?</a></li>
<li><a class="el" href="FAQ.html#faq_toolchain_bugs">Where can I report a problem?</a></li>
</ul>
</li>
<li><b>Other</b><ul>
<li><a class="el" href="FAQ.html#faq_wrong_baud_rate">Why is my baud rate wrong?</a></li>
<li><a class="el" href="FAQ.html#faq_clockskew">What is this "clock skew detected" message?</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="faq_volatile"></a>
Why doesn't my program recognize a variable updated in an interrupt routine?</h1>
<p>When using the optimizer, in a loop like the following one:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> flag; <span class="comment">// volatile is missing</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__avr__interrupts.html#gad28590624d422cdf30d626e0a506255f">ISR</a>(SOME_vect)</div>
<div class="line">{</div>
<div class="line">  flag = 1;</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (flag == 0)</div>
<div class="line">    {</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="ttc" id="agroup__avr__interrupts_html_gad28590624d422cdf30d626e0a506255f"><div class="ttname"><a href="group__avr__interrupts.html#gad28590624d422cdf30d626e0a506255f">ISR</a></div><div class="ttdeci">#define ISR(vector, attributes)</div><div class="ttdef"><b>Definition:</b> interrupt.h:118</div></div>
<div class="ttc" id="agroup__avr__stdint_html_gaba7bc1797add20fe3efdf37ced1182c5"><div class="ttname"><a href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a></div><div class="ttdeci">unsigned char uint8_t</div><div class="ttdef"><b>Definition:</b> stdint.h:88</div></div>
</div><!-- fragment --><p>the compiler will typically access <code>flag</code> only once, and optimize further accesses completely away, since its code path analysis shows that nothing inside the loop could change the value of <code>flag</code> anyway. To tell the compiler that this variable could be changed outside the scope of its code path analysis (e. g. from within an interrupt routine), the variable needs to be qualified as volatile:</p>
<div class="fragment"><div class="line"><span class="keyword">volatile</span> <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> flag;</div>
</div><!-- fragment --><p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_regbind"></a>
How to permanently bind a variable to a register?</h1>
<p>This can be done with</p>
<div class="fragment"><div class="line"><span class="keyword">register</span> <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> counter __asm(<span class="stringliteral">&quot;r3&quot;</span>);</div>
</div><!-- fragment --><p>Typically, it should be safe to use r2 through r7 that way.</p>
<p>Registers r8 through r25 can be used for argument passing by the compiler in case many or long arguments are being passed to callees. If this is not the case throughout the entire application, these registers could be used for register variables as well.</p>
<dl class="section warning"><dt>Warning</dt><dd>Extreme care should be taken that the entire application is compiled with a consistent set of register-allocated variables including possibly used library functions. This can be achieved by compiling each module with <code>-ffixed-r3</code> or <code>-ffixed-3</code>. Notice that when you are using library functions from libgcc (the avr-gcc runtime library) or AVR-LibC, then these libraries were generated <em>without</em> the requirement to avoid specific registers. Hence when you are using libraries from the distribution, you must make sure that none of the reserved registers is used in the generated binary.</dd>
<dd>
Also notice that global register variables can't be volatile, because only variables in memory can be volatile, and register variables are not located in memory.</dd></dl>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_startup"></a>
How to modify MCUCR or WDTCR early?</h1>
<p>Basically, write a small function which looks like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io_8h.html">avr/io.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> __attribute__((used, unused, naked, section(<span class="stringliteral">&quot;.init3&quot;</span>)))</div>
<div class="line">void init_MCUCR (<span class="keywordtype">void</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> init_MCUCR (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    MCUCR = <a class="code hl_define" href="group__avr__sfr.html#ga11643f271076024c395a93800b3d9546">_BV</a>(SRE) | <a class="code hl_define" href="group__avr__sfr.html#ga11643f271076024c395a93800b3d9546">_BV</a>(SRW);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__sfr_html_ga11643f271076024c395a93800b3d9546"><div class="ttname"><a href="group__avr__sfr.html#ga11643f271076024c395a93800b3d9546">_BV</a></div><div class="ttdeci">#define _BV(bit)</div><div class="ttdef"><b>Definition:</b> sfr_defs.h:206</div></div>
<div class="ttc" id="aio_8h_html"><div class="ttname"><a href="io_8h.html">io.h</a></div></div>
</div><!-- fragment --><p>Do not call this function by hand! This piece of code will be inserted in <a class="el" href="mem_sections.html#sec_dot_init">startup code</a>, which is run right after reset. For the meaning of the attributes, see <a class="el" href="FAQ.html#faq_softreset">How do I perform a software reset of the AVR?</a></p>
<p>The advantage of this method is that you can insert any initialization code you want (just remember that this is very early startup &ndash; no stack and no <code><a class="el" href="FAQ.html#zero_reg">__zero_reg__</a></code> yet), and no program memory space is wasted if this feature is not used.</p>
<p>There should be no need to modify linker scripts anymore, except for some very special cases. It is best to leave <code>__stack</code> at its default value (end of internal SRAM &ndash; faster, and required on some devices like ATmega161 because of errata), and add <code>-Wl,-Tdata,0x801100</code> to start the data section above the stack.</p>
<p>For more information on using sections, see <a class="el" href="mem_sections.html">Memory Sections</a>. There is also an example for <a class="el" href="mem_sections.html#c_sections">In C/C++ Code</a>. Note that in C code, any such function would preferably be placed into section <code>.init3</code> as the code in <code>.init2</code> ensures the internal register <code>__zero_reg__</code> is already cleared.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_cplusplus"></a>
Can I use C++ on the AVR?</h1>
<p>Basically yes, C++ is supported (assuming your compiler has been configured and compiled to support it, of course). Source files ending in <code>.cc</code>, <code>.cpp</code> or <code>.C</code> will automatically cause the compiler frontend to invoke the C++ compiler. Alternatively, the C++ compiler could be explicitly called by the name <code>avr-c++</code>.</p>
<p>However, there's currently no support for <code>libstdc++</code>, the standard support library needed for a complete C++ implementation. This imposes a number of restrictions on the C++ programs that can be compiled. Among them are:</p>
<ul>
<li>Obviously, none of the C++ related standard functions, classes, and template classes are available.</li>
<li>The operators <code>new</code> and <code>delete</code> are not implemented, attempting to use them will cause the linker to complain about undefined external references. (This could perhaps be fixed.)</li>
<li>Some of the supplied include files are not C++ safe, i. e. they need to be wrapped into <div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> { ... } </div>
</div><!-- fragment --> (This could certainly be fixed, too.)</li>
<li>Exceptions are not supported. Since exceptions are enabled by default in the C++ frontend, they explicitly need to be turned off using <code>-fno-exceptions</code> in the compiler options. Failing this, the linker will complain about an undefined external reference to <code>__gxx_personality_sj0</code>.</li>
</ul>
<p>Constructors and destructors <em>are</em> supported though, including global ones.</p>
<p>When programming C++ in space- and runtime-sensitive environments like microcontrollers, extra care should be taken to avoid unwanted side effects of the C++ calling conventions like implied copy constructors that could be called upon function invocation etc. These things could easily add up into a considerable amount of time and program memory wasted. Thus, casual inspection of the generated assembler code (using the <a class="el" href="using_tools.html#opt_save_temps">-save-temps</a> compiler option) seems to be warranted.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_asmconst"></a>
How do I use a #define'd constant in an asm statement?</h1>
<p>So you tried this:</p>
<div class="fragment"><div class="line"><span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">&quot;sbi 0x18, 7&quot;</span> ::: <span class="stringliteral">&quot;memory&quot;</span>);</div>
</div><!-- fragment --><p>Which works. When you do the same thing but replace the address of the port by its macro name, like this:</p>
<div class="fragment"><div class="line"><span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">&quot;sbi PORTB, 7&quot;</span> ::: <span class="stringliteral">&quot;memory&quot;</span>);</div>
</div><!-- fragment --><p>you get a syntax error from the assembler: <code>"Error: constant value required"</code>.</p>
<p><code>PORTB</code> is a precompiler definition included in the processor specific file included in <code><a class="el" href="io_8h.html">avr/io.h</a></code>. As you may know, the precompiler will not touch strings, and <code>PORTB</code> gets passed to the assembler instead of <code>0x18</code>. One way to avoid this problem is:</p>
<div class="fragment"><div class="line"><span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">&quot;sbi %0, 7&quot;</span> :: <span class="stringliteral">&quot;I&quot;</span> (_SFR_IO_ADDR(PORTB)) : <span class="stringliteral">&quot;memory&quot;</span>);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>For C programs, rather use the standard C bit operators instead, so the above would be expressed as <code>PORTB |= (1 &lt;&lt; 7)</code>. The optimizer will take care to transform this into a single SBI instruction, assuming the operands allow for this.</dd></dl>
<p>There are situation though where the address of a special function register (SFR) is required in inline assembly. When the register can be accessed by <code>LDS</code> and <code>STS</code>, one can use the RAM address of the SFR:</p>
<div class="fragment"><div class="line"><span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">&quot;sts %0, __zero_reg__&quot;</span> :: <span class="stringliteral">&quot;n&quot;</span> (&amp; PORTB) : <span class="stringliteral">&quot;memory&quot;</span>);</div>
</div><!-- fragment --><p>When the I/O address of the register is required, one way is to use <code>_SFR_IO_ADDR</code> to get the I/O address like in the example above. A different approach is to use inline asm <a class="el" href="inline_asm.html#inline_asm_print_modifiers">print modifier</a> <code>%i</code> supported since avr-gcc v4.7:</p>
<div class="fragment"><div class="line"><span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">&quot;out %i0, __zero_reg__&quot;</span> :: <span class="stringliteral">&quot;n&quot;</span> (&amp; PORTB) : <span class="stringliteral">&quot;memory&quot;</span>);</div>
</div><!-- fragment --><p>The <code>%i0</code> will print the address of <code>PORTB</code> as an I/O address.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_gdboptimize"></a>
Why does the PC randomly jump around when single-stepping through my program in avr-gdb?</h1>
<p>When compiling a program with both optimization (<code>-O</code>) and debug information (<code>-g</code>) which is fortunately possible in <code>avr-gcc</code>, the code watched in the debugger is optimized code. It is guaranteed that the code runs with the exact same optimizations as it would run without the <code>-g</code> switch.</p>
<p>Since the compiler is free to reorder code execution as long as the semantics do not change, code is often rearranged in order to make it possible to use a single branch instruction for conditional operations. Branch instructions can only cover a short range for the target PC (-63 through +64 words from the current PC). If a branch instruction cannot be used directly, the compiler needs to work around it by combining a skip instruction together with a relative jump (<code>rjmp</code>) instruction, which will need one additional word of ROM.</p>
<p>Another side effect of optimization is that variable usage is restricted to the area of code where it is actually used. So if a variable was placed in a register at the beginning of some function, this same register can be re-used later on if the compiler notices that the first variable is no longer used inside that function, even though the variable is still in lexical scope. When trying to examine the variable in <code>avr-gdb</code>, the displayed result will then look garbled.</p>
<p>So in order to avoid these side effects, optimization can be turned off while debugging, or at least optimization level <code>-Og</code> can be used which was introduced to improve good debugging experience while it still provides a reasonable amount of optimization.</p>
<p>However, some of these optimizations might also have the side effect of uncovering bugs that would otherwise not be obvious, so it must be noted that turning off optimization can easily change the bug pattern. In most cases, you are better off leaving optimizations enabled while debugging.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_asmstabs"></a>
How do I trace an assembler file in avr-gdb?</h1>
<p>When using the <code>-g</code> compiler option, <code>avr-gcc</code> only generates line number and other debug information for C (and C++) files that pass the compiler. Functions that don't have line number information will be completely skipped by a single <code>step</code> command in <code>gdb</code>. This includes functions linked from a standard library, but by default also functions defined in an assembler source file, since the <code>-g</code> compiler switch does not apply to the assembler.</p>
<p>So in order to debug an assembler input file (possibly one that has to be passed through the C preprocessor), it's the assembler that needs to be told to include line-number information into the output file. (Other debug information like data types and variable allocation cannot be generated, since unlike a compiler, the assembler basically doesn't know about this.) This is done using the (GNU) assembler option <code>--gstabs</code>.</p>
<p>Example:</p>
<pre class="fragment">$ avr-as -mmcu=atmega128 --gstabs -o foo.o foo.s
</pre><p>When the assembler is not called directly but through the C compiler frontend (either implicitly by passing a source file ending in <code>.S</code>, or explicitly using <code>-x assembler-with-cpp</code>), the compiler frontend needs to be told to pass the <code>--gstabs</code> option down to the assembler. This is done using <code>-Wa,--gstabs</code>. Please take care to <em>only</em> pass this option when compiling an assembler input file. Otherwise, the assembler code that results from the C compilation stage will also get line number information, which confuses the debugger.</p>
<dl class="section note"><dt>Note</dt><dd>You can also use <code>-Wa,-gstabs</code> since the compiler will add the extra <code>'-'</code> for you.</dd></dl>
<p>Example:</p>
<pre class="fragment">$ EXTRA_OPTS="-Wall -mmcu=atmega128 -x assembler-with-cpp"
$ avr-gcc -Wa,--gstabs ${EXTRA_OPTS} -c -o foo.o foo.S
</pre><p>Also note that the debugger might get confused when entering a piece of code that has a non-local label before, since it then takes this label as the name of a new function that appears to have been entered. Thus, the best practice to avoid this confusion is to only use non-local labels when declaring a new function, and restrict anything else to local labels. Local labels consist just of a number only. References to these labels consist of the number, followed by the letter <b>b</b> for a backward reference, or <b>f</b> for a forward reference. These local labels may be re-used within the source file, references will pick the closest label with the same number and given direction.</p>
<p>Example:</p>
<pre class="fragment">myfunc:
    push    r16
    push    r17
    push    r18
    push    YL
    push    YH
    ...
    clr     r16             ; start loop
    ldi     YL, lo8(sometable)
    ldi     YH, hi8(sometable)
    rjmp    2f              ; jump to loop test at end
1:  ld      r17, Y+         ; loop continues here
    ...
    breq    3f              ; return from myfunc prematurely
    ...
    inc     r16
2:  cmp     r16, r18
    brlo    1b              ; jump back to top of loop
3:  pop     YH
    pop     YL
    pop     r18
    pop     r17
    pop     r16
    ret
</pre><p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_port_pass"></a>
How do I pass an IO port as a parameter to a function?</h1>
<p>Consider this example code:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdint_8h.html">stdint.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io_8h.html">avr/io.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">set_bits_func_wrong (<span class="keyword">volatile</span> <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> port, <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> mask)</div>
<div class="line">{</div>
<div class="line">    port |= mask;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">set_bits_func_correct (<span class="keyword">volatile</span> <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *port, <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> mask)</div>
<div class="line">{</div>
<div class="line">    *port |= mask;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    set_bits_func_wrong (PORTB, 0xaa);</div>
<div class="line">    set_bits_func_correct (&amp;PORTB, 0x55);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astdint_8h_html"><div class="ttname"><a href="stdint_8h.html">stdint.h</a></div></div>
</div><!-- fragment --><p>The first function will generate object code which is not even close to what is intended. The major problem arises when the function is called. When the compiler sees this call, it will actually pass the value of the <code>PORTB</code> register (using an <code>IN</code> instruction), instead of passing the address of <code>PORTB</code> (e.g. memory mapped io addr of <code>0x38</code>, io port <code>0x18</code> for the mega128). This is seen clearly when looking at the disassembly of the call:</p>
<pre class="fragment">    set_bits_func_wrong (PORTB, 0xaa);
 10a:   6a ea           ldi     r22, 0xAA
 10c:   88 b3           in      r24, 0x18
 10e:   0e 94 65 00     call    0xca
</pre><p>So, the function, once called, only sees the value of the port register and knows nothing about which port it came from. At this point, whatever object code is generated for the function by the compiler is irrelevant. The interested reader can examine the full disassembly to see that the function's body is completely fubar.</p>
<p>The second function shows how to pass (by reference) the memory mapped address of the io port to the function so that you can read and write to it in the function. Here's the object code generated for the function call:</p>
<pre class="fragment">    set_bits_func_correct (&amp;PORTB, 0x55);
 112:   65 e5           ldi     r22, 0x55
 114:   88 e3           ldi     r24, 0x38
 116:   90 e0           ldi     r25, 0x00
 118:   0e 94 7c 00     call    0xf8
</pre><p>You can clearly see that <code>0x0038</code> is correctly passed for the address of the io port. Looking at the disassembled object code for the body of the function, we can see that the function is indeed performing the operation we intended:</p>
<pre class="fragment">void
set_bits_func_correct (volatile uint8_t *port, uint8_t mask)
{
  f8:   fc 01           movw    r30, r24
    *port |= mask;
  fa:   80 81           ld      r24, Z
  fc:   86 2b           or      r24, r22
  fe:   80 83           st      Z, r24
}
 100:   08 95           ret
</pre><p>Notice that we are accessing the io port via the <code>LD</code> and <code>ST</code> instructions.</p>
<p>The <code>port</code> parameter must be volatile to avoid a compiler warning.</p>
<dl class="section note"><dt>Note</dt><dd>Because of the nature of the <code>IN</code> and <code>OUT</code> assembly instructions, they can not be used inside the function when passing the port in this way. Readers interested in the details should consult the <em>Instruction Set</em> datasheet.</dd></dl>
<p>In this contrived example, the most efficient method with respect to both execution speed and code size is to inline the function:</p>
<p>static inline void set_bits_func_correct (volatile uint8_t *port, uint8_t mask) { port |= mask; }</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_reg_usage"></a>
What registers are used by the compiler?</h1>
<p>See also the <a href="https://gcc.gnu.org/wiki/avr-gcc#Type_Layout">Type Layout</a>, <a href="https://gcc.gnu.org/wiki/avr-gcc#Register_Layout">Register Layout</a> and <a href="https://gcc.gnu.org/wiki/avr-gcc#Calling_Convention">Calling Convention</a> sections in the avr-gcc Wiki.</p>
<dl>
<dt>Data types </dt>
<dd><p class="startdd"><code>char</code> is 8 bits, <code>int</code> and <code>short</code> are 16 bits, <code>long</code> is 32 bits, <code>long</code> <code>long</code> is 64 bits, <code>float</code> is 32 bits, <code>double</code> and <code>long</code> <code>double</code> are 32 bits or 64 bits, pointers are 16 bits (function pointers are word addresses to allow addressing up to 128K program memory space).</p>
<ul>
<li>There is a <code>-mint8</code> option (see <a class="el" href="using_tools.html#using_avr_gcc">Options for the C compiler avr-gcc</a>) to make <code>int</code> and <code>short</code> 8 bits, <code>long</code> 16 bits and <code>long</code> <code>long</code> 32 bits. But that is not supported by AVR-LibC (except for <code><a class="el" href="stdint_8h.html">stdint.h</a></code> and <code><a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a></code>, but no 64-bit integer types are available) and violates C standards (<code>int</code> <em>must</em> be at least 16 bits). </li>
</ul>
<p class="enddd"></p>
</dd>
<dt>Call-used registers (r18-r27, r30-r31) </dt>
<dd><p class="startdd">May be allocated by gcc for local data. You <em>may</em> use them freely in assembly subroutines. Calling C subroutines can clobber any of them - the caller is responsible for saving and restoring.</p>
<p class="interdd">For the Reduced Core architecture (ATtiny10 and relatives), r20-r27 and r30-31 are call-clobbered. </p>
<p class="enddd"></p>
</dd>
<dt>Call-saved registers (r2-r17, r28-r29) </dt>
<dd><p class="startdd">May be allocated by gcc for local data. Calling C subroutines leaves them unchanged. Assembly subroutines are responsible for saving and restoring these registers, if changed. r29:r28 (Y pointer) is used as a frame pointer (points to local data on stack) if necessary. The requirement for the callee to save/preserve the contents of these registers even applies in situations where the compiler assigns them for argument passing.</p>
<p class="interdd">For the Reduced Core architecture (ATtiny10 etc.), r18-r19 and r28-r29 are call-saved. Registers r0 through r15 do not exist. </p>
<p class="enddd"></p>
</dd>
<dt><a class="anchor" id="zero_reg"></a><a class="anchor" id="tmp_reg"></a>Fixed registers (r0, r1) </dt>
<dd><p class="startdd">Never allocated by gcc for local data, but often used for fixed purposes:</p>
<ul>
<li><b>r0</b> (<code>__tmp_reg__</code>) &mdash; temporary register, can be clobbered by any code (except interrupt handlers which save it), <em>may</em> be used to remember something for a while within one piece of assembly code</li>
<li><b>r1</b> (<code>__zero_reg__</code>) &mdash; assumed to be always zero in any C code, <em>may</em> be used to remember something for a while within one piece of assembler code, but <em>must</em> then be cleared after use (<code>clr __zero_reg__</code>). This includes any use of the <code>[f]mul[s[u]]</code> instructions, which return their result in r1:r0. Interrupt handlers save and clear <code>__zero_reg__</code> on entry, and restore it on exit (in case it was non-zero).</li>
<li><b>T flag</b> &mdash; the <code>T</code> flag in the status register (<code>SREG</code>) can be used the same way like <code>__tmp_reg__</code>.</li>
</ul>
<p class="interdd">For the Reduced Core architecture (ATtiny10 etc.), <code>__tmp_reg__</code> is r16, and <code>__zero_reg__</code> is r17. </p>
<p class="enddd"></p>
</dd>
<dt>Function call conventions </dt>
<dd><p class="startdd">Arguments - allocated left to right, r25 to r8. All arguments are aligned to start in even-numbered registers (odd-sized arguments, including <code>char</code>, have one free register above them). This allows making better use of the <code>movw</code> instruction on the enhanced core.</p>
<p class="interdd">If too many, those that don't fit are passed on the stack.</p>
<p class="interdd">On AVRrc, r25 to r20 are used to pass values.</p>
<ul>
<li>Return values: 8-bit in r24, 16-bit in r25:r24, up to 32 bits in r22-r25, up to 64 bits in r18-r25.</li>
<li>Arguments to functions with a variable number of lists like <code>printf</code> get all their values on the stack. <code>char</code> is extended to <code>int</code>, and <code>float</code> is extended to <code>double</code>.</li>
<li>When an argument is passed on the stack, all subsequent arguments are also passed on the stack.</li>
<li>An argument is either passed completely in registers or completely on the stack.</li>
<li>Arguments with a size of zero or with a size larger than 8 bytes (4 bytes on AVR_TINY) are returned in memory. The caller provides the memory location as implicit first argument to the callee.</li>
<li>When an argument is returned in registers, its size is padded to the next power of 2.</li>
</ul>
</dd>
</dl>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_rampx"></a>
How are the RAMPX, RAMPY, RAMPZ and RAMPD registers handled?</h1>
<p>See <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#ramp">The RAMPX, RAMPY, RAMPZ and RAMPD special function registers</a> in the GCC documentation.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_eind"></a>
How is the EIND special function register handled?</h1>
<p>See <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#eind">The EIND special function register</a> in the GCC documentation.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_ext_ram"></a>
How to use external RAM?</h1>
<p>Well, there is no universal answer to this question; it depends on what the external RAM is going to be used for.</p>
<p>Basically, the bit <code>SRE</code> (SRAM enable) in the <code>MCUCR</code> register needs to be set in order to enable the external memory interface. Depending on the device to be used, and the application details, further registers affecting the external memory operation like <code>XMCRA</code> and <code>XMCRB</code>, and/or further bits in <code>MCUCR</code> might be configured. Refer to the datasheet for details.</p>
<p>If the external RAM is going to be used to store the variables from the C program (i. e., the <code>.data</code> and/or <code>.bss</code> segment) in that memory area, it is essential to set up the external memory interface early during the <a class="el" href="mem_sections.html#sec_dot_init">device initialization</a> so the initialization of these variable will take place. Refer to <a class="el" href="FAQ.html#faq_startup">How to modify MCUCR or WDTCR early?</a> for a description how to do this using few lines of assembler code, or to the chapter about memory sections for an <a class="el" href="mem_sections.html#c_sections">example written in C</a>.</p>
<p>The explanation of malloc() contains a <a class="el" href="malloc.html#malloc_where">discussion</a> about the use of internal RAM vs. external RAM in particular with respect to the various possible locations of the <em>heap</em> (area reserved for malloc()). It also explains the linker command-line options that are required to move the memory regions away from their respective standard locations in internal RAM.</p>
<p>Finally, if the application simply wants to use the additional RAM for private data storage kept outside the domain of the C compiler (e. g. through a <code>char *</code> variable initialized directly to a particular address), it would be sufficient to defer the initialization of the external RAM interface to the beginning of <code>main()</code>, so no tweaking of the <code>.init3</code> section is necessary. The same applies if only the heap is going to be located there, since the application start-up code does not affect the heap.</p>
<p>It is not recommended to locate the stack in external RAM. In general, accessing external RAM is slower than internal RAM, and errata of some AVR devices even prevent this configuration from working properly at all.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_optflags"></a>
Which -O flag to use?</h1>
<p>There's a common misconception that larger numbers behind the <code>-O</code> option might automatically cause "better" optimization. First, there's no universal definition for "better", with optimization often being a speed vs. code size trade off. See the <a class="el" href="using_tools.html#gcc_optO">detailed discussion</a> for which option affects which part of the code generation.</p>
<p>A test case was run on an ATmega128 to judge the effect of compiling the library itself using different optimization levels. The following table lists the results. The test case consisted of around 2 KB of strings to sort. Test #1 used <a class="el" href="group__avr__stdlib.html#gafd4bf2faec43342e7ad3d2ab37bac1fe">qsort()</a> using the standard library <a class="el" href="group__avr__string.html#ga21e4788b4a0ae39b11aa32e9a1079f98" title="Compare two strings.">strcmp()</a>, test #2 used a function that sorted the strings by their size (thus had two calls to <a class="el" href="group__avr__string.html#ga219836f542ce53545052bed5353820ca" title="Calculate the length of a string.">strlen()</a> per invocation).</p>
<p>When comparing the resulting code size, it should be noted that a floating point version of fvprintf() was linked into the binary (in order to print out the time elapsed) which is entirely not affected by the different optimization levels, and added about 2.5 KB to the code.</p>
<table class="doxtable">
<tr>
<th>Optimization Flags </th><th>Size of .text </th><th>Time for Test #1 </th><th>Time for Test #2  </th></tr>
<tr>
<td>-O3 </td><td>6898 </td><td>903 &mu;s </td><td>19.7 ms  </td></tr>
<tr>
<td>-O2 </td><td>6666 </td><td>972 &mu;s </td><td>20.1 ms  </td></tr>
<tr>
<td>-Os </td><td>6618 </td><td>955 &mu;s </td><td>20.1 ms  </td></tr>
<tr>
<td>-Os -mcall-prologues </td><td>6474 </td><td>972 &mu;s </td><td>20.1 ms  </td></tr>
</table>
<p>(The difference between 955 &mu;s and 972 &mu;s was just a single timer-tick, so take this with a grain of salt.)</p>
<p>So generally, it seems <code>-Os -mcall-prologues</code> is the most universal "best" optimization level. Only applications that need to get the last few percent of speed benefit from using <code>-O3</code>.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_reloc_code"></a>
How do I relocate code to a fixed address?</h1>
<p>First, put the function into a new, orphan <a class="el" href="mem_sections.html#sec_named">named section</a>. This is done with a <code>section</code> attribute that specifies the name of the <a class="el" href="mem_sections.html#sec_input">input section</a> with the prototype of the function:</p>
<div class="fragment"><div class="line">__attribute__ ((noinline, noclone, section (<span class="stringliteral">&quot;.bootloader&quot;</span>)))</div>
<div class="line">void boot (<span class="keywordtype">void</span>);</div>
</div><!-- fragment --><p>The <code>noinline</code> and <code>noclone</code> attributes are required to make sure that the function is not (partially) inlined into the caller, which does not have a respective section attribute.</p>
<p>Second, locate the section to the desired fixed address by means of linking with, say </p><pre class="fragment">-Wl,--section-start,.bootloader=0x1E000
</pre><p> see the <a class="el" href="using_tools.html#gcc_minusW">-Wl compiler option</a>. The name after <code>--section-start</code> is the name of the section to be located, and the number specifies the beginning address of the named section.</p>
<p>This will only work when the section is an <a class="el" href="mem_sections.html#sec_orphan">orphan section</a>, i.e. a section that is not mentioned in the linker script. For sections that <em>are</em> mentioned in the linker script, like for example <code>.text.bootloader</code>, this will not work because <code>--section-start</code> refers to an output section, but the output section for input section <code>.text.bootloader</code> is the <code>.text</code> section.</p>
<p>To verify that everything went as expected, generate the disassembly with <code>avr-objdump ... -j .bootloader</code>. The top of the list file will show </p><pre class="fragment">  1 .bootloader   00000004  00002000  00002000  00000204  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
</pre><p> Or display section properties with <code>avr-readelf --section-details</code> </p><pre class="fragment">$ avr-readelf -t main.elf
Section Headers:
  [Nr] Name
       Type            Addr     Off    Size   ES   Lk Inf Al
       Flags
  [ 2] .bootloader
       PROGBITS        00002000 000204 000004 00   0   0  1
       [00000006]: ALLOC, EXEC
</pre><p>A different way to locate the section is by means of a custom linker script. The <a href="https://gcc.gnu.org/wiki/avr-gcc#Address_Spaces">avr-gcc Wiki</a> has an example that locates the <code>.progmem2.data</code> section which is used by the compiler for variables in address-space <code>__flash2</code>.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_fuses"></a>
My UART is generating nonsense!  My ATmega128 keeps crashing! Port F is completely broken!</h1>
<p>Well, certain odd problems arise out of the situation that the AVR devices as shipped by Atmel often come with a default fuse bit configuration that doesn't match the user's expectations. Here is a list of things to care for:</p>
<ul>
<li>All devices that have an internal RC oscillator ship with the fuse enabled that causes the device to run off this oscillator, instead of an external crystal. This often remains unnoticed until the first attempt is made to use something critical in timing, like UART communication.</li>
<li>The ATmega128 ships with the fuse enabled that turns this device into ATmega103 compatibility mode. This means that some ports are not fully usable, and in particular that the internal SRAM is located at lower addresses. Since by default, the stack is located at the top of internal SRAM, a program compiled for an ATmega128 running on such a device will immediately crash upon the first function call (or rather, upon the first function return).</li>
<li>Devices with a JTAG interface have the <code>JTAGEN</code> fuse programmed by default. This will make the respective port pins that are used for the JTAG interface unavailable for regular IO.</li>
</ul>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_16bitio"></a>
Why do some 16-bit timer registers sometimes get trashed?</h1>
<p>Some of the timer-related 16-bit IO registers use a temporary register (called TEMP in the AVR datasheet) to guarantee an atomic access to the register despite the fact that two separate 8-bit IO transfers are required to actually move the data. Typically, this includes access to the current timer/counter value register (<code>TCNT</code><em>n</em>), the input capture register (<code>ICR</code><em>n</em>), and write access to the output compare registers (<code>OCR</code><em>nM</em>). Refer to the actual datasheet for each device's set of registers that involves the TEMP register.</p>
<p>When accessing one of the registers that use TEMP from the main application, and possibly any other one from within an interrupt routine, care must be taken that no access from within an interrupt context could clobber the TEMP register data of an in-progress transaction that has just started elsewhere.</p>
<p>To protect interrupt routines against other interrupt routines, it's usually best to use the <a class="el" href="group__avr__interrupts.html#gad28590624d422cdf30d626e0a506255f">ISR()</a> macro when declaring the interrupt function, and to ensure that interrupts are still disabled when accessing those 16-bit timer registers.</p>
<p>Within the main program, access to those registers could be encapsulated in calls to the <a class="el" href="group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162">cli()</a> and <a class="el" href="group__avr__interrupts.html#gaad5ebd34cb344c26ac87594f79b06b73">sei()</a> macros. If the status of the global interrupt flag before accessing one of those registers is uncertain, something like the following example code can be used.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io_8h.html">avr/io.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> read_timer1 (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> sreg = SREG;</div>
<div class="line">    <a class="code hl_typedef" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> val;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162">cli</a>();</div>
<div class="line">    val = TCNT1;</div>
<div class="line">    SREG = sreg;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> val;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__interrupts_html_ga68c330e94fe121eba993e5a5973c3162"><div class="ttname"><a href="group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162">cli</a></div><div class="ttdeci">#define cli()</div><div class="ttdef"><b>Definition:</b> interrupt.h:88</div></div>
<div class="ttc" id="agroup__avr__stdint_html_ga1f1825b69244eb3ad2c7165ddc99c956"><div class="ttname"><a href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a></div><div class="ttdeci">unsigned int uint16_t</div><div class="ttdef"><b>Definition:</b> stdint.h:96</div></div>
</div><!-- fragment --><p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_varinit"></a>
Shouldn't I initialize all my variables?</h1>
<p>Variables in static storage are guaranteed to be initialized by the C standard. This includes global and static variables without explicit initializer, which are initialized to 0. <code>avr-gcc</code> does this by placing the appropriate code into section <code><a class="el" href="mem_sections.html#sec_dot_init">.init4</a></code>. With respect to the standard, this sentence is somewhat simplified (because the standard allows for machines where the actual bit pattern used differs from all bits being 0), but for the AVR target, in general, all integer-type variables are set to 0, all pointers to a NULL pointer, and all floating-point variables to 0.0.</p>
<p>As long as these variables are not explicitly initialized, or their initializer is all zeros, they go into the <a class="el" href="mem_sections.html#sec_dot_bss">.bss</a> output section. This section simply records the size of the variable, but otherwise doesn't consume space, neither within the object file nor within flash memory. (Of course, being a variable, it will consume space in the target's SRAM.)</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_flashstrings"></a>
Why do all my string literals eat up the SRAM?</h1>
<p>By default, string literals are handled like all other initialized constants in static storage: They are put into a <code>.rodata</code> <a class="el" href="mem_sections.html#sec_input_output">input section</a>.</p>
<p>On old devices, the <code>.rodata</code> input sections are allocated to the <a class="el" href="mem_sections.html#sec_dot_data">.data</a> output section, which means that such objects occupy memory in the flash ROM <em>and</em> in the SRAM according to the following rules:</p>
<table class="doxtable">
<caption>Non-Zero Data in Static Storage</caption>
<tr>
<th>Read-Only </th><th>Input Section </th><th>Output Section </th><th>Memory Region(s) </th><th>Case  </th></tr>
<tr>
<td>No </td><td>.data </td><td>.data </td><td>text <em>and</em> data </td><td>All </td></tr>
<tr>
<td rowspan="3">Yes </td><td rowspan="3">.rodata </td><td><b>.data</b> </td><td>text <em>and</em> data </td><td>3 </td></tr>
<tr>
<td>.rodata </td><td>text </td><td>1 </td></tr>
<tr>
<td>.rodata </td><td>rodata </td><td>2  </td></tr>
</table>
<p><b>Cases</b></p><ol type="1">
<li>Devices that see all of program memory in the RAM address space: <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrtiny">avrtiny</a> (AVRrc), <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrxmega3">avrxmega3</a> (AVR16 and AVR32 devices, 0-series, 1-series and 2-series).</li>
<li>Devices that see only a part of program memory in the RAM address space: AVR64 and AVR128 devices without <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#index-mrodata-in-ram"><code>-mrodata-in-ram</code></a>.</li>
<li>All other devices, i.e. devices that don't see (parts of) the program memory in the RAM address space, or when <code>-mrodata-in-ram</code> is specified. The place in the flash ROM (<code>.text</code>) is occupied by the initializer values that are used by the startup code to initialize the objects in the <code>.data</code> output section.</li>
</ol>
<p>The question remains: Why is case 3. allocating constant variables into the SRAM? For a better understanding, consider the following code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> get_first_char (<span class="keyword">const</span> <span class="keywordtype">char</span> *str)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> str[0];</div>
<div class="line">}</div>
</div><!-- fragment --><p>What code should the compiler generate for that function? Notice that it is perfectly fine to pass a string that is not constant through the <code>const char *str</code> parameter, which only states that <code>get_first_char</code> won't change <code>str</code> like in the following use cases:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> func1 (<span class="keywordtype">int</span> i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> str[10];</div>
<div class="line">    <a class="code hl_function" href="group__avr__stdio.html#ga6017094d9fd800fa02600d35399f2a2a">sprintf</a> (str, <span class="stringliteral">&quot;%d&quot;</span>, i);</div>
<div class="line">    <span class="keywordflow">return</span> get_first_char (str);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> func2 (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> get_first_char (<span class="stringliteral">&quot;Hello&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__stdio_html_ga6017094d9fd800fa02600d35399f2a2a"><div class="ttname"><a href="group__avr__stdio.html#ga6017094d9fd800fa02600d35399f2a2a">sprintf</a></div><div class="ttdeci">int sprintf(char *__s, const char *__fmt,...)</div><div class="ttdef"><b>Definition:</b> sprintf.c:37</div></div>
</div><!-- fragment --><p>In any case the compiler will generate code like this: </p><div class="fragment"><div class="line">get_first_char:</div>
<div class="line">    movw r30, r24</div>
<div class="line">    ld   r24, Z</div>
<div class="line">    ret</div>
</div><!-- fragment --><p>For the devices from 1. and 2. the <code>"ld r24,Z"</code> will read from flash or from SRAM depending on the address passed in R24. But on the old 3. devices only LPM can read from flash, and therefore the tools place <code>"Hello"</code> in RAM so that the code works for all possible string addresses. The same applies to all other constants in static storage.</p>
<p>Of course, this is going to waste a lot of SRAM on the old devices.</p>
<p>For ways how to place string literals in flash ROM (and to access them), see also the next section <a class="el" href="FAQ.html#faq_rom_array">How do I put an array of strings completely in ROM?</a>.</p>
<dl class="section note"><dt>Note</dt><dd>What follows is only needed when the <code>.rodata</code> <a class="el" href="mem_sections.html#sec_input_output">input sections</a> are located in RAM, which is only the case for the "old" AVR devices. See the table above.</dd></dl>
<h2><a class="anchor" id="faq_flashstrings_progmem"></a>
Use PROGMEM</h2>
<p>In <a class="el" href="group__avr__pgmspace.html">Program Space String Utilities</a>, a method is described how such constant data can be moved out to flash ROM. However, a constant string located in flash ROM is no longer a valid argument to pass to a function that expects a <code>const char*</code>-type string, since the old AVR devices need the special instruction <code>LPM</code> to access these strings. Thus, separate functions are needed that take this into account. Many of the standard C library functions have equivalents available where one of the string arguments can be located in flash ROM. Private functions in the applications need to handle this, too. For example, the following can be used to implement simple debugging messages that will be sent through a UART:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io_8h.html">avr/io.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> uart_putchar (<span class="keywordtype">char</span> c)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;\n&#39;</span>)</div>
<div class="line">    uart_putchar (<span class="charliteral">&#39;\r&#39;</span>);</div>
<div class="line">  <a class="code hl_define" href="group__avr__sfr.html#gaaf6857fa882da35f8685e2001e5c3bbe">loop_until_bit_is_set</a> (USR, UDRE);</div>
<div class="line">  UDR = c;</div>
<div class="line">  <span class="keywordflow">return</span> 0; <span class="comment">// So it could be used for fdevopen(), too.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> debug_P (<span class="keyword">const</span> <span class="keywordtype">char</span> *addr)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">char</span> c;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> ((c = <a class="code hl_function" href="group__avr__pgmspace.html#ga9e71104956e1361499586162104975e7">pgm_read_char</a>(addr++)))</div>
<div class="line">    uart_putchar (c);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  ioinit();  <span class="comment">// Initialize UART, ...</span></div>
<div class="line">  debug_P (<a class="code hl_define" href="group__avr__pgmspace.html#ga73809107539df84eaf01f6a4dea4fbff">PSTR</a> (<span class="stringliteral">&quot;foo was here\n&quot;</span>));</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__pgmspace_html_ga73809107539df84eaf01f6a4dea4fbff"><div class="ttname"><a href="group__avr__pgmspace.html#ga73809107539df84eaf01f6a4dea4fbff">PSTR</a></div><div class="ttdeci">#define PSTR(str)</div><div class="ttdef"><b>Definition:</b> pgmspace.h:691</div></div>
<div class="ttc" id="agroup__avr__pgmspace_html_ga9e71104956e1361499586162104975e7"><div class="ttname"><a href="group__avr__pgmspace.html#ga9e71104956e1361499586162104975e7">pgm_read_char</a></div><div class="ttdeci">static char pgm_read_char(const char *addr)</div></div>
<div class="ttc" id="agroup__avr__sfr_html_gaaf6857fa882da35f8685e2001e5c3bbe"><div class="ttname"><a href="group__avr__sfr.html#gaaf6857fa882da35f8685e2001e5c3bbe">loop_until_bit_is_set</a></div><div class="ttdeci">#define loop_until_bit_is_set(sfr, bit)</div><div class="ttdef"><b>Definition:</b> sfr_defs.h:252</div></div>
<div class="ttc" id="apgmspace_8h_html"><div class="ttname"><a href="pgmspace_8h.html">pgmspace.h</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>By convention, the suffix <b>_P</b> to the function name is used as an indication that this function is going to accept a "program-space
string". Note also the use of the <code><a class="el" href="group__avr__pgmspace.html#ga73809107539df84eaf01f6a4dea4fbff">PSTR</a></code> macro.</dd></dl>
<h2><a class="anchor" id="faq_flashstrings_flash"></a>
Use __flash</h2>
<p>As an alternative, the GNU-C named address-space <code><a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a></code> can be used. Notice the proper address-space qualification of <code>debug_F</code>, the usage of <a class="el" href="group__avr__flash.html#gabec036cb18588b3891217d4e0be515ee">FSTR</a> instead of <code>PSTR</code>, and that reading from a <code><a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a></code> address can be accomplished by open-coded C code like in <code>*addr++</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io_8h.html">avr/io.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="flash_8h.html">avr/flash.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> debug_F (<span class="keyword">const</span> <a class="code hl_variable" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> <span class="keywordtype">char</span> *addr)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">char</span> c;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> ((c = *addr++))</div>
<div class="line">    uart_putchar (c);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  ioinit(); <span class="comment">// initialize UART, ...</span></div>
<div class="line">  debug_F (<a class="code hl_define" href="group__avr__flash.html#gabec036cb18588b3891217d4e0be515ee">FSTR</a> (<span class="stringliteral">&quot;foo was here\n&quot;</span>));</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aflash_8h_html"><div class="ttname"><a href="flash_8h.html">flash.h</a></div></div>
<div class="ttc" id="agroup__avr__flash_html_ga9640f3080a04903165ca21f35da81a38"><div class="ttname"><a href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a></div><div class="ttdeci">__flash</div><div class="ttdef"><b>Definition:</b> flash.h:960</div></div>
<div class="ttc" id="agroup__avr__flash_html_gabec036cb18588b3891217d4e0be515ee"><div class="ttname"><a href="group__avr__flash.html#gabec036cb18588b3891217d4e0be515ee">FSTR</a></div><div class="ttdeci">#define FSTR(str)</div><div class="ttdef"><b>Definition:</b> flash.h:180</div></div>
</div><!-- fragment --><p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_rom_array"></a>
How do I put an array of strings completely in ROM?</h1>
<p>There are times when you may need an array of strings which will never be modified. In this case, you don't want to waste RAM storing the constant strings. For the rationale behind storing constant strings in RAM, see the previos section <a class="el" href="FAQ.html#faq_flashstrings">Why do all my string literals eat up the SRAM?</a> and <a class="el" href="pgmspace.html">Data in Program Space</a></p>
<h2><a class="anchor" id="faq_rom_array_progmem"></a>
With PROGMEM</h2>
<p>The most obvious (and incorrect) thing to do is this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// array[] will be in flash ROM, but &quot;Foo&quot; and &quot;Bar&quot; are still in RAM.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> array[2] <a class="code hl_define" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> =</div>
<div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;Foo&quot;</span>, <span class="stringliteral">&quot;Bar&quot;</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> buf[32];</div>
<div class="line">    <a class="code hl_function" href="group__avr__pgmspace.html#ga5749897c91c479d02054fc02128de482">strcpy_P</a> (buf, array[1]);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__pgmspace_html_ga5749897c91c479d02054fc02128de482"><div class="ttname"><a href="group__avr__pgmspace.html#ga5749897c91c479d02054fc02128de482">strcpy_P</a></div><div class="ttdeci">char * strcpy_P(char *, const char *)</div></div>
<div class="ttc" id="agroup__avr__pgmspace_html_ga75acaba9e781937468d0911423bc0c35"><div class="ttname"><a href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a></div><div class="ttdeci">#define PROGMEM</div><div class="ttdef"><b>Definition:</b> pgmspace.h:144</div></div>
</div><!-- fragment --><p>The result is not what you want though. What you end up with is the array stored in ROM, while the individual strings end up in RAM (in some <code>.rodata</code> input section).</p>
<p>To work around this, you need to do something like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> s_foo[] <a class="code hl_define" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> = <span class="stringliteral">&quot;Foo&quot;</span>;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> s_bar[] <a class="code hl_define" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> = <span class="stringliteral">&quot;Bar&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> array[2] <a class="code hl_define" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> =</div>
<div class="line">{</div>
<div class="line">    s_foo, s_bar</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> func (<a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> buf[32];</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *p = <a class="code hl_define" href="group__avr__pgmspace.html#ga8e93d1e5bf48f30fd1e30adeb4b7cc0f">pgm_read_ptr</a> (&amp;array[i]);</div>
<div class="line">    <a class="code hl_function" href="group__avr__pgmspace.html#ga5749897c91c479d02054fc02128de482">strcpy_P</a> (buf, p);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__pgmspace_html_ga8e93d1e5bf48f30fd1e30adeb4b7cc0f"><div class="ttname"><a href="group__avr__pgmspace.html#ga8e93d1e5bf48f30fd1e30adeb4b7cc0f">pgm_read_ptr</a></div><div class="ttdeci">#define pgm_read_ptr(__addr)</div><div class="ttdef"><b>Definition:</b> pgmspace.h:889</div></div>
</div><!-- fragment --><p>Looking at the disassembly of the resulting object file we see that array is in flash as such:</p>
<pre class="fragment">00000026 &lt;array&gt;:
  26:   2e 00 2a 00

0000002a &lt;bar&gt;:
  2a:   42 61 72 00          Bar.

0000002e &lt;foo&gt;:
  2e:   46 6f 6f 00          Foo.
</pre><p><code>foo</code> is at address 0x002e.<br  />
 <code>bar</code> is at address 0x002a.<br  />
 <code>array</code> is at address 0x0026.<br  />
</p>
<h2><a class="anchor" id="faq_rom_array_as"></a>
With named address-spaces</h2>
<p>An alternative is to use the named address-space <code><a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a></code>, which is supported since avr-gcc v4.7 and in GNU-C99 (<code>-std=gnu99</code>) and up:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="flash_8h.html">avr/flash.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_variable" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> <span class="keywordtype">char</span>* <span class="keyword">const</span> <a class="code hl_variable" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> array[] =</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_define" href="group__avr__flash.html#ga80fd1c204ef50d9959ddcfd122dd3816">FLIT</a>(<span class="stringliteral">&quot;Foo&quot;</span>), <a class="code hl_define" href="group__avr__flash.html#ga80fd1c204ef50d9959ddcfd122dd3816">FLIT</a>(<span class="stringliteral">&quot;Bar&quot;</span>)</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> compare (<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="group__avr__flash.html#ga18da52c839c7307578123e8c021b4474">strcmp_F</a> (str, array[i]);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__flash_html_ga18da52c839c7307578123e8c021b4474"><div class="ttname"><a href="group__avr__flash.html#ga18da52c839c7307578123e8c021b4474">strcmp_F</a></div><div class="ttdeci">int strcmp_F(const char *, const __flash char *)</div></div>
<div class="ttc" id="agroup__avr__flash_html_ga80fd1c204ef50d9959ddcfd122dd3816"><div class="ttname"><a href="group__avr__flash.html#ga80fd1c204ef50d9959ddcfd122dd3816">FLIT</a></div><div class="ttdeci">#define FLIT(str)</div><div class="ttdef"><b>Definition:</b> flash.h:263</div></div>
</div><!-- fragment --><p>Moreover, there is no more need for <code>pgm_read_xxx()</code>: The (addresses of) the string literals can be read directly by means of <code>array[i]</code>. Depending on the application, the string array can be defined as</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_variable" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> <span class="keywordtype">char</span> array[][4] =</div>
<div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;Foo&quot;</span>, <span class="stringliteral">&quot;Bar&quot;</span></div>
<div class="line">};</div>
</div><!-- fragment --><p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_ramoverlap"></a>
How to detect RAM memory and variable overlap problems?</h1>
<p>You can simply run <code>avr-nm</code> on your output (ELF) file. Run it with the <code>-n</code> option, and it will sort the symbols numerically (by default, they are sorted alphabetically).</p>
<p>Look for the symbol <code>_end</code>, that's the first address in RAM that is not allocated by a variable. (avr-gcc internally adds 0x800000 to all data/bss variable addresses, so please ignore this offset.) Then, the run-time initialization code initializes the stack pointer (by default) to point to the last available address in (internal) SRAM. Thus, the region between <code>_end</code> and the end of SRAM is what is available for stack. (If your application uses malloc(), which e. g. also can happen inside <a class="el" href="group__avr__stdio.html#ga4c04da4953607fa5fa4d3908fecde449">printf()</a>, the heap for dynamic memory is also located there. See <a class="el" href="malloc.html">Memory Areas and Using malloc()</a>.)</p>
<p>The amount of stack required for your application cannot be determined that easily. For example, if you recursively call a function and forget to break that recursion, the amount of stack required is infinite. :-) You can look at the generated assembler code (<code>avr-gcc ... <a class="el" href="using_tools.html#opt_save_temps">-save-temps</a></code>), there's a comment in each generated assembler file that tells you the frame size for each generated function.</p>
<p>GCC also supports <code>-fstack-usage</code> that generates an <code>.su</code> text file for each compilation unit:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">$ avr-gcc -c main.c -Os -fstack-usage</div>
<div class="line">$ cat main.su</div>
<div class="line"> </div>
<div class="line">main.c:3:5:main 2   <span class="keyword">static</span></div>
</div><!-- fragment --><p>That's the amount of stack required for this function, you have to add up that for all functions where you know that the calls could be nested.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_tinyavr_c"></a>
Is it really impossible to program the ATtinyXX in C?</h1>
<p>While some small AVRs are not directly supported by the C compiler since they do not have a RAM-based stack (and some do not even have RAM at all), it is possible anyway to use the general-purpose registers as a RAM replacement since they are mapped into the data memory region.</p>
<p>Bruce D. Lightner wrote an excellent description of how to do this, and offers this together with a toolkit on his web page:</p>
<p><a href="http://lightner.net/avr/ATtinyAvrGcc.html">http://lightner.net/avr/ATtinyAvrGcc.html</a></p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_AVRrc"></a>
What features are (not) supported on AVRrc Reduced Core devices?</h1>
<p>On the reduced AVRrc core with only 16 general purpose registers, the following features are not supported:</p>
<ul>
<li>The printf and scanf families of functions</li>
<li>Floating-point arithmetic</li>
<li>Fixed-point arithmetic (though 8-bit and 16-bit arithmetic should work with GCC v15+)</li>
<li>Arithmetic involving 64-bit computations</li>
<li>Named address-spaces like <code><a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a></code> </li>
</ul>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_clockskew"></a>
What is this "clock skew detected" message?</h1>
<p>It's a known problem of the MS-DOS FAT file system. Since the FAT file system has only a granularity of 2 seconds for maintaining a file's timestamp, and it seems that some MS-DOS derivative (Win9x) perhaps rounds up the current time to the next second when calculating the timestamp of an updated file in case the current time cannot be represented in FAT's terms, this causes a situation where <code>make</code> sees a "file coming from the future".</p>
<p>Since all make decisions are based on file timestamps, and their dependencies, make warns about this situation.</p>
<p>Solution: don't use inferior file systems / operating systems. Neither Unix file systems nor HPFS (aka NTFS) do experience that problem.</p>
<p>Workaround: after saving the file, wait a second before starting <code>make</code>. Or simply ignore the warning. If you are paranoid, execute a <code>make clean all</code> to make sure everything gets rebuilt.</p>
<p>In networked environments where the files are accessed from a file server, this message can also happen if the file server's clock differs too much from the network client's clock. In this case, the solution is to use a proper time keeping protocol on both systems, like NTP. As a workaround, synchronize the client's clock frequently with the server's clock.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_intbits"></a>
Why are (many) interrupt flags cleared by writing a logical 1?</h1>
<p>Usually, each interrupt has its own interrupt flag bit in some control register, indicating the specified interrupt condition has been met by representing a logical 1 in the respective bit position. When working with interrupt handlers, this interrupt flag bit usually gets cleared automatically in the course of processing the interrupt, sometimes by just calling the handler at all, sometimes (e. g. for the U[S]ART) by reading a particular hardware register that will normally happen anyway when processing the interrupt.</p>
<p>From the hardware's point of view, an interrupt is asserted as long as the respective bit is set, while global interrupts are enabled. Thus, it is essential to have the bit cleared before interrupts get re-enabled again (which usually happens when returning from an interrupt handler).</p>
<p>Only few subsystems require an explicit action to clear the interrupt request when using interrupt handlers. (The notable exception is the TWI interface, where clearing the interrupt indicates to proceed with the TWI bus hardware handshake, so it's never done automatically.)</p>
<p>However, if no normal interrupt handlers are to be used, or in order to make extra sure any pending interrupt gets cleared before re-activating global interrupts (e. g. an external edge-triggered one), it can be necessary to explicitly clear the respective hardware interrupt bit by software. This is usually done by writing a logical 1 into this bit position. This seems to be illogical at first, the bit position already carries a logical 1 when reading it, so why does writing a logical 1 to it <em>clear</em> the interrupt bit?</p>
<p>The solution is simple: writing a logical 1 to it requires only a single <code>OUT</code> instruction, and it is clear that only this single interrupt request bit will be cleared. There is no need to perform a read-modify-write cycle (like, an <code>SBI</code> instruction), since all bits in these control registers are interrupt bits, and writing a logical 0 to the remaining bits (as it is done by the simple <code>OUT</code> instruction) will not alter them, so there is no risk of any race condition that might accidentally clear another interrupt request bit. So instead of writing</p>
<div class="fragment"><div class="line">TIFR |= <a class="code hl_define" href="group__avr__sfr.html#ga11643f271076024c395a93800b3d9546">_BV</a>(TOV0); <span class="comment">/* wrong! */</span></div>
</div><!-- fragment --><p>simply use</p>
<div class="fragment"><div class="line">TIFR = <a class="code hl_define" href="group__avr__sfr.html#ga11643f271076024c395a93800b3d9546">_BV</a>(TOV0);</div>
</div><!-- fragment --><p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_cvt"></a>
How to use a Compact Vector Table?</h1>
<p>Some devices support a Compact Vector Table:</p>
<ul>
<li>Devices from the 0-series, 1-series, 2-series</li>
<li>AVR-Dx, AVR-Ex and AVR-SD devices</li>
</ul>
<p>A CVT consists of only four vectors: 0=Reset, 1=NMI, 2=Prio1 IRQ, 3=Prio0 IRQs. The easiest way is to link and compile with <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#index-mcvt"><code>-mcvt</code></a> which is supported since avr-gcc v15. This will link the <code>crt<em>mcu</em>-cvt.o</code> variant of the startup code that provides a CVT and activates it by setting the <code>CPUINT_CTRLA.CPUINT_CVT</code> bit. A C code will look something like: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__avr__interrupts.html#gad28590624d422cdf30d626e0a506255f">ISR</a> (__vector_2)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Code for Prio1 IRQ */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__avr__interrupts.html#ga48ae9a7647627e76a69f814510566d6c">ISR_N</a> (3)</div>
<div class="line">static <span class="keywordtype">void</span> prio0_isr (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Code for Prio0 IRQs */</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__interrupts_html_ga48ae9a7647627e76a69f814510566d6c"><div class="ttname"><a href="group__avr__interrupts.html#ga48ae9a7647627e76a69f814510566d6c">ISR_N</a></div><div class="ttdeci">#define ISR_N(vector_num, attributes)</div><div class="ttdef"><b>Definition:</b> interrupt.h:177</div></div>
<div class="ttc" id="ainterrupt_8h_html"><div class="ttname"><a href="interrupt_8h.html">interrupt.h</a></div></div>
</div><!-- fragment --><p>When you are using an older compiler but at least AVR-LibC v2.3, you can link with <code>-nostartfiles <em>path</em>/crt<em>mcu</em>-cvt.o</code> where:</p><ul>
<li><code><em>mcu</em></code> is the name of the device like <code>attiny202</code> for ATtiny202.</li>
<li><code><em>path</em></code> is of the form <code><em>prefix</em>/avr/lib/<em>mlib</em></code> where<ul>
<li><code><em>prefix</em></code> is the install path</li>
<li><code><em>mlib</em></code> is the multilib path that can be inferred with <code>$(avr-gcc -mmcu=<em>mcu</em> -print-multi-directory)</code> like <code>avrxmega3/short-calls</code> for <code>-mmcu=attiny202</code>.</li>
</ul>
</li>
</ul>
<dl>
<dt>Building <code>crt<em>mcu</em>-cvt.o</code> </dt>
<dd>When you are using AVR-LibC older than v2.3, then you can build <code>crt<em>mcu</em>-cvt.o</code> yourself from the current <a href="https://github.com/avrdudes/avr-libc/blob/main/crt1/gcrt1.S"><code>gcrt1.S</code></a> source with <code>-D USE_COMPACT_VECTOR_TABLE</code>, and you have to activate the CVT by hand (or you can implement <code>__init_cvt</code> as, say, a static constructor or as a naked function in section <code>.init3</code>).  </dd>
<dt>Downloading <code>crt<em>mcu</em>-cvt.o</code> </dt>
<dd><p class="startdd">An alternative to building <code>crt<em>mcu</em>-cvt.o</code> yourself is to download a pre-built toolchain like avr-gcc-15.1 from the <a href="https://sourceforge.net/projects/winavr/files/avr-gcc">WinAVR repo</a>. Notice that you can use that tarball on any operating system since you are only going to use target-specific files. Unpack the downloaded archive as explained there to some folder <code><em>prefix</em></code> on your machine.</p>
<p class="enddd">Then link with <code>-nostartfiles <em>path</em>/crt<em>mcu</em>-cvt.o -L <em>path</em></code> where <code><em>path</em></code> is like above. The &quot;-L <code><em>path</em></code>&quot; is needed so that <code>lib<em>mcu</em>.a</code> from the downloaded toolchain is used. It contains parts of the startup code like <code>__init_cvt</code> and <code>__call_main</code>.  </p>
</dd>
</dl>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_local_isr"></a>
How to use a local (static, namespace) function as ISR?</h1>
<p>In order to use a non-global function as an ISR, there is <a class="el" href="group__avr__interrupts.html#ga48ae9a7647627e76a69f814510566d6c">ISR_N</a> from <code><a class="el" href="interrupt_8h.html">avr/interrupt.h</a></code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__avr__interrupts.html#ga48ae9a7647627e76a69f814510566d6c">ISR_N</a> (INT0_vect_num)</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> int0_isr ()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Code</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace</span></div>
<div class="line">{</div>
<div class="line">    <a class="code hl_define" href="group__avr__interrupts.html#ga48ae9a7647627e76a69f814510566d6c">ISR_N</a> (ADC_vect_num)</div>
<div class="line">    <span class="keywordtype">void</span> adc0_isr ()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Code</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="el" href="group__avr__interrupts.html#ga48ae9a7647627e76a69f814510566d6c">ISR_N</a> was added in AVR-LibC v2.3. It uses the <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Function-Attributes.html#index-signal_0028num_0029-function-attribute_002c-AVR"><code>signal(N)</code></a> function attribute added in <a href="https://gcc.gnu.org/gcc-15/changes.html#avr">GCC v15</a>.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_fuselow"></a>
Why have "programmed" fuses the bit value 0?</h1>
<p>Basically, fuses are just a bit in a special EEPROM area. For technical reasons, erased E[E]PROM cells have all bits set to the value 1, so unprogrammed fuses also have a logical 1. Conversely, programmed fuse cells read out as bit value 0.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_asmops"></a>
Which AVR-specific assembler operators are available?</h1>
<p>See <a class="el" href="assembler.html#ass_pseudoops">Pseudo-Ops</a> and <a class="el" href="inline_asm.html#assembly_operand_modifiers">Operand Modifiers</a>.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_call_asm_from_c"></a>
How to call an assembly function from C/C++?</h1>
<p>Just declare the function like you would in C/C++: </p><div class="fragment"><div class="line"><span class="keyword">extern</span>     <a class="code hl_typedef" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> asm_add (<a class="code hl_typedef" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> a, <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> b); <span class="comment">// in C</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <a class="code hl_typedef" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> asm_add (<a class="code hl_typedef" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> a, <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> b); <span class="comment">// in C++</span></div>
</div><!-- fragment --><p>and then call it like any ordinary C/C++ function: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> use_asm_func (<a class="code hl_typedef" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> a)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> asm_add (a, 42);</div>
<div class="line">}</div>
</div><!-- fragment --><p>An example implementation of an assembly function that returns <em>a</em> + <em>b</em> would read something like: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef __AVR_TINY__</span></div>
<div class="line"><span class="preprocessor">#define zero_reg r17</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#define zero_reg r1</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">.text</div>
<div class="line"><span class="comment">/* According to the AVR GCC ABI:</span></div>
<div class="line"><span class="comment">   - Param a is passed in R25:R24.</span></div>
<div class="line"><span class="comment">   - Param b is passed in R22.</span></div>
<div class="line"><span class="comment">   - Return value is in R25:R24.</span></div>
<div class="line"><span class="comment">   - zero_reg always contains a value of zero.  */</span></div>
<div class="line">.global asm_add</div>
<div class="line">.type asm_add, @function</div>
<div class="line">asm_add:</div>
<div class="line">    add r24, r22</div>
<div class="line">    adc r24, zero_reg</div>
<div class="line">    ret</div>
<div class="line">.size asm_add, . - asm_add</div>
</div><!-- fragment --><p>Notice that the assembly function complies to the <a href="https://gcc.gnu.org/wiki/avr-gcc#Calling_Convention">avr-gcc calling convention</a>.</p>
<p>See also</p><ul>
<li><a class="el" href="FAQ.html#faq_reg_usage">What registers are used by the compiler?</a></li>
<li><a class="el" href="FAQ.html#faq_nonabi">How can I use a function that doesn't comply to the ABI?</a></li>
</ul>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_call_c_from_asm"></a>
How to call a C/C++ function from assembly?</h1>
<p>The actual call is simple: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef __AVR_HAVE_JMP_CALL__</span></div>
<div class="line"><span class="preprocessor">#define XCALL call</span></div>
<div class="line"><span class="preprocessor">#define XJMP  jmp</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#define XCALL rcall</span></div>
<div class="line"><span class="preprocessor">#define XJMP  rjmp</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">.text</div>
<div class="line">   ...</div>
<div class="line">   XCALL c_func  <span class="comment">/* Ordinary call */</span></div>
<div class="line">   ...</div>
<div class="line">   XJMP c_func   <span class="comment">/* Tail-call */</span></div>
</div><!-- fragment --><p>Since <code>__AVR_HAVE_JMP_CALL__</code> is a macro built-in defined by the C preprocessor, you have to <a class="el" href="assembler.html#ass_tools">invoke the assembler</a> by means of the avr-gcc driver program. On the C/C++ side, you have to make sure that the <code>c_func</code> function is actually present:</p>
<ul>
<li>In C/C++, <code>c_func</code> must be declared as <code>extern</code>.</li>
<li>C++ will provide the mangled name like <code>_Z4funci</code> for <code>int c_func(int)</code>. When you want a plain <code>c_func</code> symbol, then define the function as <code>extern "C"</code>.</li>
<li>Make sure that the function is not optimized away: When you are using global optimizations, then function attributes like <code>externally_visible</code> and <code>used</code> may be needed.</li>
</ul>
<p>The passed arguments and the return value must comply to the <a href="https://gcc.gnu.org/wiki/avr-gcc#Calling_Convention">avr-gcc ABI</a>, see also <a class="el" href="FAQ.html#faq_reg_usage">What registers are used by the compiler?</a> In particular C/C++ functions expect that register R1 (on AVRrc: R17) contains the value 0.</p>
<p>When calling a function in <a href="https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=libgcc/config/avr/lib1funcs.S">libgcc</a>, GCC's runtime support library, then you'll have to check which calling convention is actually in use. These function are implemented in assembly, and some of them don't use the C/C++ calling convention. An example is the 32 = 16 &times; 16 multiplication routine <a href="https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=libgcc/config/avr/lib1funcs.S;h=dfe99b1ea06f5b45e0a19942c42fe92f46e497ac;hb=HEAD#l547"><code>__umulhisi3</code></a>. For an (incomplete) list, see the <a href="https://gcc.gnu.org/wiki/avr-gcc#Exceptions_to_the_Calling_Convention">avr-gcc Wiki</a>.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_nonabi"></a>
How can I use a function that doesn't comply to the ABI?</h1>
<p>Suppose you have a function <code>f_nonabi</code> written in assembly that doesn't comply to the <a class="el" href="FAQ.html#faq_reg_usage">avr-gcc ABI</a>. How can such a function be used from C/C++?</p>
<p>For the matter of the discussion, suppose that the function <code>f_nonabi</code> </p>
<ul>
<li>Takes a 16-bit integer value in R31:R30</li>
<li>Returns a 16-bit integer value in R23:R22</li>
<li>Clobbers R1 and R2</li>
<li>Changes memory contents</li>
</ul>
<p>There are basically two approaches: Write an interface function in assembly, or write an interface in inline assembly.</p>
<h2><a class="anchor" id="faq_nonabi_asm"></a>
Interface in Assembly</h2>
<p>The iterface function would look something like this, assuming that the AVR device supports the <code>MOVW</code> and <code>CALL</code> instructions:</p>
<div class="fragment"><div class="line">.global call_f_nonabi</div>
<div class="line">.type call_f_nonabi,&quot;function&quot;</div>
<div class="line">call_f_nonabi:</div>
<div class="line">    push r2         ; ABI: R2 is callee-saved</div>
<div class="line">    movw r30, r24   ; ABI: int is passed in R25:R24</div>
<div class="line">    call f_nonabi</div>
<div class="line">    movw r24, r22   ; ABI: Return result in R25:R24</div>
<div class="line">    clr r1          ; ABI: R1 (__zero_reg__) must hold 0.</div>
<div class="line">    pop r2          ; ABI: R2 is callee-saved</div>
<div class="line">    ret</div>
</div><!-- fragment --><p>Then provide C/C++ with an interface to <code>call_f_nonabi:</code> </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span>     <span class="keywordtype">int</span> call_f_nonabi (<span class="keywordtype">int</span>);  <span class="comment">// C</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">int</span> call_f_nonabi (<span class="keywordtype">int</span>);  <span class="comment">// C++</span></div>
</div><!-- fragment --><h2><a class="anchor" id="faq_nonabi_inline_asm"></a>
Interface in Inline Assembly</h2>
<p>GCC supports <a href="ttps://gcc.gnu.org/onlinedocs/gcc/Local-Register-Variables.html">local register variables</a> as a GNU extension: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __attribute__((__always_inline__))</div>
<div class="line"><span class="keywordtype">int</span> call_f_nonabi (<span class="keywordtype">int</span> arg)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">register</span> <span class="keywordtype">int</span> r22 __asm(<span class="stringliteral">&quot;r22&quot;</span>);</div>
<div class="line">    __asm <span class="keyword">volatile</span> (<span class="stringliteral">&quot;%~call f_nonabi&quot;</span>   <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">                    <span class="stringliteral">&quot;clr __zero_reg__&quot;</span></div>
<div class="line">                    : <span class="stringliteral">&quot;=r&quot;</span> (r22) : <span class="stringliteral">&quot;z&quot;</span> (arg) : <span class="stringliteral">&quot;r2&quot;</span>, <span class="stringliteral">&quot;memory&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> r22;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Notes:</p><ul>
<li>Whether or not <code>volatile</code> and the <code>"memory"</code> clobber are needed depend on what <code>f_nonabi</code> actually does.</li>
<li>There's no need for a local register variable for <code>num</code> since the <code>"z"</code> <a class="el" href="inline_asm.html#inline_asm_constraints">constraint</a> is R30 and R31.</li>
<li>R1 is a fixed register, and therefore clobbering it has no effect. The value of 0 in R1 has to be restored by hand.</li>
<li>For the meaning of <code>"%~call"</code> see <a class="el" href="inline_asm.html#inline_asm_special_sequences">inline asm special sequences</a>.</li>
<li>GCC v16 introduces <a href="https://gcc.gnu.org/onlinedocs/gcc/Hard-Register-Constraints.html">hard-register constraints</a> as an alternative to local register variables. Using that feature, the function would look like this: <div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __attribute__((__always_inline__))</div>
<div class="line"><span class="keywordtype">int</span> call_f_nonabi (<span class="keywordtype">int</span> arg)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> ret;</div>
<div class="line">    __asm <span class="keyword">volatile</span> (<span class="stringliteral">&quot;%~call f_nonabi&quot;</span>   <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">                    <span class="stringliteral">&quot;clr __zero_reg__&quot;</span></div>
<div class="line">                    : <span class="stringliteral">&quot;={r22}&quot;</span> (ret) : <span class="stringliteral">&quot;z&quot;</span> (arg) : <span class="stringliteral">&quot;r2&quot;</span>, <span class="stringliteral">&quot;memory&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_spman"></a>
Why are interrupts re-enabled in the middle of writing the stack pointer?</h1>
<p>When setting up space for local variables on the stack, the compiler generates code like this:</p>
<pre class="fragment">/* prologue: frame size=20 */
	push r28
	push r29
	in r28,__SP_L__
	in r29,__SP_H__
	sbiw r28,20
	in __tmp_reg__,__SREG__
	cli
	out __SP_H__,r29
	out __SREG__,__tmp_reg__
	out __SP_L__,r28
/* prologue end (size=10) */
</pre><p>It reads the current stack pointer value, decrements it by the required amount of bytes, then disables interrupts, writes back the high part of the stack pointer, writes back the saved <code>SREG</code> (which will eventually re-enable interrupts if they have been enabled before), and finally writes the low part of the stack pointer.</p>
<p>At the first glance, there's a race between restoring <code>SREG</code>, and writing <code>SPL</code>. However, after enabling interrupts (either explicitly by setting the <code>I</code> flag, or by restoring it as part of the entire <code>SREG</code>), the AVR hardware executes (at least) the next instruction still with interrupts disabled, so the write to <code>SPL</code> is guaranteed to be executed with interrupts disabled still. Thus, the emitted sequence ensures interrupts will be disabled only for the minimum time required to guarantee the integrity of this operation.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_linkerscripts"></a>
Why are there five different linker scripts?</h1>
<p>From a comment in the source code:</p>
<p>Which one of the five linker script files is actually used depends on command line options given to ld.</p>
<p>A .x script file is the default script A .xr script is for linking without relocation (-r flag) A .xu script is like .xr but *do* create constructors (-Ur flag) A .xn script is for linking with -n flag (mix text and data on same page). A .xbn script is for linking with -N flag (mix text and data on same page).</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_binarydata"></a>
How to add a raw binary image to linker output?</h1>
<h2><a class="anchor" id="faq_binarydata_embed"></a>
Using #embed</h2>
<p>Before answering this question, lets mention the <code>#embed</code> directive introduced in C23. While <code>#embed</code> doesn't strictly conform to the requirement of the question, it is so much more convenient that you still may want to use it. <code>#embed</code> embeds the contents of a file into a compilation unit. Here is an example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdio_8h.html">stdio.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> abba_txt[] <a class="code hl_define" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> =</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#embed &quot;abba.txt&quot;</span></div>
<div class="line">    <span class="comment">// Append \0 so that abba_txt becomes a proper C string</span></div>
<div class="line">    <span class="comment">// (assuming abba.txt is a text file).</span></div>
<div class="line">    , <span class="charliteral">&#39;\0&#39;</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="group__avr__stdio.html#ga4c04da4953607fa5fa4d3908fecde449">printf</a> (<span class="stringliteral">&quot;== abba.txt has %d bytes ==\n%S\n&quot;</span>,</div>
<div class="line">            (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span> (abba_txt) - 1, abba_txt);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__stdio_html_ga4c04da4953607fa5fa4d3908fecde449"><div class="ttname"><a href="group__avr__stdio.html#ga4c04da4953607fa5fa4d3908fecde449">printf</a></div><div class="ttdeci">int printf(const char *__fmt,...)</div><div class="ttdef"><b>Definition:</b> printf.c:35</div></div>
<div class="ttc" id="astdio_8h_html"><div class="ttname"><a href="stdio_8h.html">stdio.h</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="faq_binarydata_incbin"></a>
Using .incbin</h2>
<p>The GNU assembler supports the <a href="https://sourceware.org/binutils/docs/as/Incbin.html"><code>.incbin</code></a> directive, which includes the content of a file verbatim as if it was specified by <code>.byte</code> directives: </p><div class="fragment"><div class="line">.macro ARRAY_START name</div>
<div class="line">    .pushsection .progmem.data.\name,<span class="stringliteral">&quot;a&quot;</span>,<span class="stringliteral">&quot;progbits&quot;</span></div>
<div class="line">    .global \name</div>
<div class="line">    .type \name,<span class="stringliteral">&quot;object&quot;</span></div>
<div class="line">    \name:</div>
<div class="line">.endm</div>
<div class="line"> </div>
<div class="line">.macro ARRAY_END name</div>
<div class="line">    .global \name\&zwj;()_size</div>
<div class="line">    \name\()_size = . - \name</div>
<div class="line">    .size \name, . - \name</div>
<div class="line">    .popsection</div>
<div class="line">.endm</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Defines abba_txt[] from the bytes of abba.txt. */</span></div>
<div class="line">ARRAY_START abba_txt</div>
<div class="line">    .incbin <span class="stringliteral">&quot;abba.txt&quot;</span></div>
<div class="line">    <span class="comment">/* Append a \0 to the array. */</span></div>
<div class="line">    .byte 0</div>
<div class="line">ARRAY_END abba_txt</div>
</div><!-- fragment --><p>The code defines the assembly macros <code>ARRAY_START</code> and <code>ARRAY_END</code> for convenience. They define the array and a symbol for the array size. A C header file provides the symbols to a C program:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ABBA_H</span></div>
<div class="line"><span class="preprocessor">#define ABBA_H</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">char</span> abba_txt[];</div>
<div class="line"><span class="comment">// Notice that abba_txt_size is just a symbol</span></div>
<div class="line"><span class="comment">// that doesn&#39;t occupy memory.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">char</span> abba_txt_size[];</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* ABBA_H */</span><span class="preprocessor"></span></div>
</div><!-- fragment --><p>This header is then included in order to use the data:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdio_8h.html">stdio.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdint_8h.html">stdint.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;abba.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="group__avr__stdio.html#ga4c04da4953607fa5fa4d3908fecde449">printf</a> (<span class="stringliteral">&quot;start: 0x%x\n&quot;</span>, (<a class="code hl_typedef" href="group__avr__stdint.html#ga2c8c1b9f53772a86b0827ce7399b68aa">uintptr_t</a>) abba_txt);</div>
<div class="line">    <a class="code hl_function" href="group__avr__stdio.html#ga4c04da4953607fa5fa4d3908fecde449">printf</a> (<span class="stringliteral">&quot;size:  %u\n&quot;</span>, (<a class="code hl_typedef" href="group__avr__stdint.html#ga2c8c1b9f53772a86b0827ce7399b68aa">uintptr_t</a>) abba_txt_size);</div>
<div class="line">    <a class="code hl_function" href="group__avr__stdio.html#ga4c04da4953607fa5fa4d3908fecde449">printf</a> (<span class="stringliteral">&quot;array: \&quot;%S\&quot;\n&quot;</span>, abba_txt);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__stdint_html_ga2c8c1b9f53772a86b0827ce7399b68aa"><div class="ttname"><a href="group__avr__stdint.html#ga2c8c1b9f53772a86b0827ce7399b68aa">uintptr_t</a></div><div class="ttdeci">uint16_t uintptr_t</div><div class="ttdef"><b>Definition:</b> stdint.h:183</div></div>
</div><!-- fragment --><p>The simplest way to assemble the assembly module is by letting avr-gcc do the work: </p><pre class="fragment">$ avr-gcc -x assembler-with-cpp abba.asm -x none -o abba.o -mmcu=...
</pre><p> The <code>"-x assembler-with-cpp"</code> and <code>"-x none"</code> are only needed when the file extension of the assembly file is neither <code>.S</code> nor <code>.sx</code>. In such cases, avr-gcc must be provided with the <a class="el" href="using_tools.html#opt_x">input language</a>.</p>
<h2><a class="anchor" id="faq_binarydata_objcopy"></a>
Using objcopy</h2>
<p>The GNU linker <code>avr-ld</code> cannot handle binary data directly. However, there's a companion tool called <a href="https://sourceware.org/binutils/docs/binutils/objcopy.html"><code>avr-objcopy</code></a>. This is already known from the output side: it's used to extract the contents of the linked ELF file into an Intel Hex load file.</p>
<p><code>avr-objcopy</code> can create a relocatable object file from arbitrary binary input, like</p>
<pre class="fragment">$ avr-objcopy -I binary -O elf32-avr foo.bin foo.o
</pre><p>This will create a file named <code>foo.o</code> with the contents of <code>foo.bin</code>. The contents will default to section .data, and two symbols will be created named <code>_binary_foo_bin_start</code> and <code>_binary_foo_bin_end</code>. These symbols can be referred to inside a C source to access these data.</p>
<p>If the goal is to have those data go to flash ROM (similar to having used the PROGMEM attribute in C source code), the sections have to be renamed while copying, and it's also useful to set the section flags:</p>
<pre class="fragment">$ avr-objcopy --rename-section .data=.progmem.data,contents,alloc,load,readonly,data -I binary -O elf32-avr foo.bin foo.o
</pre><p>Note that all this could be conveniently wired into a Makefile, so whenever <code>foo.bin</code> changes, it will trigger the recreation of <code>foo.o</code>, and a subsequent relink of the final ELF file.</p>
<p>Below are two Makefile fragments that provide rules to convert a .txt file to an object file, and to convert a .bin file to an object file:</p>
<pre class="fragment">$(OBJDIR)/%.o : %.txt
	@echo Converting $&lt;
	@cp $(&lt;) $(*).tmp
	@echo -n 0 | tr 0 '\000' &gt;&gt; $(*).tmp
	@$(OBJCOPY) -I binary -O elf32-avr \
	--rename-section .data=.progmem.data,contents,alloc,load,readonly,data \
	--redefine-sym _binary_$*_tmp_start=$* \
	--redefine-sym _binary_$*_tmp_end=$*_end \
	--redefine-sym _binary_$*_tmp_size=$*_size_sym \
	$(*).tmp $(@)
	@echo "extern const char" $(*)"[] PROGMEM;" &gt; $(*).h
	@echo "extern const char" $(*)_end"[] PROGMEM;" &gt;&gt; $(*).h
	@echo "extern const char" $(*)_size_sym"[];" &gt;&gt; $(*).h
	@echo "#define $(*)_size ((int)$(*)_size_sym)" &gt;&gt; $(*).h
	@rm $(*).tmp

$(OBJDIR)/%.o : %.bin
	@echo Converting $&lt;
	@$(OBJCOPY) -I binary -O elf32-avr \
	--rename-section .data=.progmem.data,contents,alloc,load,readonly,data \
	--redefine-sym _binary_$*_bin_start=$* \
	--redefine-sym _binary_$*_bin_end=$*_end \
	--redefine-sym _binary_$*_bin_size=$*_size_sym \
	$(&lt;) $(@)
	@echo "extern const char" $(*)"[] PROGMEM;" &gt; $(*).h
	@echo "extern const char" $(*)_end"[] PROGMEM;" &gt;&gt; $(*).h
	@echo "extern const char" $(*)_size_sym"[];" &gt;&gt; $(*).h
	@echo "#define $(*)_size ((int)$(*)_size_sym)" &gt;&gt; $(*).h
</pre><p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_softreset"></a>
How do I perform a software reset of the AVR?</h1>
<p>The canonical way to perform a software reset of non-XMega AVR's is to use the watchdog timer. Enable the watchdog timer to the shortest timeout setting, then go into an infinite, do-nothing loop. The watchdog will then reset the processor.</p>
<p>XMega parts have a specific bit <code>RST_SWRST_bm</code> in the <code>RST.CTRL</code> register, that generates a hardware reset. RST_SWRST_bm is protected by the XMega Configuration Change Protection system.</p>
<p>The reason why using the watchdog timer or <code>RST_SWRST_bm</code> is preferable over jumping to the reset vector, is that when the watchdog or <code>RST_SWRST_bm</code> resets the AVR, the registers will be reset to their known, default settings. Whereas jumping to the reset vector will leave the registers in their previous state, which is generally not a good idea.</p>
<dl>
<dt>CAUTION! </dt>
<dd>Older AVRs will have the watchdog timer disabled on a reset. For these older AVRs, doing a soft reset by enabling the watchdog is easy, as the watchdog will then be disabled after the reset. On newer AVRs, once the watchdog is enabled, then it <b>stays enabled, even after a reset</b>! For these newer AVRs a function needs to be added to the <code>.init3</code> section (i.e. during the startup code, before main()) to disable the watchdog early enough so it does not continually reset the AVR.  </dd>
</dl>
<p>Here is some example code that creates a macro that can be called to perform a soft reset:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="wdt_8h.html">avr/wdt.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __attribute__((__always_inline__))</div>
<div class="line"><span class="keywordtype">void</span> soft_reset (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_define" href="group__avr__watchdog.html#ga9d1aeb2823c79936e980fabba10ac75e">wdt_enable</a> (<a class="code hl_define" href="group__avr__watchdog.html#gad45893280f49113ffc2e67e1d741f29d">WDTO_15MS</a>);</div>
<div class="line">    <span class="keywordflow">for</span>(;;) {}</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__watchdog_html_ga9d1aeb2823c79936e980fabba10ac75e"><div class="ttname"><a href="group__avr__watchdog.html#ga9d1aeb2823c79936e980fabba10ac75e">wdt_enable</a></div><div class="ttdeci">#define wdt_enable(timeout)</div><div class="ttdef"><b>Definition:</b> wdt.h:131</div></div>
<div class="ttc" id="agroup__avr__watchdog_html_gad45893280f49113ffc2e67e1d741f29d"><div class="ttname"><a href="group__avr__watchdog.html#gad45893280f49113ffc2e67e1d741f29d">WDTO_15MS</a></div><div class="ttdeci">#define WDTO_15MS</div><div class="ttdef"><b>Definition:</b> wdt.h:552</div></div>
<div class="ttc" id="awdt_8h_html"><div class="ttname"><a href="wdt_8h.html">wdt.h</a></div></div>
</div><!-- fragment --><p>For newer AVRs (such as the ATmega1281) also add this function to your code to then disable the watchdog after a reset (e.g., after a soft reset):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="wdt_8h.html">avr/wdt.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Function Pototype</span></div>
<div class="line"><span class="keyword">static</span>  __attribute__((used, unused, naked, section(<span class="stringliteral">&quot;.init3&quot;</span>)))</div>
<div class="line">void wdt_init (<span class="keywordtype">void</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Function Implementation</span></div>
<div class="line"><span class="keywordtype">void</span> wdt_init (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    MCUSR = 0;</div>
<div class="line">    <a class="code hl_function" href="group__avr__watchdog.html#ga4bf8d96fb29e5735ae2a560e7b8cfd15">wdt_disable</a>();</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__watchdog_html_ga4bf8d96fb29e5735ae2a560e7b8cfd15"><div class="ttname"><a href="group__avr__watchdog.html#ga4bf8d96fb29e5735ae2a560e7b8cfd15">wdt_disable</a></div><div class="ttdeci">static void wdt_disable(void)</div><div class="ttdef"><b>Definition:</b> wdt.h:483</div></div>
</div><!-- fragment --><p> The code is placed in section <code><a class="el" href="mem_sections.html#sec_dot_init">.init3</a></code> so that it is executed as part of the normal startup procedure. The <code>naked</code> attribute is required so that the code does not <code>ret</code>urn (Code in init sections is executed as it is located; the code is not called, and code from one init section falls through to the code in the next one). The <code>used</code> attribute makes sure that the compiler does not throw the seemingly unused function away. The <code>unused</code> attributes avoids warnings about unused code.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_reentrant"></a>
What pitfalls exist when writing reentrant code?</h1>
<p>Reentrant code means the ability for a piece of code to be called simultaneously from two or more threads. Attention to re-enterability is needed when using a multi-tasking operating system, or when using interrupts since an interrupt is really a temporary thread.</p>
<p>The code generated natively by gcc is reentrant. But, only some of the libraries in AVR-LibC are explicitly reentrant, and some are known not to be reentrant. In general, any library call that reads and writes global variables (including I/O registers) is not reentrant. This is because more than one thread could read or write the same storage at the same time, unaware that other threads are doing the same, and create inconsistent and/or erroneous results.</p>
<p>A library call that is known not to be reentrant will work if it is used only within one thread <em>and</em> no other thread makes use of a library call that shares common storage with it.</p>
<p>Below is a table of library calls with known issues.</p>
<table class="doxtable">
<tr>
<th>Library Call </th><th>Reentrant Issue </th><th>Workaround / Alternative  </th></tr>
<tr>
<td><code><a class="el" href="group__avr__stdlib.html#gae23144bcbb8e3742b00eb687c36654d1">rand</a></code>, <code><a class="el" href="group__avr__stdlib.html#ga114aeb1751119382aaf3340355b22cfd">random</a></code> </td><td>Uses global variables to keep state information. </td><td>Use special reentrant versions: <a class="el" href="group__avr__stdlib.html#gaf5085001be836a0f2a5d3269a7c9fd04">rand_r</a>, <a class="el" href="group__avr__stdlib.html#gaa99a0733f06d2b9960a1401c2721af1e">random_r</a>.  </td></tr>
<tr>
<td><code><a class="el" href="group__avr__stdlib.html#ga699a1d102f9ea32765752559f978a590">strtof</a></code>, <code><a class="el" href="group__avr__stdlib.html#ga5ee4d110a3bb55d2eadda05e3ebedf8a">strtod</a></code>, <code><a class="el" href="group__avr__stdlib.html#gaf8ce3b8dae3d45c34c3b172de503f7b3">strtol</a></code>, <code><a class="el" href="group__avr__stdlib.html#gaea44aa48bda8261f794dcb2d1e7ab2b2">strtoul</a></code> </td><td>Uses the global variable <code>errno</code> to return success/failure. </td><td>Ignore <code>errno</code>, or protect calls with <a class="el" href="group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162">cli</a>/<a class="el" href="group__avr__interrupts.html#gaad5ebd34cb344c26ac87594f79b06b73">sei</a> or <a class="el" href="group__util__atomic.html#gaaaea265b31dabcfb3098bec7685c39e4">ATOMIC_BLOCK</a> if the application can tolerate it. Or use <a class="el" href="group__avr__stdio.html#ga3f0edc16dcabb5344d59d42cf7682102">scanf</a> or <a class="el" href="group__avr__stdio.html#ga0fb7fd70cd7618f27d8219c97e61bcf3">scanf_P</a> if possible.   </td></tr>
<tr>
<td><code><a class="el" href="group__avr__stdlib.html#a_malloc">malloc</a></code>, <code><a class="el" href="group__avr__stdlib.html#a_realloc">realloc</a></code>, <code><a class="el" href="group__avr__stdlib.html#ga62994ba3ce84fed8a5481ab68e71a963">calloc</a></code>, <code>free</code> </td><td>Uses the stack pointer and global variables to allocate and free memory. </td><td>Protect calls with <a class="el" href="group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162">cli</a>/<a class="el" href="group__avr__interrupts.html#gaad5ebd34cb344c26ac87594f79b06b73">sei</a> or <a class="el" href="group__util__atomic.html#gaaaea265b31dabcfb3098bec7685c39e4">ATOMIC_BLOCK</a> if the application can tolerate it. If using an OS, use the OS provided memory allocator since the OS is likely modifying the stack pointer anyway.   </td></tr>
<tr>
<td><code><a class="el" href="group__avr__stdio.html#ga4d3cf48473f17420f1960a1b27f54d00">fdevopen</a></code>, <code><a class="el" href="group__avr__stdio.html#gad3d27a6dcc225237171196dd0739bb10">fclose</a></code> </td><td>Uses <a class="el" href="group__avr__stdlib.html#ga62994ba3ce84fed8a5481ab68e71a963">calloc</a> and free. </td><td>Protect calls with <a class="el" href="group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162">cli</a>/<a class="el" href="group__avr__interrupts.html#gaad5ebd34cb344c26ac87594f79b06b73">sei</a> or <a class="el" href="group__util__atomic.html#gaaaea265b31dabcfb3098bec7685c39e4">ATOMIC_BLOCK</a> if the application can tolerate it. Or use <a class="el" href="group__avr__stdio.html#gaf41f158c022cbb6203ccd87d27301226" title="Setup a user-supplied buffer as an stdio stream.">fdev_setup_stream</a> or <a class="el" href="group__avr__stdio.html#gaea2b6be92ead4673bc487b271b7227fb" title="Initializer for a user-supplied stdio stream.">FDEV_SETUP_STREAM</a>. <br  />
 Note: <a class="el" href="group__avr__stdio.html#gad3d27a6dcc225237171196dd0739bb10">fclose</a> will only call free if the stream has been opened with <a class="el" href="group__avr__stdio.html#ga4d3cf48473f17420f1960a1b27f54d00">fdevopen</a>.   </td></tr>
<tr>
<td><code><a class="el" href="group__avr__eeprom.html">eeprom_*</a></code>, <code><a class="el" href="group__avr__boot.html">boot_*</a></code> </td><td>Accesses I/O registers. </td><td>Protect calls with <a class="el" href="group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162">cli</a>/<a class="el" href="group__avr__interrupts.html#gaad5ebd34cb344c26ac87594f79b06b73">sei</a>, <a class="el" href="group__util__atomic.html#gaaaea265b31dabcfb3098bec7685c39e4">ATOMIC_BLOCK</a>, or use OS locking.  </td></tr>
<tr>
<td><code><a class="el" href="group__avr__pgmspace.html">pgm_*_far</a></code> </td><td>Accesses I/O register RAMPZ. </td><td>Starting with GCC 4.3, RAMPZ is automatically saved for <a class="el" href="group__avr__interrupts.html#gad28590624d422cdf30d626e0a506255f">ISRs</a>, so nothing further is needed if only using interrupts. <br  />
Some OSes may automatically preserve RAMPZ during context switching. Check the OS documentation before assuming it does. <br  />
Otherwise, protect calls with <a class="el" href="group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162">cli</a>/<a class="el" href="group__avr__interrupts.html#gaad5ebd34cb344c26ac87594f79b06b73">sei</a>, <a class="el" href="group__util__atomic.html#gaaaea265b31dabcfb3098bec7685c39e4">ATOMIC_BLOCK</a>, or use explicit OS locking.   </td></tr>
<tr>
<td><code><a class="el" href="group__avr__stdio.html#ga4c04da4953607fa5fa4d3908fecde449">printf</a></code>, <code><a class="el" href="group__avr__stdio.html#ga418e63921ed6259e873cd21b6c5c8e6e">printf_P</a></code>, <code><a class="el" href="group__avr__stdio.html#ga0b15be24dd9db93355e1f62937fdfd9a">vprintf</a></code>, <code><a class="el" href="group__avr__stdio.html#ga33f7bd99d40bf6f68a00d5507d65363d">puts</a></code>, <code><a class="el" href="group__avr__stdio.html#gab4de83c560c79bf880fa39b997d61610">puts_P</a></code> </td><td>Alters flags and character count in global FILE <code>stdout</code>. </td><td>Use only in one thread. Or if returned character count is unimportant, do not use the *_P versions. <br  />
Note: Formatting to a string output, e.g. <a class="el" href="group__avr__stdio.html#ga6017094d9fd800fa02600d35399f2a2a">sprintf</a>, <a class="el" href="group__avr__stdio.html#ga2b829d696b17dedbf181cd5dc4d7a31d">sprintf_P</a>, <a class="el" href="group__avr__stdio.html#ga77070c245d4ca4f7ec7d7144260fb875">snprintf</a>, <a class="el" href="group__avr__stdio.html#ga53ff61856759709eeceae10aaa10a0a3">snprintf_P</a>, <a class="el" href="group__avr__stdio.html#ga129a84920638c8e538e80fdeb6d69a6f">vsprintf</a>, <a class="el" href="group__avr__stdio.html#gab5cb9ba918b3c3f80399e1164a8b28d2">vsprintf_P</a>, <a class="el" href="group__avr__stdio.html#ga1797e15713c635606cbaf6ba56e98fe5">vsnprintf</a>, <a class="el" href="group__avr__stdio.html#gac0902d91baba413dedb08474f2ae4383">vsnprintf_P</a>, is thread safe. The formatted string could then be followed by an <a class="el" href="group__avr__stdio.html#gadd5777719a41713629a62b68c239a774">fwrite</a> which simply calls the lower layer to send the string.   </td></tr>
<tr>
<td><code><a class="el" href="group__avr__stdio.html#ga0e41285401c397eb29692205a95fcd9c">fprintf</a></code>, <code><a class="el" href="group__avr__stdio.html#ga36173b4a8551b61811089198beec69d9">fprintf_P</a></code>, <code><a class="el" href="group__avr__stdio.html#gaa3b98c0d17b35642c0f3e4649092b9f1">vfprintf</a></code>, <code><a class="el" href="group__avr__stdio.html#ga55b25ecbfd3811ea4495d1f235e2e186">vfprintf_P</a></code>, <code><a class="el" href="group__avr__stdio.html#ga19c2bbe9ce4af9f0a7e3448387004fd3">fputs</a></code>, <code><a class="el" href="group__avr__stdio.html#ga3d25813cb225ca410518a3f48eb00caa">fputs_P</a></code> </td><td>Alters flags and character count in the FILE argument. Problems can occur if a global FILE is used from multiple threads.  </td><td>Assign each thread its own FILE for output. Or if returned character count is unimportant, do not use the *_P versions.   </td></tr>
<tr>
<td><code><a class="el" href="group__avr__stdio.html#gaaa6d255675688c736c99ebd32f2a7214">clearerr</a></code> </td><td>Alters flags in the FILE argument.  </td><td><p class="starttd">Assign each thread its own FILE for output.  </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code><a class="el" href="group__avr__stdio.html#gac0484b3e3a4d8361d91c3322440f9195">getchar</a></code>, <code><a class="el" href="group__avr__stdio.html#ga69ba61d3700de71575c9f7d21b70d582">gets</a></code> </td><td>Alters flags, character count, and unget buffer in global FILE <code>stdin</code>. </td><td><p class="starttd">Use only in one thread. *** </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code><a class="el" href="group__avr__stdio.html#ga818d63019adc9d518a13f9c36ed04f35">fgetc</a></code>, <code><a class="el" href="group__avr__stdio.html#gab4f9b130166e5811519513d6178c1ae3">ungetc</a></code>, <code><a class="el" href="group__avr__stdio.html#gadc840142f71fe24306b4c249d0c749bf">fgets</a></code>, <code><a class="el" href="group__avr__stdio.html#ga3f0edc16dcabb5344d59d42cf7682102">scanf</a></code>, <code><a class="el" href="group__avr__stdio.html#ga0fb7fd70cd7618f27d8219c97e61bcf3">scanf_P</a></code>, <code><a class="el" href="group__avr__stdio.html#ga0beb4fd9ff6833a364e3ce60370de058">fscanf</a></code>, <code><a class="el" href="group__avr__stdio.html#ga7aec94e711ad64724076666586a26839">fscanf_P</a></code>, <code><a class="el" href="group__avr__stdio.html#ga8bd4b760f67791a54e73111734caa82f">vscanf</a></code>, <code><a class="el" href="group__avr__stdio.html#ga67bae1ad3af79809fd770be392f90e21">vfscanf</a></code>, <code><a class="el" href="group__avr__stdio.html#ga6c6b5b881ce8f4739777ff3a615e988a">vfscanf_P</a></code>, <code><a class="el" href="group__avr__stdio.html#ga54fa47156a34c1659a29ed96e46e3518">fread</a></code> </td><td>Alters flags, character count, and unget buffer in the FILE argument. </td><td><p class="starttd">Assign each thread its own FILE for input. *** <br  />
Note: Scanning from a string, e.g. <a class="el" href="group__avr__stdio.html#ga5507d0e1bbfd387fbb2ffcfd8f5dca6f">sscanf</a> and <a class="el" href="group__avr__stdio.html#gaeca11dc4b3757ed4ff2f2a4950eba117">sscanf_P</a>, are thread safe.  </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code><a class="el" href="time_8h.html">time.h</a></code> </td><td>Uses global state in <code>__latitude</code>, <code>__longitude</code>, <code>__utc_offset</code>, <code>__asc_store</code>, <code>__tm_store</code>, <code>__dst_ptr</code>, <code>__system_time</code>. </td><td>Some functions have reentrant versions, like: <code><a class="el" href="group__avr__time.html#gaa1128e048925e3b208213febb8573b88">asctime_r</a></code>, <code><a class="el" href="group__avr__time.html#ga34fa7766f6b0a8a74a41683693eabad9">ctime_r</a></code>, <code><a class="el" href="group__avr__time.html#ga7cb461118a6aeebeaacd48ee127b952a">gmtime_r</a></code>, <code><a class="el" href="group__avr__time.html#ga8a4fd6a03c19f96f656316eba80b9c9a">iso_week_date_r</a></code>, <code><a class="el" href="group__avr__time.html#gae200cfc8cc7309d0ce5fef3ee490dc47">isotime_r</a></code>, <code><a class="el" href="group__avr__time.html#gacd9715002deaf28b432a8f2b54dd9aa5">localtime_r</a></code>.  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>It's not clear one would ever want to do character input simultaneously from more than one thread anyway, but these entries are included for completeness.</dd></dl>
<p>An effort will be made to keep this table up to date if any new issues are discovered or introduced.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_eeprom_corruption"></a>
Why are some addresses of the EEPROM corrupted (usually address zero)?</h1>
<p>The two most common reason for EEPROM corruption is either writing to the EEPROM beyond the datasheet endurance specification, or resetting the AVR while an EEPROM write is in progress.</p>
<p>EEPROM writes can take up to tens of milliseconds to complete. So that the CPU is not tied up for that long of time, an internal state-machine handles EEPROM write requests. The EEPROM state-machine expects to have all of the EEPROM registers setup, then an EEPROM write request to start the process. Once the EEPROM state-machine has started, changing EEPROM related registers during an EEPROM write is guaranteed to corrupt the EEPROM write process. The datasheet always shows the proper way to tell when a write is in progress, so that the registers are not changed by the user's program. The EEPROM state-machine will <b>always</b> complete the write in progress unless power is removed from the device.</p>
<p>As with all EEPROM technology, if power fails during an EEPROM write the state of the byte being written is undefined.</p>
<p>In older generation AVRs the EEPROM Address Register (EEAR) is initialized to zero on reset, be it from Brown Out Detect, Watchdog or the Reset Pin. If an EEPROM write has just started at the time of the reset, the write will be completed, but now at address zero instead of the requested address. If the reset occurs later in the write process both the requested address and address zero may be corrupted.</p>
<p>To distinguish which AVRs may exhibit the corrupt of address zero while a write is in process during a reset, look at the "initial
value" section for the EEPROM Address Register. If EEAR shows the initial value as 0x00 or 0x0000, then address zero and possibly the one being written will be corrupted. Newer parts show the initial value as "undefined", these will not corrupt address zero during a reset (unless it was address zero that was being written).</p>
<p>EEPROMs have limited write endurance. The datasheet specifies the number of EEPROM writes that are guaranteed to function across the full temperature specification of the AVR, for a given byte. A read should always be performed before a write, to see if the value in the EEPROM actually needs to be written, so not to cause unnecessary EEPROM wear.</p>
<p>The failure mechanism for an overwritten byte is generally one of "stuck" bits, i. e. a bit will stay at a one or zero state regardless of the byte written. Also a write followed by a read may return the correct data, but the data will change with the passage of time, due the EEPROM's inability to hold a charge from the excessive write wear.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_wrong_baud_rate"></a>
Why is my baud rate wrong?</h1>
<p>Some AVR datasheets give the following formula for calculating baud rates:</p>
<div class="fragment"><div class="line">(<a class="code hl_define" href="group__util__delay.html#ga43bafb28b29491ec7f871319b5a3b2f8">F_CPU</a> / (UART_BAUD_RATE * 16L) - 1)</div>
<div class="ttc" id="agroup__util__delay_html_ga43bafb28b29491ec7f871319b5a3b2f8"><div class="ttname"><a href="group__util__delay.html#ga43bafb28b29491ec7f871319b5a3b2f8">F_CPU</a></div><div class="ttdeci">#define F_CPU</div><div class="ttdoc">CPU frequency in Hz.</div><div class="ttdef"><b>Definition:</b> delay.h:115</div></div>
</div><!-- fragment --><p>Unfortunately that formula does not work with all combinations of clock speeds and baud rates due to integer truncation during the division operator.</p>
<p>When doing integer division it is usually better to round to the nearest integer, rather than to the lowest. To do this add 0.5 (i. e. half the value of the denominator) to the numerator before the division, resulting in the formula:</p>
<div class="fragment"><div class="line">((<a class="code hl_define" href="group__util__delay.html#ga43bafb28b29491ec7f871319b5a3b2f8">F_CPU</a> + UART_BAUD_RATE * 8L) / (UART_BAUD_RATE * 16L) - 1)</div>
</div><!-- fragment --><p>This is also the way it is implemented in <a class="el" href="group__util__setbaud.html">&lt;util/setbaud.h&gt;: Helper macros for baud rate calculations</a>.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_funcptr_gt128kib"></a>
On a device with more than 128 KiB of flash, how to make function pointers work?</h1>
<p>Function pointers beyond the "magical" 128 KiB barrier(s) on larger devices are supposed to be resolved through so-called <em>trampolines</em> by the linker, so the actual pointers used in the code can remain 16 bits wide.</p>
<p>In order for this to work, the option <code>-mrelax</code> must be given on the compiler command-line that is used to link the final ELF file.</p>
<p>See also the avr-gcc online documentation on the <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#eind"><code>EIND</code> special function register</a> and indirect calls.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_assign_chain"></a>
Why is assigning ports in a "chain" a bad idea?</h1>
<p>Suppose a number of IO port registers should get the value <code>0xff</code> assigned. Conveniently, it is implemented like this:</p>
<div class="fragment"><div class="line">DDRB = DDRD = 0xff;</div>
</div><!-- fragment --><p>According to the rules of the C language, this causes 0xff to be assigned to <code>DDRD</code>, then <code>DDRD</code> is read back, and the value is assigned to <code>DDRB</code>. The compiler stands no chance to optimize the readback away, as an IO port register is declared "volatile". Thus, chaining that kind of IO port assignments would better be avoided, using explicit assignments instead:</p>
<div class="fragment"><div class="line">DDRB = 0xff;</div>
<div class="line">DDRD = 0xff;</div>
</div><!-- fragment --><p>Even worse ist this, e. g. on an ATmega1281:</p>
<div class="fragment"><div class="line">DDRA = DDRB = DDRC = DDRD = DDRE = DDRF = DDRG = 0xff;</div>
</div><!-- fragment --><p>The same happens as outlined above. However, when reading back register <code>DDRG</code>, this register only implements 6 out of the 8 bits, so the two topmost (unimplemented) bits read back as 0! Consequently, all remaining <code>DDR</code><em>x</em> registers get assigned the value 0x3f, which does not match the intention of the developer in any way.</p>
<h1><a class="anchor" id="faq_headers"></a>
Which header files are included in my program?</h1>
<p>Suppose we have a simple program like </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>and we want to know which files this <code>#include</code> triggers. Just add option <code>-H</code> to the compiler options and check what is printed on standard output: </p><pre class="fragment">$ avr-gcc -H -S main.c -mmcu=atmega8
. &lt;install&gt;/avr/include/avr/pgmspace.h
.. &lt;install&gt;/avr/include/inttypes.h
... &lt;install&gt;/lib/gcc/avr/&lt;version&gt;/include/stdint.h
.... &lt;install&gt;/avr/include/stdint.h
.. &lt;install&gt;/lib/gcc/avr/&lt;version&gt;/include/stddef.h
.. &lt;install&gt;/avr/include/avr/io.h
... &lt;install&gt;/avr/include/avr/sfr_defs.h
... &lt;install&gt;/avr/include/avr/iom8.h
... &lt;install&gt;/avr/include/avr/portpins.h
...
</pre><p> where <code>&lt;install&gt;</code> denotes the installation path, <code>&lt;version&gt;</code> denotes the GCC version, and the number of dots indicates the include level, e.g. <code><a class="el" href="inttypes_8h.html">inttypes.h</a></code> is included by <code><a class="el" href="pgmspace_8h.html">pgmspace.h</a></code>.</p>
<p>When <code>-v</code> is added to the compiler options, then the search paths are also displayed (amongst other stuff): </p><pre class="fragment">#include "..." search starts here:
#include &lt;...&gt; search starts here:
 &lt;install&gt;/bin/../lib/gcc/avr/&lt;version&gt;/include
 &lt;install&gt;/bin/../lib/gcc/avr/&lt;version&gt;/include-fixed
 &lt;install&gt;/bin/../lib/gcc/avr/&lt;version&gt;/../../../../avr/include
End of search list.
</pre><p> After resolving the <code>..</code>'s for <em>"parent directory"</em>, the last directory becomes<br  />
 <code>&lt;install&gt;/avr/include</code>.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_macros"></a>
Which macros are defined in my program? Where are they defined, and to what value?</h1>
<p>For a documentation of compiler built-in macros see <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#AVR-Built-in-Macros">AVR built-in macros</a> in the GCC online documentation.</p>
<p>One way to find all the defined macros is to add <code><a class="el" href="using_tools.html#opt_save_temps">-save-temps</a></code> and <code><a class="el" href="using_tools.html#opt_g">-g3</a></code> to the compiler options. This saves the temporary files like the pre-processed source code in an <code>.i</code> file (for C sources), an <code>.ii</code> (for C++), or a <code>.s</code> (for assembly). A debug level of DWARF3 or higher is required to include the macro definitions in the file. With lower debug levels, only the preprocessed source will be present.</p>
<p>For a module with a simple <code>#include &lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</code>, the saved intermediate file might look something like:</p>
<pre class="fragment"># 0 "&lt;built-in&gt;"
#define __STDC__ 1
</pre><p>&rArr; The <code>__STDC__</code> macro is defined built-in in the compiler.</p>
<pre class="fragment"># 0 "&lt;command-line&gt;"
#define __AVR_DEVICE_NAME__ atmega8
</pre><p>&rArr; The <code>__AVR_DEVICE_NAME__</code> macro is defined on the command line by means of <code>-D __AVR_DEVICE_NAME__=atmega8</code>. In this special case, the <code>-D</code> option is added by the specs file <code>specs-atmega8</code>.</p>
<pre class="fragment"># 81 "&lt;install&gt;/avr/include/avr/pgmspace.h" 3
#define __PGMSPACE_H_ 1


#define __need_size_t
</pre><p>&rArr; The <code>__PGMSPACE_H_</code> macro is defined in line 81 of that header file. When there is no line note directly above the definition, go up until you find a line note and add the respective number of lines. For example, the <code>__need_size_t</code> macro is defined in line 84 of that file.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_isr_names"></a>
What ISR names are available for my device?</h1>
<p>The HTML documentation comes with exhaustive <a class="el" href="group__avr__interrupts.html#avr_signames">Vector &rarr; AVRs</a> and <a class="el" href="group__avr__interrupts.html#avr_mcu_signames">AVR &rarr; Vectors</a> tables. In order to get a vector number for the <code>ISR_N</code> macro, just append <code>_num</code> to the vector name as used with <code>ISR</code>. For example use <code><a class="el" href="group__avr__interrupts.html#ga48ae9a7647627e76a69f814510566d6c">ISR_N(ADC0_vect_num)</a></code> instead of <a class="el" href="group__avr__interrupts.html#gad28590624d422cdf30d626e0a506255f">ISR(ADC0_vect)</a>.</p>
<p>One way to find the available vector names is to pre-process a small file, and to grep for possible names, like in:</p>
<pre class="fragment">$ echo "#include &lt;avr/io.h&gt;" | avr-gcc -xc - -mmcu=atmega8 -E -dM  | grep _VECTOR
#define INT0_vect _VECTOR(1)
#define INT1_vect _VECTOR(2)
#define TIMER2_COMP_vect _VECTOR(3)
#define TIMER2_OVF_vect _VECTOR(4)
#define TIMER1_CAPT_vect _VECTOR(5)
...
</pre><p>Explanation: </p><dl>
<dt><code>echo "#include &lt;avr/io.h&gt;"</code> </dt>
<dd><p class="startdd">This prints <code>#include &lt;<a class="el" href="io_8h.html">avr/io.h</a>&gt;</code> to the standard output, which is picked up by the following command as a C program to be preprocessed. </p>
<p class="enddd"></p>
</dd>
<dt><code>avr-gcc -xc - -mmcu=atmega8 -E -dM</code> </dt>
<dd><p class="startdd">Set the <a class="el" href="using_tools.html#opt_x">input language</a> to C, read the program from standard input (specified by a dash), preprocess, and print all macro definitions to the standard output. </p>
<p class="enddd"></p>
</dd>
<dt><code>grep _VECTOR</code> </dt>
<dd><p class="startdd">Only print lines with <code>_VECTOR</code> in them.<br  />
 The output above was actually generated with an additional <code>| sort -t '(' -k 2n</code> so that the vectors are printed in order.</p>
<p class="enddd">In order to find the respective vector numbers, use <code>grep _vect_num</code> instead.  </p>
</dd>
</dl>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_toolchain_version"></a>
What are the versions of the tools in my toolchain?</h1>
<p>The versions of the tools can be obtained by running the following commands and taking the first line of the standard output:</p>
<table class="doxtable">
<caption>Commands to obtain Tool Versions</caption>
<tr>
<th>Version of </th><th>Command </th></tr>
<tr>
<td>Compiler </td><td><code>avr-gcc --version</code> </td></tr>
<tr>
<td>Assembler </td><td><code>avr-as --version</code> </td></tr>
<tr>
<td>LD Linker<sup>1</sup> </td><td><code>avr-ld --version</code> </td></tr>
<tr>
<td>CC Linker<sup>2</sup> </td><td><code>echo "" | avr-gcc -xc - -Wl,--version 2&gt; /dev/null</code> </td></tr>
<tr>
<td>AVR-LibC </td><td><code>echo "#include &lt;avr/version.h&gt;" | avr-gcc -xc - -E -dM | grep AVR_LIBC_VERSION_STRING</code> </td></tr>
</table>
<p>Linker<sup>1</sup> is the linker as called directly (<code>avr-ld</code>) whereas Linker<sup>2</sup> is the linker as called though the compiler driver <code>avr-gcc</code>. The latter is the usual way to invoke the linker. When these two versions are not the same, then the resulting toolchain may have inconsistencies.</p>
<p>When you have more then one toolchain installed, then make sure you are calling the command from the intended toolchain, e.g. by specifying the absolute path to the tool.</p>
<p>Also notice that software may come with vendor specific patches, so that the tool behaves differently than the stock version.</p>
<p>The FAQ document you are reading right now is part of an AVR-LibC that has been configured for the following tool versions:</p>
<table class="doxtable">
<caption>Tool Versions</caption>
<tr>
<th>Software </th><th>Version </th></tr>
<tr>
<td>Compiler </td><td><code>avr-gcc (GCC) 14.2.0</code> </td></tr>
<tr>
<td>Assembler </td><td><code>GNU assembler (GNU Binutils) 2.43.1</code> </td></tr>
<tr>
<td>LD Linker </td><td><code>GNU ld (GNU Binutils) 2.43.1</code> </td></tr>
<tr>
<td>CC Linker </td><td><code>GNU ld (GNU Binutils) 2.43.1</code> </td></tr>
<tr>
<td>AVR-LibC </td><td><code>2.3.0</code> </td></tr>
</table>
<ul>
<li><a href="https://gcc.gnu.org/gcc-14">GCC 14 documentation</a></li>
<li><a href="https://gcc.gnu.org/gcc-14/changes.html#avr">GCC 14 release notes</a></li>
</ul>
<p><a class="anchor" id="faq_toolchain_support"></a> The following features have been detected when building AVR-LibC. They influence how pars of the library behave.</p>
<table class="doxtable">
<caption>Toolchain Features affecting AVR-LibC</caption>
<tr>
<th>Feature </th><th>Supported </th><th>Affects </th></tr>
<tr>
<td><a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Built-in-Functions.html#index-_005f_005fbuiltin_005favr_005fdelay_005fcycles"><code>__builtin_avr_delay_cycles()</code></a>  </td><td>yes </td><td><code>&lt;<a class="el" href="delay_8h.html">util/delay.h</a>&gt;</code> </td></tr>
<tr>
<td><a class="el" href="mem_sections.html#sec_memory_regions">text</a> starts at <code>__TEXT_REGION_ORIGIN__</code> </td><td>yes </td><td>Starup code </td></tr>
<tr>
<td><a class="el" href="mem_sections.html#sec_memory_regions">data</a> starts at <code>__DATA_REGION_ORIGIN__</code> </td><td>yes </td><td>Starup code </td></tr>
<tr>
<td>Compiler supports <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#index-mcvt"><code>-mcvt</code></a> </td><td>no </td><td><a class="el" href="FAQ.html#faq_cvt">CVT</a> convenience </td></tr>
<tr>
<td>Compiler supports attribute <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Function-Attributes.html#index-signal_0028num_0029-function-attribute_002c-AVR"><code>signal(n)</code></a> </td><td>no </td><td><code>&lt;<a class="el" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</code>, <a class="el" href="group__avr__interrupts.html#ga48ae9a7647627e76a69f814510566d6c">ISR_N</a>, <a class="el" href="FAQ.html#faq_local_isr">local functions as ISRs</a> </td></tr>
<tr>
<td>64-bit floating-point </td><td>yes: <code>-mdouble=64</code>, <code>-mlong-double=32</code> </td><td><code>&lt;<a class="el" href="math_8h.html">math.h</a>&gt;</code>, Libraries </td></tr>
<tr>
<td>Fixed-point  </td><td>yes </td><td><code>&lt;<a class="el" href="group__avr__stdfix.html#stdfix_h">stdfix.h</a>&gt;</code>, Libraries </td></tr>
<tr>
<td>Device library <code>lib<em>mcu</em>.a</code> </td><td>yes </td><td>Startup code, Libraries </td></tr>
</table>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_toolchain_sources"></a>
Where can I find the source code of the tools?</h1>
<p>Here are web views of the GIT repos of the projects and some points of interest.</p>
<p><a href="https://sourceware.org/binutils"><b>Binutils</b></a></p><ul>
<li>Top source: <a href="https://sourceware.org/git/?p=binutils-gdb.git;a=tree">https://sourceware.org/git/binutils-gdb.git</a><br  />
 The linker is located in <code>ld/</code>, the assembler in <code>gas/</code> and the other tools are in <code>binutils/</code>.</li>
<li>Linker script: <a href="https://sourceware.org/git/?p=binutils-gdb.git;a=blob;f=ld/scripttempl/avr.sc">ld/scripttempl/avr.sc</a></li>
<li>AVR opcodes: <a href="https://sourceware.org/git/?p=binutils-gdb.git;a=blob;f=include/opcode/avr.h">include/opcodes/avr.h</a></li>
<li>Latest <a href="https://sourceware.org/binutils/docs/">manual</a></li>
</ul>
<p><a href="https://gcc.gnu.org"><b>GCC</b></a></p><ul>
<li>Top source: <a href="https://gcc.gnu.org/git/?p=gcc.git;a=tree;hb=HEAD">https://gcc.gnu.org/git/gcc.git</a></li>
<li>AVR backend: <a href="https://gcc.gnu.org/git/?p=gcc.git;a=tree;f=gcc/config/avr">gcc/config/avr</a></li>
<li>libgcc (AVR part): <a href="https://gcc.gnu.org/git/?p=gcc.git;a=tree;f=libgcc/config/avr">libgcc/config/avr</a></li>
<li>Online <a href="https://gcc.gnu.org/onlinedocs/">manuals</a></li>
</ul>
<p><a href="https://avrdudes.github.io/avr-libc"><b>AVR-LibC</b></a></p><ul>
<li>Top source: <a href="https://github.com/avrdudes/avr-libc">https://github.com/avrdudes/avr-libc.git</a></li>
<li>Startup code: <a href="https://github.com/avrdudes/avr-libc/blob/main/crt1/gcrt1.S">crt1/gcrt1.S</a></li>
<li>Online <a href="https://avrdudes.github.io/avr-libc/">manuals</a></li>
</ul>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_toolchain_bugs"></a>
Where can I report a problem?</h1>
<p>The projects have issue trackers:</p><ul>
<li><a href="https://gcc.gnu.org/bugzilla/">GCC Bugzilla</a> and the <a href="https://gcc.gnu.org/bugs/#report">GCC bug-reporting guide</a></li>
<li><a href="https://sourceware.org/bugzilla/">Binutils Bugzilla</a> and the <a href="https://sourceware.org/bugzilla/page.cgi?id=bug-writing.html">Binutils bug-reporting guide</a></li>
<li><a href="https://github.com/avrdudes/avr-libc/issues">AVR-LibC issues</a></li>
</ul>
<p>Please make sure to use the most recent tool version before filing an issue. When reporting a problem, please make sure that the report is self-contained and that the artifact can be reproduced by others.</p>
<p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small></p>
<h1><a class="anchor" id="faq_use_bv"></a>
What is all this _BV() stuff about?</h1>
<p>When performing low-level output work, which is a very central point in microcontroller programming, it is quite common that a particular bit needs to be set or cleared in some IO register. While the device documentation provides mnemonic names for the various bits in the IO registers, and the <a class="el" href="group__avr__io.html">AVR device-specific IO definitions</a> reflect these names in definitions for numerical constants, a way is needed to convert a bit number (usually within a byte register) into a byte value that can be assigned directly to the register. However, sometimes the direct bit numbers are needed as well (e. g. in an <code>SBI()</code> instruction), so the definitions cannot usefully be made as byte values in the first place.</p>
<p>So in order to access a particular bit number as a byte value, use the <code><a class="el" href="group__avr__sfr.html#ga11643f271076024c395a93800b3d9546">_BV()</a></code> macro. Of course, the implementation of this macro is just the usual bit shift (which is done by the compiler anyway, thus doesn't impose any run-time penalty), so the following applies:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__avr__sfr.html#ga11643f271076024c395a93800b3d9546">_BV</a>(3) =&gt; 1 &lt;&lt; 3 =&gt; 0x08</div>
</div><!-- fragment --><p>However, using the macro often makes the program better readable.</p>
<p>"BV" stands for "bit value", in case someone might ask you. :-)</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Clock timer 2 with full IO clock (CS2x = 0b001).</span></div>
<div class="line"><span class="comment">// Toggle OC2 output on compare match (COM2x = 0b01).</span></div>
<div class="line"><span class="comment">// Clear timer on compare match (CTC2 = 1).</span></div>
<div class="line">TCCR2 = <a class="code hl_define" href="group__avr__sfr.html#ga11643f271076024c395a93800b3d9546">_BV</a>(COM20) | <a class="code hl_define" href="group__avr__sfr.html#ga11643f271076024c395a93800b3d9546">_BV</a>(CTC2) | <a class="code hl_define" href="group__avr__sfr.html#ga11643f271076024c395a93800b3d9546">_BV</a>(CS20);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Make OC2 (PD7) an output.</span></div>
<div class="line">DDRD = <a class="code hl_define" href="group__avr__sfr.html#ga11643f271076024c395a93800b3d9546">_BV</a>(PD7);</div>
</div><!-- fragment --><p><small>Back to <a class="el" href="FAQ.html#faq_index">FAQ Index</a>.</small> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 23 2025 14:19:01 for AVR-LibC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.6
</small></address>
</body>
</html>
