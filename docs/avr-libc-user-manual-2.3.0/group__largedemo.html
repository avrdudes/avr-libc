<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<title>AVR-LibC: A more sophisticated project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AVR-LibC
   &#160;<span id="projectnumber">2.3.0</span>
   </div>
   <div id="projectbrief">Standard C library for AVR-GCC</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table>
  <tr>
    <td align="left"><a href="https://avrdudes.github.io/avr-libc/"><h2>AVR-LibC Manual</h2></a></td>
    <td align="center" colspan=4>
      <div class="logo"><img src="avr-libc-logo.png" alt="Logo" align="middle" border="0"></div>
      <div class="invlogo"><img src="avr-libc-logo-inverted.png" alt="Logo" align="middle" border="0"></div>
    </td>
    <td align="right"><a href="https://github.com/avrdudes/avr-libc/"><h2>AVR-LibC Sources</h2></a></td>
  </tr>
  <tr>
    <td align="center" width="14%"><a href="index.html"><h2>Main Page</h2></a></td>
    <td align="center" width="16%"><a href="pages.html"><h2>User Manual</h2></a></td>
    <td align="center" width="22%"><a href="modules.html"><h2>Lib&shy;rary Refe&shy;rence</h2></a></td>
    <td align="center" width="7%"><a href="FAQ.html"><h2>FAQ</h2></a></td>
    <td align="center" width="22%"><a href="group__demos.html"><h2>Exam&shy;ple Pro&shy;jects</h2></a></td>
    <td align="center" width="14%"><a href="Global_01Index.html"><h2>Index</h2></a></td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">A more sophisticated project<div class="ingroups"><a class="el" href="group__demos.html">Demo projects</a></div></div></div>
</div><!--header-->
<div class="contents">
<p>This project extends the basic idea of the <a class="el" href="group__demo__project.html">simple project</a> to control a LED with a PWM output, but adds methods to adjust the LED brightness. It employs a lot of the basic concepts of AVR-LibC to achieve that goal.</p>
<p>Understanding this project assumes the simple project has been understood in full, as well as being acquainted with the basic hardware concepts of an AVR microcontroller.</p>
<h1><a class="anchor" id="largedemo_hw"></a>
Hardware setup</h1>
<p>The demo is again arranged around an Arduino Nano compatible board. This time, the hardware PWM of the ATmega328P is used, so a LED (with resistor) needs to be attached to Arduino D8 (= PB1 = OC1A on the ATmega328P). Further, a potentiometer needs to be connected to ADC0 (Arduino A0), with GND and +5V at the outer terminals. Finally, three push buttons are connected to Arduino D2, D3, and D4, respectively (= PD2, PD3, PD4).</p>
<div class="image">
<img src="largedemo-setup.jpg" alt=""/>
<div class="caption">
Setup of the Arduino Nano</div></div>
 <p>Note that in the explanation below, all port/pin names are applicable to the ATmega328P setup.</p>
<h1><a class="anchor" id="largedemo_overview"></a>
Functional overview</h1>
<p>PD6 (Arduino D6) will be toggled with each internal clock tick (approx. 10 ms). PD7 (Arduino D7) will flash (short low pulse) once per second.</p>
<p>PD0 and PD1 are configured as UART IO, and can be used to connect the demo kit to a PC (9600 Bd, 8N1 frame format). The demo application talks to the serial port, and it can be controlled from the serial port. On an Arduino Nano compatible board, this serial connection is routed to a USB-to-serial interface, so a PC can communicate through USB.</p>
<p>PD2 through PD4 are configured as inputs, and control the application unless control has been taken over by the serial port. Shorting PD2 to GND will decrease the current PWM value, shorting PD3 to GND will increase it.</p>
<p>While PD4 is shorted to GND, one ADC conversion for channel 0 (ADC input is on PA0) will be triggered each internal clock tick, and the resulting value will be used as the PWM value. So the brightness of the LED follows the analog input value on PC0. On the Arduino Nano, the ADC uses VCC internally as reference; all other setups require the reference voltage to be attached to the AREF pin.</p>
<p>When running in serial control mode, the function of the watchdog timer can be demonstrated by typing an `r'. This will make the demo application run in a tight loop without retriggering the watchdog so after some seconds, the watchdog will reset the MCU. This situation can be figured out on startup by reading the MCUCSR register.</p>
<p>The current value of the PWM is backed up in an EEPROM cell after about 3 seconds of idle time after the last change. If that EEPROM cell contains a reasonable (i. e. non-erased) value at startup, it is taken as the initial value for the PWM. This virtually preserves the last value across power cycles. By not updating the EEPROM immediately but only after a timeout, EEPROM wear is reduced considerably compared to immediately writing the value at each change.</p>
<h1><a class="anchor" id="largedemo_code"></a>
A code walkthrough</h1>
<p>This section explains the ideas behind individual parts of the code. The <a class="el" href="group__largedemo.html#largedemo_src">source code</a> has been divided into numbered parts, and the following subsections explain each of these parts.</p>
<h2><a class="anchor" id="largedemo_code_p1"></a>
Part 1: Macro definitions</h2>
<p>A number of preprocessor macros are defined to improve readability and/or portability of the application.</p>
<p>The first macros describe the IO pins our LEDs and pushbuttons are connected to. This provides some kind of mini-HAL (hardware abstraction layer) so should some of the connections be changed, they don't need to be changed inside the code but only on top. Note that the location of the PWM output itself is mandated by the hardware, so it cannot be easily changed. As the ATmega48/88/168/328P controllers belong to a more recent generation of AVRs, a number of register and bit names have been changed there, so they are mapped back to their ATmega8/16 equivalents to keep the actual program code portable.</p>
<p>The name <code>F_CPU</code> is the conventional name to describe the CPU clock frequency of the controller. This demo project just uses a 1 MHz CPU clock. On many AVR devices, this is the default startup frequency from the internal RC oscillator. On the Arduino Nano, the MCU is clocked by an external 16 MHz crystal though. Therefore, during device initialization, a 1:16 prescaler is configured at startup so the remaining code could remain the same. Note that when using the <code>&lt;<a class="el" href="delay_8h.html">util/delay.h</a>&gt;</code> functions, <code><a class="el" href="group__util__delay.html#ga43bafb28b29491ec7f871319b5a3b2f8" title="CPU frequency in Hz.">F_CPU</a></code> needs to be defined before including that file.</p>
<p>The remaining macros have their own comments in the source code. The macro <code>TMR1_SCALE</code> shows how to use the preprocessor and the compiler's constant expression computation to calculate the value of timer 1's post-scaler in a way so it only depends on <code>F_CPU</code> and the desired software clock frequency. While the formula looks a bit complicated, using a macro offers the advantage that the application will automatically scale to new target softclock or master CPU frequencies without having to manually re-calculate hardcoded constants.</p>
<h2><a class="anchor" id="largedemo_code_p2"></a>
Part 2: Variable definitions</h2>
<p>The <code>intflags</code> structure demonstrates a way to allocate bit variables in memory. Each of the interrupt service routines just sets one bit within that structure, and the application's main loop then monitors the bits in order to act appropriately.</p>
<p>Like all variables that are used to communicate values between an interrupt service routine and the main application, it is declared <a class="el" href="FAQ.html#faq_volatile">volatile</a>.</p>
<p>The variable <code>ee_pwm</code> is not a variable in the classical C sense that could be used as an lvalue or within an expression to obtain its value. Instead, the</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> ee_pwm <a class="code hl_define" href="group__avr__eeprom.html#ga79a42ec6c6c8bbbe6e34ed57a52aac59">EEMEM</a> ... </div>
<div class="ttc" id="agroup__avr__eeprom_html_ga79a42ec6c6c8bbbe6e34ed57a52aac59"><div class="ttname"><a href="group__avr__eeprom.html#ga79a42ec6c6c8bbbe6e34ed57a52aac59">EEMEM</a></div><div class="ttdeci">#define EEMEM</div><div class="ttdef"><b>Definition:</b> eeprom.h:105</div></div>
<div class="ttc" id="agroup__avr__stdint_html_ga1f1825b69244eb3ad2c7165ddc99c956"><div class="ttname"><a href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a></div><div class="ttdeci">unsigned int uint16_t</div><div class="ttdef"><b>Definition:</b> stdint.h:96</div></div>
</div><!-- fragment --><p>marks it as belonging to the <a class="el" href="mem_sections.html#sec_dot_eeprom">EEPROM section</a>. This section is merely used as a placeholder so the compiler can arrange for each individual variable's location in EEPROM. The compiler will also keep track of initial values assigned, and usually the Makefile is arranged to extract these initial values into a separate load file (<code>largedemo_eeprom</code>.* in this case) that can be used to initialize the EEPROM.</p>
<p>The actual EEPROM IO must be performed manually.</p>
<p>Similarly, the variable <code>mcucsr</code> is kept in the <a class="el" href="mem_sections.html#sec_dot_noinit">.noinit</a> section in order to prevent it from being cleared upon application startup.</p>
<h2><a class="anchor" id="largedemo_code_p3"></a>
Part 3: Interrupt service routines</h2>
<p>The ISR to handle timer 1's overflow interrupt arranges for the software clock. While timer 1 runs the PWM, it calls its overflow handler rather frequently, so the <code>TMR1_SCALE</code> value is used as a postscaler to reduce the internal software clock frequency further. If the software clock triggers, it sets the <code>tmr_int</code> bitfield, and defers all further tasks to the main loop.</p>
<p>The ADC ISR just fetches the value from the ADC conversion, disables the ADC interrupt again, and announces the presence of the new value in the <code>adc_int</code> bitfield. The interrupt is kept disabled while not needed, because the ADC will also be triggered by executing the SLEEP instruction in idle mode (which is the default sleep mode). Another option would be to turn off the ADC completely here, but that increases the ADC's startup time (not that it would matter much for this application).</p>
<h2><a class="anchor" id="largedemo_code_p4"></a>
Part 4: Auxiliary functions</h2>
<h3><a class="anchor" id="largedemo_handle_mcucsr"></a>
handle_mcucsr()</h3>
<p>The function <code>handle_mcucsr()</code> uses <code>__attribute__</code> declarators to achieve specific goals:</p>
<dl>
<dt><code>section(".init3")</code> </dt>
<dd>First, it will instruct the compiler to place the generated code into the <a class="el" href="mem_sections.html#sec_dot_init">.init3</a> section of the output. Thus, it will become part of the application initialization sequence. This is done in order to fetch (and clear) the reason of the last hardware reset from <code>MCUCSR</code> as early as possible. </dd>
<dt><code>naked</code> </dt>
<dd><p class="startdd">As the initialization code is not called using CALL/RET instructions but rather concatenated together, the compiler needs to be instructed to omit the entire function prologue and epilogue. This is performed by the <em>naked</em> attribute. So while syntactically, <code>handle_mcucsr()</code> is a function to the compiler, the compiler will just emit the instructions for it without setting up any stack frame, and not even a RET instruction at the end.</p>
<p class="interdd">Notice that this code is not strictly conforming to GCC requirements, which documents that <code>naked</code> functions should only contain inline asm statements. However, the code is simple enough so it doesn't require a stack frame as the project is compiled with optimizations turned on.</p>
<p class="enddd"></p>
</dd>
<dt><code>used</code> </dt>
<dd>Tell the compiler that handle_mcucsr() is used by the code, even though the function is never called. This keeps the compiler from optimizing out a seemingly unused function. </dd>
</dl>
<p>There is a short period of time where the next reset could already trigger before the current reason has been evaluated. This also explains why the variable <code>mcucsr</code> that mirrors the register's value needs to be placed into the .noinit section, because otherwise the default initialization (which happens after <code>.init3</code>) would blank the value again.</p>
<h3><a class="anchor" id="largedemo_ioinit"></a>
ioinit()</h3>
<p>Function <code>ioinit()</code> centralizes all hardware setup. The very last part of that function demonstrates the use of the EEPROM variable <code>ee_pwm</code> to obtain an EEPROM address that can in turn be applied as an argument to <code><a class="el" href="group__avr__eeprom.html#ga6311011b27c7f37b6d8be9dab0a95e03">eeprom_read_word()</a></code>.</p>
<h3><a class="anchor" id="largedemo_output_functions"></a>
UART Output</h3>
<p>The following functions handle UART character and string output. (UART input is handled by an ISR.) There are two string output functions, <code>printstr()</code> and <code>printstr_p()</code>. The latter function fetches the string from <a class="el" href="group__avr__pgmspace.html">program memory</a>. Both functions translate a newline character into a carriage return/newline sequence, so a simple <code>\n</code> can be used in the source code.</p>
<h3><a class="anchor" id="largedemo_set_pwm"></a>
set_pwm()</h3>
<p>The function <code>set_pwm()</code> propagates the new PWM value to the PWM, performing range checking. When the value has been changed, the new percentage will be announced on the serial link. The current value is mirrored in the variable <code>pwm</code> so others can use it in calculations. In order to allow for a simple calculation of a percentage value without requiring floating-point mathematics, the maximal value of the PWM is restricted to 1000 rather than 1023, so a simple division by 10 can be used. Due to the nature of the human eye, the difference in LED brightness between 1000 and 1023 is not noticeable anyway.</p>
<h2><a class="anchor" id="largedemo_code_p5"></a>
Part 5: main()</h2>
<p>At the start of <code>main()</code>, a variable <code>mode</code> is declared to keep the current mode of operation. An enumeration is used to improve the readability. By default, the compiler would allocate a variable of type <em>int</em> for an enumeration. The <em>packed</em> attribute declarator instructs the compiler to use the smallest possible integer type (which would be an 8-bit type here).</p>
<p>After some initialization actions, the application's main loop follows. In an embedded application, this is normally an infinite loop as there is nothing an application could "exit" into anyway.</p>
<p>At the beginning of the loop, the watchdog timer will be retriggered. If that timer is not triggered for about 2 seconds, it will issue a hardware reset. Care needs to be taken that no code path blocks longer than this, or it needs to frequently perform watchdog resets of its own. An example of such a code path would be the string IO functions: for an overly large string to print (about 2000 characters at 9600 Bd), they might block for too long.</p>
<p>The loop itself then acts on the interrupt indication bitfields as appropriate, and will eventually put the CPU on sleep at its end to conserve power.</p>
<p>The first interrupt bit that is handled is the (software) timer, at a frequency of approximately 100 Hz. The <code>CLOCKOUT</code> pin will be toggled here, so e. g. an oscilloscope can be used on that pin to measure the accuracy of our software clock. Then, the LED flasher for LED2 ("We are alive"-LED) is built. It will flash that LED for about 50 ms, and pause it for another 950 ms. Various actions depending on the operation mode follow. Finally, the 3-second backup timer is implemented that will write the PWM value back to EEPROM once it is not changing anymore.</p>
<p>The ADC interrupt will just adjust the PWM value only.</p>
<p>Finally, the UART Rx interrupt will dispatch on the last character received from the UART.</p>
<p>All the string literals that are used as informational messages within <code>main()</code> are placed in <a class="el" href="group__avr__pgmspace.html">program memory</a> so <a class="el" href="FAQ.html#faq_flashstrings">no SRAM needs to be allocated</a> for them. This is done by using the <a class="el" href="group__avr__pgmspace.html#ga73809107539df84eaf01f6a4dea4fbff">PSTR</a> macro for the string argument of <code>printstr_p()</code>.</p>
<h1><a class="anchor" id="largedemo_src"></a>
The source code</h1>
<p> 
Source file: <a href="examples/largedemo/largedemo.c">largedemo.c</a>
</p>
<p> </p>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 23 2025 14:19:03 for AVR-LibC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.6
</small></address>
</body>
</html>
