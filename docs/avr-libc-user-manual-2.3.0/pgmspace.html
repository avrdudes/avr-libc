<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<title>AVR-LibC: Data in Program Space</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AVR-LibC
   &#160;<span id="projectnumber">2.3.0git</span>
   </div>
   <div id="projectbrief">Standard C library for AVR-GCC</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table>
  <tr>
    <td align="left"><a href="https://avrdudes.github.io/avr-libc/"><h2>AVR-LibC Documen&shy;tation</h2></a></td>
    <td align="center" colspan=4>
      <div class="logo"><img src="avr-libc-logo.png" alt="Logo" align="middle" border="0"></div>
      <div class="invlogo"><img src="avr-libc-logo-inverted.png" alt="Logo" align="middle" border="0"></div>
    </td>
    <td align="right" colspan=2><a href="https://github.com/avrdudes/avr-libc/"><h2>AVR-LibC Development Pages</h2></a></td>
  </tr>
  <tr>
    <td align="center" width="15%"><a href="index.html"><h2>Main Page</h2></a></td>
    <td align="center" width="15%"><a href="pages.html"><h2>User Manual</h2></a></td>
    <td align="center" width="15%"><a href="modules.html"><h2>Library Refe&shy;rence</h2></a></td>
    <td align="center" width="8%"><a href="FAQ.html"><h2>FAQ</h2></a></td>
    <td align="center" width="15%"><a href="group__demos.html"><h2>Example Projects</h2></a></td>
    <td align="center" width="8%"><a href="files.html"><h2>File List</h2></a></td>
    <td align="center" width="8%"><a href="Global_01Index.html"><h2>Index</h2></a></td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Data in Program Space </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="pgmspace_introduction"></a>
Introduction</h1>
<p>So you have some constant data and you're running out of room to store it? Many AVRs have limited amount of RAM in which to store data, but may have more Flash space available. The AVR is a Harvard architecture processor, where Flash is used for the program, RAM is used for data, and they each have separate address spaces. It is a challenge to get constant data to be stored in the Program Space, and to retrieve that data to use it in the AVR application.</p>
<p>The problem is exacerbated by the fact that the C Language was not designed for Harvard architectures, it was designed for Von Neumann architectures where code and data exist in the same address space. This means that any compiler for a Harvard architecture processor, like the AVR, has to use other means to operate with separate address spaces.</p>
<p>GCC has a special keyword, <code>__attribute__</code> that is used to attach different attributes to things such as function declarations, variables, and types. This keyword is followed by an attribute specification in double parentheses. In AVR GCC, there is a special attribute called <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Variable-Attributes.html#index-progmem-variable-attribute_002c-AVR"><code>progmem</code></a>. This attribute is used on data definitions, and tells the compiler to place the data in the Program Memory (Flash).</p>
<p>AVR-LibC provides a simple macro <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> that is defined as the attribute syntax of GCC with the <code>__progmem__</code> attribute. The PROGMEM macro is defined in the <a class="el" href="group__avr__pgmspace.html">&lt;avr/pgmspace.h&gt;</a> system header which also provides macros and inline functions to access such data.</p>
<p>An alternative approach is taken by named address-spaces like <a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> and <a class="el" href="group__avr__flash.html#ga23fa8e089930723df0ce4bbdbf8d02bc">__flashx</a> as proposed by the N1275 draft to the ISO/IEC DTR 18037 "Embedded C" specification. Named address-spaces are supported in <code>avr-gcc</code> since v4.7 (<a class="el" href="group__avr__flash.html#ga23fa8e089930723df0ce4bbdbf8d02bc">__flashx</a> since <code>avr-gcc</code> v15) as part of the GNU-C99 language dialect (<code>-std=gnu99</code> and up), see the <a href="https://gcc.gnu.org/onlinedocs/gcc/Named-Address-Spaces.html">avr-gcc documentation</a>.</p>
<dl class="section note"><dt>Note</dt><dd>There are AVR devices that provide a linear address space where the program memory is seen in the RAM address space and can be accessed with <code>LD</code> instructions. The respective device families are:<ul>
<li>Devices from the AVRrc core in <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrtiny">avrtiny</a>.</li>
<li>AVR16 and AVR32 devices, and devices from the 0-series, 1-series, 2-series in <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrxmega3">avrxmega3</a>.</li>
<li>AVR64 devices in <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrxmega2">avrxmega2</a> and AVR128 devices in <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrxmega4">avrxmega4</a>. For these devices, only a 32 KiB portion of the program flash is visible in the RAM address space. And only <em>without</em> <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#index-mrodata-in-ram"><code>-mrodata-in-ram</code></a> will <code>.rodata</code> be located in flash. </li>
</ul>
</dd>
<dd>
In all of these cases, complications like <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> or <a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> are not needed, though they are working as usual.</dd></dl>
<h1><a class="anchor" id="pgmspace_const"></a>
Why is GCC putting const Data into RAM to begin with?</h1>
<p>From a technical point of view, GCC is putting constant data in static storage<sup><a class="el" href="pgmspace.html#foot_cpp_const">1</a></sup> into the <a class="el" href="mem_sections.html#sec_input">.rodata input section</a>, as opposed to non-const data which is put into <code>.data</code> or <code>.bss</code>. But the question is then: Why is the <a class="el" href="mem_sections.html#sec_ld_script_blocks">linker (script)</a> putting the <code>.rodata</code> sections into RAM? In order to better understand this, take the following code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span> c_one;</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">char</span> c_two;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> is_one (<span class="keyword">const</span> <span class="keywordtype">char</span> *pc)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> *pc == <span class="charliteral">&#39;1&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> test1 (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (is_one (&amp;c_one))</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_one (&amp;c_two))</div>
<div class="line">        <span class="keywordflow">return</span> 2;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is a completely valid C99 compilation unit.</p>
<p>Function <code>is_one</code> takes a <code>const char*</code> pointer argument because it is just reading through <code>pc</code> and does not modify the pointed-to object. Without the <code>const</code> qualifier for the pointed-to object it was not possible to use the function with constant pointers like <code>&amp;c_one</code>, because the code would no more be const-correct.</p>
<p>Moreover, it is completely fine to pass the address of a non-const object like <code>&amp;c_two</code> to a function that won't change the pointed-to object, and hence takes a pointer-to-const.</p>
<p>The big question in now: What assembly / machine code should a compiler generate for <code>is_one()</code>?</p>
<ul>
<li>
<p class="startli">AVR GCC is using <code>LD(pc)</code> in order to read <code>*pc</code>: </p><pre class="fragment">is_one:
    movw r30, r24  ; move pc from r25:r24 to Z
    ldi  r24, 1    ; return value := true
    ld   r25, Z    ; r25 := *Z using LD
    cpi  r25, '1'  ; is r25 == '1' ?
    breq .L2       ; yes: then goto return
    ldi  r24, 0    ; no:  then return value := false
.L2:
    ret            ; return value (r24)
</pre><p class="endli">This works when <code>c_one</code> and <code>c_two</code> are located in RAM<sup><a class="el" href="pgmspace.html#foot_cpp_const">2</a></sup>, so that the <code>LD</code> instruction can be used. </p>
</li>
<li>
<p class="startli">A different approach would be to use <code>LD(pc)</code> when <code>*pc</code> is located in RAM, and <code>LPM(pc)</code> when <code>*pc</code> is located in flash; something like: </p><pre class="fragment">if is_ram_pointer(pc)
    r25 = LD(pc)
else
    r25 = LPM(pc)</pre><p> The drawbacks are obvious: Such code is expensive, because it has to discriminate at run-time whether <code>pc</code> points to RAM or to flash. Plus, there must be some means to tell which kind of pointer <code>pc</code> actually is. For example, the high bit of the address could be used to encode the information.</p>
<p class="endli">This approach is taken by <code>avr-gcc</code>'s named address-space <a class="el" href="group__avr__flash.html#gad830b33caf116de308322d13e2a768d2">__memx</a>, which uses 24-bit pointers and encodes the information in the high byte.  </p>
</li>
</ul>
<p>So when the compiler takes the first approach of always using <code>LD</code>, what will happen when we put <code>is_one</code> in <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>?</p>
<p>The code will just not work!<sup><a class="el" href="pgmspace.html#foot_progmem_rtiny">3</a></sup></p>
<p>To use <code>is_one()</code> for pointers to RAM as well as pointers to progmem (or <a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> for that matter), <code>is_one()</code> needs a second argument that tells which kind of pointer is being passed, and it has to adjust the code accordingly; something like: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> is_one (<span class="keyword">const</span> <span class="keywordtype">char</span> *pc, <span class="keywordtype">bool</span> is_ram_addr)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> c = is_ram_addr</div>
<div class="line">        ? <a class="code hl_function" href="group__avr__pgmspace.html#ga31fde89bb6d08399d0469dfc9244187b">pgm_read_char</a> (pc)</div>
<div class="line">        : *pc;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> c == <span class="charliteral">&#39;1&#39;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__pgmspace_html_ga31fde89bb6d08399d0469dfc9244187b"><div class="ttname"><a href="group__avr__pgmspace.html#ga31fde89bb6d08399d0469dfc9244187b">pgm_read_char</a></div><div class="ttdeci">static char pgm_read_char(const char *addr)</div></div>
<div class="ttc" id="apgmspace_8h_html"><div class="ttname"><a href="pgmspace_8h.html">pgmspace.h</a></div></div>
</div><!-- fragment --><p>Notes</p>
<ol type="1">
<li><a class="anchor" id="foot_cpp_const"></a>In C++, const static storage data might be written to. For example, in <div class="fragment"><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">int</span> vi;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> i2 = vi;</div>
</div><!-- fragment --> the variable <code>i2</code> is read-only for the C++ program, but <code>i2</code> must not be put into <code>.rodata</code> because it cannot be initialized at load-time. Due to its initializer that is not computable at load-time, <code>i2</code> has to be put into RAM and will be initialized (written to) at run-time by the startup code. <code>avr-g++</code> will diagnose when an attempt is made to put <code>i2</code> in <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>.</li>
<li><a class="anchor" id="foor_ram_addrspace"></a>More precisely, these variables have to be located in the RAM <em>address space</em> for the code to work. For example, some AVR devices see (a part of) the program memory in the RAM address space, and hence can use the LD instruction to access program memory.<br  />
 For example, an ATmega3208 sees the program memory range of 0x0...0x7fff in the RAM address space at addresses 0x4000...0xbfff. So all the linker script has to do is to provide an appropriate <a class="el" href="mem_sections.html#sec_vma">VMA</a> of 0x4000+<a class="el" href="mem_sections.html#sec_lma">LMA</a> for <code>.rodata</code> objects. This is the case for devices from the <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrxmega3">avrxmega3</a> and <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrtiny">avrtiny</a> families. Since <a href="https://gcc.gnu.org/gcc-14/changes.html#avr">GCC v14</a> / Binutils v2.42 it is also the case for <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrxmega2">AVR64</a> and <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrxmega4">AVR128</a> devices when they use the default <code>avrxmega2_flmap</code> or <code>avrxmega4_flmap</code> emulation, i.e. without <code>-mrodata-in-ram</code>.</li>
<li><a class="anchor" id="foot_progmem_rtiny"></a>The code does actually work for Reduced Tiny devices because the compiler is implementing attribute <code>progmem</code> in a different way for the reduced core (AVRrc). See the <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Variable-Attributes.html#index-progmem-variable-attribute_002c-AVR">GCC documentation on <code>progmem</code></a>.</li>
</ol>
<h1><a class="anchor" id="pgmspace_data"></a>
Storing and Retrieving Data in the Program Space</h1>
<h2><a class="anchor" id="pgmspace_data_progmem"></a>
With Attribute PROGMEM and pgm_read() Functions</h2>
<p>Let's say you have some global data:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> mydata[2][8] =</div>
<div class="line">{</div>
<div class="line">    { 2, 3, 5,  7, 11, 13, 17, 19 },</div>
<div class="line">    { 1, 4, 9, 16, 25, 36, 49, 64 }</div>
<div class="line">};</div>
</div><!-- fragment --><p>and later in your code you access this data in a function and store a single byte into a variable <code>value</code> like so:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> value = mydata[i][j];</div>
</div><!-- fragment --><p>Now you want to store your data in Program Memory. Use the <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> macro found in <code>&lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</code> and put it after the declaration of the variable, but before the initializer, like so:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> mydata[2][8] <a class="code hl_define" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> =</div>
<div class="line">{</div>
<div class="line">    { 2, 3, 5,  7, 11, 13, 17, 19 },</div>
<div class="line">    { 1, 4, 9, 16, 25, 36, 49, 64 }</div>
<div class="line">};</div>
<div class="ttc" id="agroup__avr__pgmspace_html_ga75acaba9e781937468d0911423bc0c35"><div class="ttname"><a href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a></div><div class="ttdeci">#define PROGMEM</div><div class="ttdef"><b>Definition:</b> pgmspace.h:146</div></div>
</div><!-- fragment --><p>That's it! Now your data is in the Program Space. You can compile, link, and check the map file to verify that <code>mydata</code> is placed in the correct section.</p>
<p>Now that your data resides in the Program Space, your code to access (read) the data will no longer work. The code that gets generated will retrieve the data that is located at the address of the <code>mydata</code> array, plus offsets indexed by the <code>i</code> and <code>j</code> variables. However, the final address that is calculated where to the retrieve the data points to the Data Space! Not the Program Space where the data is actually located. It is likely that you will be retrieving some garbage. The problem is that <code>avr-gcc</code> does not intrinsically know that the data resides in the Program Space.</p>
<p>The solution is fairly simple. The "rule of thumb" for accessing data stored in the Program Space is to access the data as you normally would (as if the variable is stored in Data Space), like so:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> value = mydata[i][j];</div>
</div><!-- fragment --><p>then take the address of the data:</p>
<div class="fragment"><div class="line">... &amp;(mydata[i][j]);</div>
</div><!-- fragment --><p>then use the appropriate <code>pgm_read_*</code> function, and the address of your data becomes the parameter to that function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> value = <a class="code hl_function" href="group__avr__pgmspace.html#ga31fde89bb6d08399d0469dfc9244187b">pgm_read_char</a> (&amp;(mydata[i][j]));</div>
</div><!-- fragment --><p>The <code>pgm_read_*</code> functions take an address that points to the Program Space, and retrieves the data that is stored at that address. This is why you take the address of the offset into the array. This address becomes the parameter to the function so it can generate the correct code to retrieve the data from the Program Space. There are different <code>pgm_read_*</code> functions to read different types of data at the address given.</p>
<h2><a class="anchor" id="pgmspace_data_flash"></a>
With Named Address-Space __flash</h2>
<p>The same code in terms of address-space <a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> is:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_variable" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> <span class="keywordtype">char</span> mydata[2][8] =</div>
<div class="line">{</div>
<div class="line">    { 2, 3, 5,  7, 11, 13, 17, 19 },</div>
<div class="line">    { 1, 4, 9, 16, 25, 36, 49, 64 }</div>
<div class="line">};</div>
<div class="ttc" id="agroup__avr__flash_html_ga9640f3080a04903165ca21f35da81a38"><div class="ttname"><a href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a></div><div class="ttdeci">__flash</div><div class="ttdef"><b>Definition:</b> flash.h:960</div></div>
</div><!-- fragment --><p>In order to read from <code>mydata</code>, no special code is required: </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> value = mydata[i][j];</div>
</div><!-- fragment --><p>You can also pass qualified addresses around, like in </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> get_first (<span class="keyword">const</span> <a class="code hl_variable" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> <span class="keywordtype">char</span> *array)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> array[0];</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> get_mydata_nth_first (<a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> n)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> get_first (mydata[n]);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__stdint_html_gaba7bc1797add20fe3efdf37ced1182c5"><div class="ttname"><a href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a></div><div class="ttdeci">unsigned char uint8_t</div><div class="ttdef"><b>Definition:</b> stdint.h:81</div></div>
</div><!-- fragment --><h1><a class="anchor" id="pgmspace_progmem_vs_flash"></a>
PROGMEM and __flash: The Differences</h1>
<p>So what's are the ups and down of using <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> or <a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> ?</p>
<ol type="1">
<li><code>Named</code> address-spaces are only available in GNU-C99 and up, and with <code>avr-gcc</code> v4.7 or newer. To date, GCC does not support named address-spaces in C++, whereas the <code>pgm_read</code> functions work in C++ just as well as in C.</li>
<li>Qualifiers like <a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> are easier to port. For example, <code>avr-gcc</code> does not support named address-spaces for the Reduced Tiny devices like ATtiny10. This can be handled with the builtin macro <code>__FLASH:</code> <div class="fragment"><div class="line"><span class="preprocessor">#ifndef __FLASH</span></div>
<div class="line"><span class="preprocessor">#define __flash </span><span class="comment">// empty</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Code that uses __flash</span></div>
</div><!-- fragment --> (Notice that on Reduced Tiny, section <code>.rodata</code> is located in program memory as opposed to many other AVR cores that have <code>.rodata</code> in RAM. Hence <em>not</em> using <a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> does <em>not</em> cause a loss of performance.)</li>
<li><a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> is transparent to the compiler, for example an access like <code>value = mydata[1][1]</code> can be optimized to <code>value = 4</code>, whereas accesses through <code>pgm_read</code> cannot be optimized.</li>
<li>Qualifiers like <a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> can be used in pointer targets, like in <div class="fragment"><div class="line"><span class="keywordtype">char</span> read_c (<span class="keyword">const</span> <a class="code hl_variable" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> <span class="keywordtype">char</span> *c)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> *c; <span class="comment">// Compiles to LPM</span></div>
<div class="line">}</div>
</div><!-- fragment --> whereas this is not possible for <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>, which is an attribute in GCC and not a qualifier.</li>
<li>The analogon to <a class="el" href="group__avr__pgmspace.html#ga73809107539df84eaf01f6a4dea4fbff">PSTR</a> for address-spaces is <a class="el" href="group__avr__flash.html#gabec036cb18588b3891217d4e0be515ee">FSTR</a> or <a class="el" href="group__avr__flash.html#ga63582dc1de52de7622e3b010b4213bd2">FXSTR</a>. As of v14, <code>avr-gcc</code> still rejects to put local static compound literals into an address-space (GCC PR84163). While constructs like <div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_variable" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> <span class="keywordtype">char</span> *ptext = <a class="code hl_define" href="group__avr__flash.html#gabec036cb18588b3891217d4e0be515ee">FSTR</a> (<span class="stringliteral">&quot;Text&quot;</span>);</div>
<div class="ttc" id="agroup__avr__flash_html_gabec036cb18588b3891217d4e0be515ee"><div class="ttname"><a href="group__avr__flash.html#gabec036cb18588b3891217d4e0be515ee">FSTR</a></div><div class="ttdeci">#define FSTR(str)</div><div class="ttdef"><b>Definition:</b> flash.h:180</div></div>
</div><!-- fragment --> will work and are qualifier-correct, i.e. <code>avr-gcc</code> will not raise a diagnostic with <code>-Waddr-space-convert</code>.</li>
<li><a class="el" href="group__avr__pgmspace.html#ga73809107539df84eaf01f6a4dea4fbff">PSTR</a> cannot be used on global scope, whereas a similar construct with address-spaces is possible: Take for example the code discussed in the next section that declares an array to string literals. With address-space we can write: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="flash_8h.html">avr/flash.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_variable" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> <span class="keywordtype">char</span>* <span class="keyword">const</span> <a class="code hl_variable" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> string_table[] =</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_define" href="group__avr__flash.html#ga80fd1c204ef50d9959ddcfd122dd3816">FLIT</a>(<span class="stringliteral">&quot;String 1&quot;</span>),</div>
<div class="line">    <a class="code hl_define" href="group__avr__flash.html#ga80fd1c204ef50d9959ddcfd122dd3816">FLIT</a>(<span class="stringliteral">&quot;String 2&quot;</span>),</div>
<div class="line">    <a class="code hl_define" href="group__avr__flash.html#ga80fd1c204ef50d9959ddcfd122dd3816">FLIT</a>(<span class="stringliteral">&quot;String 3&quot;</span>)</div>
<div class="line">};</div>
<div class="ttc" id="aflash_8h_html"><div class="ttname"><a href="flash_8h.html">flash.h</a></div></div>
<div class="ttc" id="agroup__avr__flash_html_ga80fd1c204ef50d9959ddcfd122dd3816"><div class="ttname"><a href="group__avr__flash.html#ga80fd1c204ef50d9959ddcfd122dd3816">FLIT</a></div><div class="ttdeci">#define FLIT(str)</div><div class="ttdef"><b>Definition:</b> flash.h:263</div></div>
</div><!-- fragment --> Notice that the <a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> left of the <code>*</code> refers to strings pointed-to by <code>string_table</code>, whereas the <a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> right of the <code>*</code> refers to <code>string_table</code> itself, i.e. the string literals as well as the table are in <a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a>.</li>
<li>For functions that take a pointer to program space like <a class="el" href="group__avr__pgmspace.html#ga5749897c91c479d02054fc02128de482">strcpy_P</a>, there are address-space correct variants like <a class="el" href="group__avr__flash.html#gaccef35e5e8a9b57c10647be92227facd">strcpy_F</a> and <a class="el" href="group__avr__flash.html#gab14e6d1f6f7d76d5410d1b715510f8ff" title="Duplicate a string from address-space __flashx.">strcpy_FX</a> that work nicely with <code>-Waddr-space-convert</code>.</li>
</ol>
<h1><a class="anchor" id="pgmspace_strings"></a>
Storing and Retrieving Strings in the Program Space</h1>
<dl class="section note"><dt>Note</dt><dd>For a solution with the <a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a> address-space, see the section above or have a look at <a class="el" href="FAQ.html#faq_rom_array_as">FAQ: How to put an array of strings completely in ROM?</a></dd></dl>
<p>Now that you can successfully store and retrieve simple data from Program Space you want to store and retrieve strings from Program Space. And specifically you want to store and array of strings to Program Space. So you start off with your array, like so:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> string_table[] =</div>
<div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;String 1&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;String 2&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;String 3&quot;</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>and then you add your <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> macro to the end of the declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> string_table[] <a class="code hl_define" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> =</div>
<div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;String 1&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;String 2&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;String 3&quot;</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Right? WRONG!</p>
<p>Unfortunately, with GCC attributes, they affect only the declaration that they are attached to. So in this case, we successfully put the <code>string_table</code> variable, the array itself, in the Program Space. This DOES NOT put the actual strings themselves into Program Space. At this point, the strings are still in the Data Space, which is probably not what you want.</p>
<p>In order to put the strings in Program Space, you have to have explicit declarations for each string, and put each string in Program Space:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> string_1[] <a class="code hl_define" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> = <span class="stringliteral">&quot;String 1&quot;</span>;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> string_2[] <a class="code hl_define" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> = <span class="stringliteral">&quot;String 2&quot;</span>;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> string_3[] <a class="code hl_define" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> = <span class="stringliteral">&quot;String 3&quot;</span>;</div>
</div><!-- fragment --><p>Then use the new symbols in your table, like so:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> string_table[] <a class="code hl_define" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> =</div>
<div class="line">{</div>
<div class="line">    string_1,</div>
<div class="line">    string_2,</div>
<div class="line">    string_3</div>
<div class="line">};</div>
</div><!-- fragment --><p>Now this has the effect of putting <code>string_table</code> in Program Space, where <code>string_table</code> is an array of pointers to characters (strings), where each pointer is a pointer to the Program Space, where each string is also stored.</p>
<p>Retrieving the strings are a different matter. You probably don't want to pull the string out of Program Space, byte by byte, using the <code><a class="el" href="group__avr__pgmspace.html#gae89a4ff0b5a887888fcf83c4701b310b">pgm_read_byte()</a></code> macro or <code>prgm_read_char()</code> function. There are other functions declared in the &lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt; header file that work with strings that are stored in the Program Space.</p>
<p>For example if you want to copy the string from Program Space to a buffer in RAM (like an automatic variable inside a function, that is allocated on the stack), you can do this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> buffer[10];</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> i = 0; i &lt; 3; i++)</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_function" href="group__avr__pgmspace.html#ga5749897c91c479d02054fc02128de482">strcpy_P</a> (buffer, (<span class="keyword">const</span> <span class="keywordtype">char</span>*) <a class="code hl_define" href="group__avr__pgmspace.html#ga8e93d1e5bf48f30fd1e30adeb4b7cc0f">pgm_read_ptr</a> (&amp; string_table[i]));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Display buffer on LCD.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__pgmspace_html_ga5749897c91c479d02054fc02128de482"><div class="ttname"><a href="group__avr__pgmspace.html#ga5749897c91c479d02054fc02128de482">strcpy_P</a></div><div class="ttdeci">char * strcpy_P(char *, const char *)</div></div>
<div class="ttc" id="agroup__avr__pgmspace_html_ga8e93d1e5bf48f30fd1e30adeb4b7cc0f"><div class="ttname"><a href="group__avr__pgmspace.html#ga8e93d1e5bf48f30fd1e30adeb4b7cc0f">pgm_read_ptr</a></div><div class="ttdeci">#define pgm_read_ptr(__addr)</div><div class="ttdef"><b>Definition:</b> pgmspace.h:938</div></div>
</div><!-- fragment --><p>Here, the <code>string_table</code> array is stored in Program Space, so we access it normally, as if were stored in Data Space, then take the address of the location we want to access, and use the address as a parameter to <code>pgm_read_ptr</code>. We use the <code>pgm_read_ptr</code> macro to read the string pointer out of the <code>string_table</code> array. Remember that a pointer is 16-bits, or word size. The <a class="el" href="group__avr__pgmspace.html#ga8e93d1e5bf48f30fd1e30adeb4b7cc0f">pgm_read_ptr</a> macro will return a <code>void*</code>. This pointer is an address in Program Space pointing to the string that we want to copy. This pointer is then used as a parameter to the function <a class="el" href="group__avr__pgmspace.html#ga5749897c91c479d02054fc02128de482">strcpy_P</a>. The function <a class="el" href="group__avr__pgmspace.html#ga5749897c91c479d02054fc02128de482">strcpy_P</a> is just like the regular <code>strcpy</code> function, except that it copies a string from Program Space (the second parameter) to a buffer in the Data Space (the first parameter).</p>
<p>There are many string functions available that work with strings located in Program Space. All of these special string functions have a suffix of <code>_P</code> in the function name, and are declared in the &lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt; header file. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 27 2025 18:32:01 for AVR-LibC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.6
</small></address>
</body>
</html>
