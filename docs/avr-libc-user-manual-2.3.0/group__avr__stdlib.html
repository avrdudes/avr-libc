<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<title>AVR-LibC: &lt;stdlib.h&gt;: General utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AVR-LibC
   &#160;<span id="projectnumber">2.3.0git</span>
   </div>
   <div id="projectbrief">Standard C library for AVR-GCC</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table>
  <tr>
    <td align="left"><a href="https://avrdudes.github.io/avr-libc/"><h2>AVR-LibC Documen&shy;tation</h2></a></td>
    <td align="center" colspan=4>
      <div class="logo"><img src="avr-libc-logo.png" alt="Logo" align="middle" border="0"></div>
      <div class="invlogo"><img src="avr-libc-logo-inverted.png" alt="Logo" align="middle" border="0"></div>
    </td>
    <td align="right" colspan=2><a href="https://github.com/avrdudes/avr-libc/"><h2>AVR-LibC Development Pages</h2></a></td>
  </tr>
  <tr>
    <td align="center" width="15%"><a href="index.html"><h2>Main Page</h2></a></td>
    <td align="center" width="15%"><a href="pages.html"><h2>User Manual</h2></a></td>
    <td align="center" width="15%"><a href="modules.html"><h2>Library Refe&shy;rence</h2></a></td>
    <td align="center" width="8%"><a href="FAQ.html"><h2>FAQ</h2></a></td>
    <td align="center" width="15%"><a href="group__demos.html"><h2>Example Projects</h2></a></td>
    <td align="center" width="8%"><a href="files.html"><h2>File List</h2></a></td>
    <td align="center" width="8%"><a href="Global_01Index.html"><h2>Index</h2></a></td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">&lt;stdlib.h&gt;: General utilities</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdiv__t.html">div_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structldiv__t.html">ldiv_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga687984f47d8cce148d1b914d2b79612a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga687984f47d8cce148d1b914d2b79612a">EXIT_SUCCESS</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga687984f47d8cce148d1b914d2b79612a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73efe787c131b385070f25d18b7c9aa4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga73efe787c131b385070f25d18b7c9aa4">EXIT_FAILURE</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga73efe787c131b385070f25d18b7c9aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga690f251553b39fd4f31894826141b61a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga690f251553b39fd4f31894826141b61a">RAND_MAX</a>&#160;&#160;&#160;0x7FFF</td></tr>
<tr class="separator:ga690f251553b39fd4f31894826141b61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga35e28bfcc8d641e0eebd66f4dc559a3f"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga35e28bfcc8d641e0eebd66f4dc559a3f">__compar_fn_t</a>) (const void *, const void *)</td></tr>
<tr class="separator:ga35e28bfcc8d641e0eebd66f4dc559a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8dec7c95227ff149687066cf04029191"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga8dec7c95227ff149687066cf04029191">abort</a> (void)</td></tr>
<tr class="separator:ga8dec7c95227ff149687066cf04029191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb8c83badc195efc1229799391fececc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gadb8c83badc195efc1229799391fececc">abs</a> (int __i)</td></tr>
<tr class="separator:gadb8c83badc195efc1229799391fececc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae017047d6d0a688ccb622ff062dcd230"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gae017047d6d0a688ccb622ff062dcd230">labs</a> (long __i)</td></tr>
<tr class="separator:gae017047d6d0a688ccb622ff062dcd230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f6b867ea6ce0dc4de2b01e949ac3d5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gaf6f6b867ea6ce0dc4de2b01e949ac3d5">bsearch</a> (const void *__key, const void *__base, size_t __nmemb, size_t __size, int(*__compar)(const void *, const void *))</td></tr>
<tr class="separator:gaf6f6b867ea6ce0dc4de2b01e949ac3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7486ea9a8a90ac6b93bed37d08ebbd9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdiv__t.html">div_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga7486ea9a8a90ac6b93bed37d08ebbd9e">div</a> (int __num, int __denom) __asm__(&quot;__divmodhi4&quot;)</td></tr>
<tr class="separator:ga7486ea9a8a90ac6b93bed37d08ebbd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b688b463f9faaa82f31ac7587e06849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structldiv__t.html">ldiv_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga5b688b463f9faaa82f31ac7587e06849">ldiv</a> (long __num, long __denom) __asm__(&quot;__divmodsi4&quot;)</td></tr>
<tr class="separator:ga5b688b463f9faaa82f31ac7587e06849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd4bf2faec43342e7ad3d2ab37bac1fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gafd4bf2faec43342e7ad3d2ab37bac1fe">qsort</a> (void *__base, size_t __nmemb, size_t __size, <a class="el" href="group__avr__stdlib.html#ga35e28bfcc8d641e0eebd66f4dc559a3f">__compar_fn_t</a> __compar)</td></tr>
<tr class="separator:gafd4bf2faec43342e7ad3d2ab37bac1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8ce3b8dae3d45c34c3b172de503f7b3"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gaf8ce3b8dae3d45c34c3b172de503f7b3">strtol</a> (const char *__nptr, char **__endptr, int __base)</td></tr>
<tr class="separator:gaf8ce3b8dae3d45c34c3b172de503f7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5006f43088ee0321cf6191ce89eb78b7"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga5006f43088ee0321cf6191ce89eb78b7">strtoll</a> (const char *__nptr, char **__endptr, int __base)</td></tr>
<tr class="separator:ga5006f43088ee0321cf6191ce89eb78b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea44aa48bda8261f794dcb2d1e7ab2b2"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gaea44aa48bda8261f794dcb2d1e7ab2b2">strtoul</a> (const char *__nptr, char **__endptr, int __base)</td></tr>
<tr class="separator:gaea44aa48bda8261f794dcb2d1e7ab2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e125b8f54ff186f1627cfea739764f1"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga1e125b8f54ff186f1627cfea739764f1">strtoull</a> (const char *__nptr, char **__endptr, int __base)</td></tr>
<tr class="separator:ga1e125b8f54ff186f1627cfea739764f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15ac025af527b5ecc2e15e114297a890"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga15ac025af527b5ecc2e15e114297a890">atol</a> (const char *__s)</td></tr>
<tr class="separator:ga15ac025af527b5ecc2e15e114297a890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644e59f576ae3cda834cdbcf81f65f29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga644e59f576ae3cda834cdbcf81f65f29">atoi</a> (const char *__s)</td></tr>
<tr class="separator:ga644e59f576ae3cda834cdbcf81f65f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga037e1211798125c945a26bfbfdf26b8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga037e1211798125c945a26bfbfdf26b8f">exit</a> (int __status)</td></tr>
<tr class="separator:ga037e1211798125c945a26bfbfdf26b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97271fab94fab20520a8629621431de"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gab97271fab94fab20520a8629621431de">malloc</a> (size_t __size)</td></tr>
<tr class="separator:gab97271fab94fab20520a8629621431de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb8699abb1f51d920a176e695ff3be8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gafb8699abb1f51d920a176e695ff3be8a">free</a> (void *__ptr)</td></tr>
<tr class="separator:gafb8699abb1f51d920a176e695ff3be8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62994ba3ce84fed8a5481ab68e71a963"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga62994ba3ce84fed8a5481ab68e71a963">calloc</a> (size_t __nele, size_t __size)</td></tr>
<tr class="separator:ga62994ba3ce84fed8a5481ab68e71a963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf145dbe75eee95212f77da6826eb7d4e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gaf145dbe75eee95212f77da6826eb7d4e">realloc</a> (void *__ptr, size_t __size)</td></tr>
<tr class="separator:gaf145dbe75eee95212f77da6826eb7d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga699a1d102f9ea32765752559f978a590"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga699a1d102f9ea32765752559f978a590">strtof</a> (const char *__nptr, char **__endptr)</td></tr>
<tr class="separator:ga699a1d102f9ea32765752559f978a590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee4d110a3bb55d2eadda05e3ebedf8a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga5ee4d110a3bb55d2eadda05e3ebedf8a">strtod</a> (const char *__nptr, char **__endptr)</td></tr>
<tr class="separator:ga5ee4d110a3bb55d2eadda05e3ebedf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61043ae34c33c61780a2d9c52f065782"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga61043ae34c33c61780a2d9c52f065782">strtold</a> (const char *__nptr, char **__endptr)</td></tr>
<tr class="separator:ga61043ae34c33c61780a2d9c52f065782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd89c82095df80e5e12d6b2834a2acc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga7fd89c82095df80e5e12d6b2834a2acc">atexit</a> (void(*func)(void))</td></tr>
<tr class="separator:ga7fd89c82095df80e5e12d6b2834a2acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4ac57d05ab8e485c697da461745fb64"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gae4ac57d05ab8e485c697da461745fb64">atoff</a> (const char *__nptr)</td></tr>
<tr class="separator:gae4ac57d05ab8e485c697da461745fb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga689c9d3c4c04463aa31d329937789d06"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga689c9d3c4c04463aa31d329937789d06">atof</a> (const char *__nptr)</td></tr>
<tr class="separator:ga689c9d3c4c04463aa31d329937789d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c75fbb14d85d07354609ac96d7aa7d3"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga2c75fbb14d85d07354609ac96d7aa7d3">atofl</a> (const char *__nptr)</td></tr>
<tr class="separator:ga2c75fbb14d85d07354609ac96d7aa7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae23144bcbb8e3742b00eb687c36654d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gae23144bcbb8e3742b00eb687c36654d1">rand</a> (void)</td></tr>
<tr class="separator:gae23144bcbb8e3742b00eb687c36654d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacceff9dc95bb3c5562dc9e61fc3d9075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gacceff9dc95bb3c5562dc9e61fc3d9075">srand</a> (unsigned int __seed)</td></tr>
<tr class="separator:gacceff9dc95bb3c5562dc9e61fc3d9075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5085001be836a0f2a5d3269a7c9fd04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gaf5085001be836a0f2a5d3269a7c9fd04">rand_r</a> (unsigned long *__ctx)</td></tr>
<tr class="separator:gaf5085001be836a0f2a5d3269a7c9fd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaffadd67736fd340e893fb22c207de597"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gaffadd67736fd340e893fb22c207de597">__malloc_margin</a></td></tr>
<tr class="separator:gaffadd67736fd340e893fb22c207de597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9310042b3956282440c091d20cb98c5f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga9310042b3956282440c091d20cb98c5f">__malloc_heap_start</a></td></tr>
<tr class="separator:ga9310042b3956282440c091d20cb98c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d7b1bf0f75d529cc75229a266132115"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga4d7b1bf0f75d529cc75229a266132115">__malloc_heap_end</a></td></tr>
<tr class="separator:ga4d7b1bf0f75d529cc75229a266132115"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Non-standard (i.e. non-ISO C) functions.</h2></td></tr>
<tr class="memitem:ga0fd3ced14fa7c0d51d59a00efcdbbfc7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga0fd3ced14fa7c0d51d59a00efcdbbfc7">ltoa</a> (long val, char *s, int radix)</td></tr>
<tr class="separator:ga0fd3ced14fa7c0d51d59a00efcdbbfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae73ba2b460809c0b7fee30ffe347083c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gae73ba2b460809c0b7fee30ffe347083c">utoa</a> (unsigned int val, char *s, int radix)</td></tr>
<tr class="separator:gae73ba2b460809c0b7fee30ffe347083c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfc2bdc0b74aaeba28efe5af3085a89f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gadfc2bdc0b74aaeba28efe5af3085a89f">ultoa</a> (unsigned long val, char *s, int radix)</td></tr>
<tr class="separator:gadfc2bdc0b74aaeba28efe5af3085a89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab47b5d70f2429fb71c84dac6743f1819"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gab47b5d70f2429fb71c84dac6743f1819">ulltoa</a> (unsigned long long val, char *s, int radix)</td></tr>
<tr class="separator:gab47b5d70f2429fb71c84dac6743f1819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce93a5610dfd2c4c482b52fb363be47"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga2ce93a5610dfd2c4c482b52fb363be47">ulltoa_base10</a> (unsigned long long val, char *s)</td></tr>
<tr class="separator:ga2ce93a5610dfd2c4c482b52fb363be47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3f54f0f4d5418ac640eb53d9fc067e6"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gab3f54f0f4d5418ac640eb53d9fc067e6">lltoa</a> (long long val, char *s, int radix)</td></tr>
<tr class="separator:gab3f54f0f4d5418ac640eb53d9fc067e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga114aeb1751119382aaf3340355b22cfd"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga114aeb1751119382aaf3340355b22cfd">random</a> (void)</td></tr>
<tr class="separator:ga114aeb1751119382aaf3340355b22cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fca27496ca29c0a723d197696641eff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga4fca27496ca29c0a723d197696641eff">srandom</a> (unsigned long __seed)</td></tr>
<tr class="separator:ga4fca27496ca29c0a723d197696641eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa99a0733f06d2b9960a1401c2721af1e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gaa99a0733f06d2b9960a1401c2721af1e">random_r</a> (unsigned long *__ctx)</td></tr>
<tr class="separator:gaa99a0733f06d2b9960a1401c2721af1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfa0628fac4940c39a8a81947a6c116f"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gacfa0628fac4940c39a8a81947a6c116f">sqrtu16_floor</a> (unsigned int radic)</td></tr>
<tr class="separator:gacfa0628fac4940c39a8a81947a6c116f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a277fdc08e38ae3a42938db099298f7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga5a277fdc08e38ae3a42938db099298f7">sqrtu32_floor</a> (unsigned long radic)</td></tr>
<tr class="separator:ga5a277fdc08e38ae3a42938db099298f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9396cd11c895591e6bb051d121a6db0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gaa9396cd11c895591e6bb051d121a6db0">itoa</a> (int val, char *s, int radix)</td></tr>
<tr class="separator:gaa9396cd11c895591e6bb051d121a6db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd31f0d9a9127548b734e7ca03cc6df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga3bd31f0d9a9127548b734e7ca03cc6df">RANDOM_MAX</a>&#160;&#160;&#160;0x7FFFFFFF</td></tr>
<tr class="separator:ga3bd31f0d9a9127548b734e7ca03cc6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Conversion functions for double arguments.</h2></td></tr>
<tr class="memitem:ga0ae16bbdf51c0be563cfff9d6c05d8f1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga0ae16bbdf51c0be563cfff9d6c05d8f1">ftostre</a> (float __val, char *__s, unsigned char __prec, unsigned char __flags)</td></tr>
<tr class="separator:ga0ae16bbdf51c0be563cfff9d6c05d8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f07a282f28b2754b0e1d23679fc92c5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga3f07a282f28b2754b0e1d23679fc92c5">dtostre</a> (double __val, char *__s, unsigned char __prec, unsigned char __flags)</td></tr>
<tr class="separator:ga3f07a282f28b2754b0e1d23679fc92c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8741c23a75d598221ca983f7599bce0f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga8741c23a75d598221ca983f7599bce0f">ldtostre</a> (long double __val, char *__s, unsigned char __prec, unsigned char __flags)</td></tr>
<tr class="separator:ga8741c23a75d598221ca983f7599bce0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc15e117d82b6b613b2d3874d5ad951b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#gadc15e117d82b6b613b2d3874d5ad951b">ftostrf</a> (float __val, signed char __width, unsigned char __prec, char *__s)</td></tr>
<tr class="separator:gadc15e117d82b6b613b2d3874d5ad951b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c4fb1dcdd7424b5fb1ad197a9ac2992"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga7c4fb1dcdd7424b5fb1ad197a9ac2992">dtostrf</a> (double __val, signed char __width, unsigned char __prec, char *__s)</td></tr>
<tr class="separator:ga7c4fb1dcdd7424b5fb1ad197a9ac2992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8b4fe3639157dbb90ea78d480b01fb"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga0b8b4fe3639157dbb90ea78d480b01fb">ldtostrf</a> (long double __val, signed char __width, unsigned char __prec, char *__s)</td></tr>
<tr class="separator:ga0b8b4fe3639157dbb90ea78d480b01fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga815d0d26e215d9b78af1cb2288d22361"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga815d0d26e215d9b78af1cb2288d22361">DTOSTR_ALWAYS_SIGN</a>&#160;&#160;&#160;0x01        /* put '+' or ' ' for positives */</td></tr>
<tr class="separator:ga815d0d26e215d9b78af1cb2288d22361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga268774f80047812307365f3113109767"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga268774f80047812307365f3113109767">DTOSTR_PLUS_SIGN</a>&#160;&#160;&#160;0x02        /* put '+' rather than ' ' */</td></tr>
<tr class="separator:ga268774f80047812307365f3113109767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125348f1e1fed1793426f4c4dc6fb2f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdlib.html#ga125348f1e1fed1793426f4c4dc6fb2f7">DTOSTR_UPPERCASE</a>&#160;&#160;&#160;0x04        /* put 'E' rather 'e' */</td></tr>
<tr class="separator:ga125348f1e1fed1793426f4c4dc6fb2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdlib_8h.html">stdlib.h</a>&gt;</span> </div>
<div class="ttc" id="astdlib_8h_html"><div class="ttname"><a href="stdlib_8h.html">stdlib.h</a></div></div>
</div><!-- fragment --><p>This file declares some basic C macros and functions as defined by the ISO standard, plus some AVR-specific extensions.</p>
<p>For some functions, <a class="el" href="benchmarks.html#bench_libc">benchmarks</a> are available. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga815d0d26e215d9b78af1cb2288d22361" name="ga815d0d26e215d9b78af1cb2288d22361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga815d0d26e215d9b78af1cb2288d22361">&#9670;&#160;</a></span>DTOSTR_ALWAYS_SIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DTOSTR_ALWAYS_SIGN&#160;&#160;&#160;0x01        /* put '+' or ' ' for positives */</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bit value that can be passed in <code>flags</code> to <a class="el" href="group__avr__stdlib.html#ga0ae16bbdf51c0be563cfff9d6c05d8f1">ftostre()</a>, <a class="el" href="group__avr__stdlib.html#ga3f07a282f28b2754b0e1d23679fc92c5">dtostre()</a> and <a class="el" href="group__avr__stdlib.html#ga8741c23a75d598221ca983f7599bce0f">ldtostre()</a>. </p>

</div>
</div>
<a id="ga268774f80047812307365f3113109767" name="ga268774f80047812307365f3113109767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga268774f80047812307365f3113109767">&#9670;&#160;</a></span>DTOSTR_PLUS_SIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DTOSTR_PLUS_SIGN&#160;&#160;&#160;0x02        /* put '+' rather than ' ' */</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bit value that can be passed in <code>flags</code> to <a class="el" href="group__avr__stdlib.html#ga0ae16bbdf51c0be563cfff9d6c05d8f1">ftostre()</a>, <a class="el" href="group__avr__stdlib.html#ga3f07a282f28b2754b0e1d23679fc92c5">dtostre()</a> and <a class="el" href="group__avr__stdlib.html#ga8741c23a75d598221ca983f7599bce0f">ldtostre()</a>. </p>

</div>
</div>
<a id="ga125348f1e1fed1793426f4c4dc6fb2f7" name="ga125348f1e1fed1793426f4c4dc6fb2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga125348f1e1fed1793426f4c4dc6fb2f7">&#9670;&#160;</a></span>DTOSTR_UPPERCASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DTOSTR_UPPERCASE&#160;&#160;&#160;0x04        /* put 'E' rather 'e' */</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bit value that can be passed in <code>flags</code> to <a class="el" href="group__avr__stdlib.html#ga0ae16bbdf51c0be563cfff9d6c05d8f1">ftostre()</a>, <a class="el" href="group__avr__stdlib.html#ga3f07a282f28b2754b0e1d23679fc92c5">dtostre()</a> and <a class="el" href="group__avr__stdlib.html#ga8741c23a75d598221ca983f7599bce0f">ldtostre()</a>. </p>

</div>
</div>
<a id="ga73efe787c131b385070f25d18b7c9aa4" name="ga73efe787c131b385070f25d18b7c9aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73efe787c131b385070f25d18b7c9aa4">&#9670;&#160;</a></span>EXIT_FAILURE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXIT_FAILURE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unsuccessful termination for <a class="el" href="group__avr__stdlib.html#ga037e1211798125c945a26bfbfdf26b8f">exit()</a>; evaluates to a non-zero value. </p>

</div>
</div>
<a id="ga687984f47d8cce148d1b914d2b79612a" name="ga687984f47d8cce148d1b914d2b79612a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga687984f47d8cce148d1b914d2b79612a">&#9670;&#160;</a></span>EXIT_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXIT_SUCCESS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Successful termination for <a class="el" href="group__avr__stdlib.html#ga037e1211798125c945a26bfbfdf26b8f">exit()</a>; evaluates to 0. </p>

</div>
</div>
<a id="ga690f251553b39fd4f31894826141b61a" name="ga690f251553b39fd4f31894826141b61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga690f251553b39fd4f31894826141b61a">&#9670;&#160;</a></span>RAND_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RAND_MAX&#160;&#160;&#160;0x7FFF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Highest number that can be generated by <a class="el" href="group__avr__stdlib.html#gae23144bcbb8e3742b00eb687c36654d1">rand()</a>. </p>

</div>
</div>
<a id="ga3bd31f0d9a9127548b734e7ca03cc6df" name="ga3bd31f0d9a9127548b734e7ca03cc6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bd31f0d9a9127548b734e7ca03cc6df">&#9670;&#160;</a></span>RANDOM_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RANDOM_MAX&#160;&#160;&#160;0x7FFFFFFF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Highest number that can be generated by <a class="el" href="group__avr__stdlib.html#ga114aeb1751119382aaf3340355b22cfd">random()</a>. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga35e28bfcc8d641e0eebd66f4dc559a3f" name="ga35e28bfcc8d641e0eebd66f4dc559a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35e28bfcc8d641e0eebd66f4dc559a3f">&#9670;&#160;</a></span>__compar_fn_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* __compar_fn_t) (const void *, const void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparision function type for <a class="el" href="group__avr__stdlib.html#gafd4bf2faec43342e7ad3d2ab37bac1fe">qsort()</a>, just for convenience. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8dec7c95227ff149687066cf04029191" name="ga8dec7c95227ff149687066cf04029191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dec7c95227ff149687066cf04029191">&#9670;&#160;</a></span>abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void abort </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga8dec7c95227ff149687066cf04029191">abort()</a> function causes abnormal program termination to occur. This realization disables interrupts and jumps to _exit() function with argument equal to 1. In the limited AVR environment, execution is effectively halted by entering an infinite loop. </p>

</div>
</div>
<a id="gadb8c83badc195efc1229799391fececc" name="gadb8c83badc195efc1229799391fececc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb8c83badc195efc1229799391fececc">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int abs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>__i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#gadb8c83badc195efc1229799391fececc">abs()</a> function computes the absolute value of the integer <code>i</code>. </p><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group__avr__stdlib.html#gadb8c83badc195efc1229799391fececc">abs()</a> and <a class="el" href="group__avr__stdlib.html#gae017047d6d0a688ccb622ff062dcd230">labs()</a> functions are builtins of gcc. </dd></dl>

</div>
</div>
<a id="ga7fd89c82095df80e5e12d6b2834a2acc" name="ga7fd89c82095df80e5e12d6b2834a2acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fd89c82095df80e5e12d6b2834a2acc">&#9670;&#160;</a></span>atexit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int atexit </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga7fd89c82095df80e5e12d6b2834a2acc">atexit()</a> function registers function <em>func</em> to be run as part of the <code><a class="el" href="group__avr__stdlib.html#ga037e1211798125c945a26bfbfdf26b8f">exit()</a></code> function during <a class="el" href="mem_sections.html#sec_dot_fini">.fini8</a>. <a class="el" href="group__avr__stdlib.html#ga7fd89c82095df80e5e12d6b2834a2acc">atexit()</a> calls malloc(). </p>

</div>
</div>
<a id="ga689c9d3c4c04463aa31d329937789d06" name="ga689c9d3c4c04463aa31d329937789d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga689c9d3c4c04463aa31d329937789d06">&#9670;&#160;</a></span>atof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double atof </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga689c9d3c4c04463aa31d329937789d06">atof()</a> function converts the initial portion of the string pointed to by <em>nptr</em> to <code>double</code> representation.</p>
<p>It is equivalent to calling </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__avr__stdlib.html#ga5ee4d110a3bb55d2eadda05e3ebedf8a">strtod</a>(nptr, (<span class="keywordtype">char</span>**) 0); </div>
<div class="ttc" id="agroup__avr__stdlib_html_ga5ee4d110a3bb55d2eadda05e3ebedf8a"><div class="ttname"><a href="group__avr__stdlib.html#ga5ee4d110a3bb55d2eadda05e3ebedf8a">strtod</a></div><div class="ttdeci">double strtod(const char *__nptr, char **__endptr)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gae4ac57d05ab8e485c697da461745fb64" name="gae4ac57d05ab8e485c697da461745fb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4ac57d05ab8e485c697da461745fb64">&#9670;&#160;</a></span>atoff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float atoff </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#gae4ac57d05ab8e485c697da461745fb64">atoff()</a> function converts the initial portion of the string pointed to by <em>nptr</em> to <code>float</code> representation.</p>
<p>It is equivalent to calling </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__avr__stdlib.html#ga699a1d102f9ea32765752559f978a590">strtof</a>(nptr, (<span class="keywordtype">char</span>**) 0); </div>
<div class="ttc" id="agroup__avr__stdlib_html_ga699a1d102f9ea32765752559f978a590"><div class="ttname"><a href="group__avr__stdlib.html#ga699a1d102f9ea32765752559f978a590">strtof</a></div><div class="ttdeci">float strtof(const char *__nptr, char **__endptr)</div><div class="ttdef"><b>Definition:</b> strtod.c:120</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga2c75fbb14d85d07354609ac96d7aa7d3" name="ga2c75fbb14d85d07354609ac96d7aa7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c75fbb14d85d07354609ac96d7aa7d3">&#9670;&#160;</a></span>atofl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double atofl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga2c75fbb14d85d07354609ac96d7aa7d3">atofl()</a> function converts the initial portion of the string pointed to by <em>nptr</em> to <code>long</code> <code>double</code> representation.</p>
<p>It is equivalent to calling </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__avr__stdlib.html#ga61043ae34c33c61780a2d9c52f065782">strtold</a>(nptr, (<span class="keywordtype">char</span>**) 0); </div>
<div class="ttc" id="agroup__avr__stdlib_html_ga61043ae34c33c61780a2d9c52f065782"><div class="ttname"><a href="group__avr__stdlib.html#ga61043ae34c33c61780a2d9c52f065782">strtold</a></div><div class="ttdeci">long double strtold(const char *__nptr, char **__endptr)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga644e59f576ae3cda834cdbcf81f65f29" name="ga644e59f576ae3cda834cdbcf81f65f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga644e59f576ae3cda834cdbcf81f65f29">&#9670;&#160;</a></span>atoi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int atoi </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>__s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga644e59f576ae3cda834cdbcf81f65f29">atoi()</a> function converts the initial portion of the string pointed to by <code>s</code> to integer representation. In contrast to</p>
<div class="fragment"><div class="line">(int)<a class="code hl_function" href="group__avr__stdlib.html#gaf8ce3b8dae3d45c34c3b172de503f7b3">strtol</a>(s, (<span class="keywordtype">char</span> **)NULL, 10); </div>
<div class="ttc" id="agroup__avr__stdlib_html_gaf8ce3b8dae3d45c34c3b172de503f7b3"><div class="ttname"><a href="group__avr__stdlib.html#gaf8ce3b8dae3d45c34c3b172de503f7b3">strtol</a></div><div class="ttdeci">long strtol(const char *__nptr, char **__endptr, int __base)</div></div>
</div><!-- fragment --><p>this function does not detect overflow (<code>errno</code> is not changed and the result value is not predictable), uses smaller memory (flash and stack) and works more quickly. </p>

</div>
</div>
<a id="ga15ac025af527b5ecc2e15e114297a890" name="ga15ac025af527b5ecc2e15e114297a890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15ac025af527b5ecc2e15e114297a890">&#9670;&#160;</a></span>atol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long atol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>__s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga15ac025af527b5ecc2e15e114297a890">atol()</a> function converts the initial portion of the string pointed to by <code>s</code> to long integer representation. In contrast to</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__avr__stdlib.html#gaf8ce3b8dae3d45c34c3b172de503f7b3">strtol</a>(s, (<span class="keywordtype">char</span> **)NULL, 10); </div>
</div><!-- fragment --><p>this function does not detect overflow (<code>errno</code> is not changed and the result value is not predictable), uses smaller memory (flash and stack) and works more quickly. </p>

</div>
</div>
<a id="gaf6f6b867ea6ce0dc4de2b01e949ac3d5" name="gaf6f6b867ea6ce0dc4de2b01e949ac3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6f6b867ea6ce0dc4de2b01e949ac3d5">&#9670;&#160;</a></span>bsearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * bsearch </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>__key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>__base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>__nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>__size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>__compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#gaf6f6b867ea6ce0dc4de2b01e949ac3d5">bsearch()</a> function searches an array of <code>nmemb</code> objects, the initial member of which is pointed to by <code>base</code>, for a member that matches the object pointed to by <code>key</code>. The size of each member of the array is specified by <code>size</code>.</p>
<p>The contents of the array should be in ascending sorted order according to the comparison function referenced by <code>compar</code>. The <code>compar</code> routine is expected to have two arguments which point to the key object and to an array member, in that order, and should return an integer less than, equal to, or greater than zero if the key object is found, respectively, to be less than, to match, or be greater than the array member.</p>
<p>The <a class="el" href="group__avr__stdlib.html#gaf6f6b867ea6ce0dc4de2b01e949ac3d5">bsearch()</a> function returns a pointer to a matching member of the array, or a null pointer if no match is found. If two members compare as equal, which member is matched is unspecified. </p>

</div>
</div>
<a id="ga62994ba3ce84fed8a5481ab68e71a963" name="ga62994ba3ce84fed8a5481ab68e71a963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62994ba3ce84fed8a5481ab68e71a963">&#9670;&#160;</a></span>calloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * calloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>__nele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>__size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate <code>nele</code> elements of <code>size</code> each. Identical to calling <code>malloc()</code> using <code>nele * size</code> as argument, except the allocated memory will be cleared to zero. </p>

</div>
</div>
<a id="ga7486ea9a8a90ac6b93bed37d08ebbd9e" name="ga7486ea9a8a90ac6b93bed37d08ebbd9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7486ea9a8a90ac6b93bed37d08ebbd9e">&#9670;&#160;</a></span>div()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdiv__t.html">div_t</a> div </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>__num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>__denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga7486ea9a8a90ac6b93bed37d08ebbd9e">div()</a> function computes the value <code>num/denom</code> and returns the quotient and remainder in a structure named <code><a class="el" href="structdiv__t.html">div_t</a></code> that contains two int members named <code>quot</code> and <code>rem</code>. </p>

</div>
</div>
<a id="ga3f07a282f28b2754b0e1d23679fc92c5" name="ga3f07a282f28b2754b0e1d23679fc92c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f07a282f28b2754b0e1d23679fc92c5">&#9670;&#160;</a></span>dtostre()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * dtostre </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>__val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>__s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>__prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>__flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga3f07a282f28b2754b0e1d23679fc92c5">dtostre()</a> function is similar to the <a class="el" href="group__avr__stdlib.html#ga0ae16bbdf51c0be563cfff9d6c05d8f1">ftostre()</a> function, except that it converts a <code>double</code> value instead of a <code>float</code> value.</p>
<p><a class="el" href="group__avr__stdlib.html#ga3f07a282f28b2754b0e1d23679fc92c5">dtostre()</a> is currently only supported when <code>double</code> is a 32-bit type. </p>

</div>
</div>
<a id="ga7c4fb1dcdd7424b5fb1ad197a9ac2992" name="ga7c4fb1dcdd7424b5fb1ad197a9ac2992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c4fb1dcdd7424b5fb1ad197a9ac2992">&#9670;&#160;</a></span>dtostrf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * dtostrf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>__val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char&#160;</td>
          <td class="paramname"><em>__width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>__prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>__s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga7c4fb1dcdd7424b5fb1ad197a9ac2992">dtostrf()</a> function is similar to the <a class="el" href="group__avr__stdlib.html#gadc15e117d82b6b613b2d3874d5ad951b">ftostrf()</a> function, except that converts a <code>double</code> value instead of a <code>float</code> value.</p>
<p><a class="el" href="group__avr__stdlib.html#ga8741c23a75d598221ca983f7599bce0f">ldtostre()</a> is currently only supported when <code>double</code> is a 32-bit type. </p>

</div>
</div>
<a id="ga037e1211798125c945a26bfbfdf26b8f" name="ga037e1211798125c945a26bfbfdf26b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga037e1211798125c945a26bfbfdf26b8f">&#9670;&#160;</a></span>exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void exit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>__status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga037e1211798125c945a26bfbfdf26b8f">exit()</a> function terminates the application. Since there is no environment to return to, <code>status</code> is ignored, and code execution will eventually reach an infinite loop, thereby effectively halting all code processing. Before entering the infinite loop, interrupts are globally disabled.</p>
<p>Global destructors will be called before halting execution, see the <a class="el" href="mem_sections.html#sec_dot_fini">.fini</a> sections. </p>

</div>
</div>
<a id="gafb8699abb1f51d920a176e695ff3be8a" name="gafb8699abb1f51d920a176e695ff3be8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb8699abb1f51d920a176e695ff3be8a">&#9670;&#160;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>__ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The free() function causes the allocated memory referenced by <code>ptr</code> to be made available for future allocations. If <code>ptr</code> is NULL, no action occurs. </p>

</div>
</div>
<a id="ga0ae16bbdf51c0be563cfff9d6c05d8f1" name="ga0ae16bbdf51c0be563cfff9d6c05d8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ae16bbdf51c0be563cfff9d6c05d8f1">&#9670;&#160;</a></span>ftostre()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ftostre </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>__val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>__s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>__prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>__flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga0ae16bbdf51c0be563cfff9d6c05d8f1">ftostre()</a> function converts the <code>float</code> value passed in <code>val</code> into an ASCII representation that will be stored under <code>s</code>. The caller is responsible for providing sufficient storage in <code>s</code>.</p>
<p>Conversion is done in the format <code>&quot;[-]d.ddde&plusmn;dd&quot;</code> where there is one digit before the decimal-point character and the number of digits after it is equal to the precision <code>prec</code>; if the precision is zero, no decimal-point character appears. If <code>flags</code> has the <a class="el" href="group__avr__stdlib.html#ga125348f1e1fed1793426f4c4dc6fb2f7">DTOSTR_UPPERCASE</a> bit set, the letter <code>'E'</code> (rather than <code>'e'</code> ) will be used to introduce the exponent. The exponent always contains two digits; if the value is zero, the exponent is <code>"00"</code>.</p>
<p>If <code>flags</code> has the <a class="el" href="group__avr__stdlib.html#ga815d0d26e215d9b78af1cb2288d22361">DTOSTR_ALWAYS_SIGN</a> bit set, a space character will be placed into the leading position for positive numbers.</p>
<p>If <code>flags</code> has the <a class="el" href="group__avr__stdlib.html#ga268774f80047812307365f3113109767">DTOSTR_PLUS_SIGN</a> bit set, a plus sign will be used instead of a space character in this case.</p>
<p>The <a class="el" href="group__avr__stdlib.html#ga0ae16bbdf51c0be563cfff9d6c05d8f1">ftostre()</a> function returns the pointer to the converted string <code>s</code>. </p>

</div>
</div>
<a id="gadc15e117d82b6b613b2d3874d5ad951b" name="gadc15e117d82b6b613b2d3874d5ad951b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc15e117d82b6b613b2d3874d5ad951b">&#9670;&#160;</a></span>ftostrf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ftostrf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>__val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char&#160;</td>
          <td class="paramname"><em>__width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>__prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>__s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#gadc15e117d82b6b613b2d3874d5ad951b">ftostrf()</a> function converts the <code>float</code> value passed in <code>val</code> into an ASCII representation that will be stored in <code>s</code>. The caller is responsible for providing sufficient storage in <code>s</code>.</p>
<p>Conversion is done in the format <code>"[-]d.ddd"</code>. The minimum field width of the output string (including the possible <code>'</code>.' and the possible sign for negative values) is given in <code>width</code>, and <code>prec</code> determines the number of digits after the decimal sign. <code>width</code> is signed value, negative for left adjustment.</p>
<p>The <a class="el" href="group__avr__stdlib.html#gadc15e117d82b6b613b2d3874d5ad951b">ftostrf()</a> function returns the pointer to the converted string <code>s</code>. </p>

</div>
</div>
<a id="gaa9396cd11c895591e6bb051d121a6db0" name="gaa9396cd11c895591e6bb051d121a6db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9396cd11c895591e6bb051d121a6db0">&#9670;&#160;</a></span>itoa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * itoa </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an integer to a string. </p>
<p>The function <a class="el" href="group__avr__stdlib.html#gaa9396cd11c895591e6bb051d121a6db0" title="Convert an integer to a string.">itoa()</a> converts the integer value from <code>val</code> into an ASCII representation that will be stored under <code>s</code>. The caller is responsible for providing sufficient storage in <code>s</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The minimal size of the buffer <code>s</code> depends on the choice of radix. For example, if the radix is 2 (binary), you need to supply a buffer with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one character for each bit plus one for the string terminator. Using a larger radix will require a smaller minimal buffer size.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the buffer is too small, you risk a buffer overflow.</dd></dl>
<p>Conversion is done using the <code>radix</code> as base, which may be a number between 2 (binary conversion) and up to 36. If <code>radix</code> is greater than 10, the next digit after <code>'9'</code> will be the letter <code>'a'</code>.</p>
<p>If radix is 10 and val is negative, a minus sign will be prepended.</p>
<p>The <a class="el" href="group__avr__stdlib.html#gaa9396cd11c895591e6bb051d121a6db0" title="Convert an integer to a string.">itoa()</a> function returns the pointer passed as <code>s</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Decimal conversions can be sped up by using the <a class="el" href="group__avr__stdfix.html#ga6fa7b06670f1241ab1d05be4a33f5465">ktoa()</a> function from <a class="el" href="group__avr__stdfix.html">&lt;stdfix.h&gt;</a> that converts fixed-point values to decimal ASCII, like in <code>ktoa((accum) val, s, FXTOA_TRUNC)</code> that converts <code>val</code> to a decimal ASCII representation with zero fractional digits. For example, converting 1000 using <a class="el" href="group__avr__stdlib.html#gaa9396cd11c895591e6bb051d121a6db0" title="Convert an integer to a string.">itoa()</a> takes around 700 cycles whereas <a class="el" href="group__avr__stdfix.html#ga6fa7b06670f1241ab1d05be4a33f5465">ktoa()</a> does the job in less than 300 cycles. </dd></dl>

</div>
</div>
<a id="gae017047d6d0a688ccb622ff062dcd230" name="gae017047d6d0a688ccb622ff062dcd230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae017047d6d0a688ccb622ff062dcd230">&#9670;&#160;</a></span>labs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long labs </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>__i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#gae017047d6d0a688ccb622ff062dcd230">labs()</a> function computes the absolute value of the long integer <code>i</code>. </p><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group__avr__stdlib.html#gadb8c83badc195efc1229799391fececc">abs()</a> and <a class="el" href="group__avr__stdlib.html#gae017047d6d0a688ccb622ff062dcd230">labs()</a> functions are builtins of gcc. </dd></dl>

</div>
</div>
<a id="ga5b688b463f9faaa82f31ac7587e06849" name="ga5b688b463f9faaa82f31ac7587e06849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b688b463f9faaa82f31ac7587e06849">&#9670;&#160;</a></span>ldiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structldiv__t.html">ldiv_t</a> ldiv </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>__num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>__denom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga5b688b463f9faaa82f31ac7587e06849">ldiv()</a> function computes the value <code>num/denom</code> and returns the quotient and remainder in a structure named <code><a class="el" href="structldiv__t.html">ldiv_t</a></code> that contains two long integer members named <code>quot</code> and <code>rem</code>. </p>

</div>
</div>
<a id="ga8741c23a75d598221ca983f7599bce0f" name="ga8741c23a75d598221ca983f7599bce0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8741c23a75d598221ca983f7599bce0f">&#9670;&#160;</a></span>ldtostre()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ldtostre </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>__val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>__s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>__prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>__flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga8741c23a75d598221ca983f7599bce0f">ldtostre()</a> function is similar to the <a class="el" href="group__avr__stdlib.html#ga0ae16bbdf51c0be563cfff9d6c05d8f1">ftostre()</a> function, except that it converts a <code>long</code> <code>double</code> value instead of a <code>float</code> value.</p>
<p><a class="el" href="group__avr__stdlib.html#ga8741c23a75d598221ca983f7599bce0f">ldtostre()</a> is currently only supported when <code>long</code> <code>double</code> is a 32-bit type. </p>

</div>
</div>
<a id="ga0b8b4fe3639157dbb90ea78d480b01fb" name="ga0b8b4fe3639157dbb90ea78d480b01fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b8b4fe3639157dbb90ea78d480b01fb">&#9670;&#160;</a></span>ldtostrf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ldtostrf </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>__val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char&#160;</td>
          <td class="paramname"><em>__width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>__prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>__s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga0b8b4fe3639157dbb90ea78d480b01fb">ldtostrf()</a> function is similar to the <a class="el" href="group__avr__stdlib.html#gadc15e117d82b6b613b2d3874d5ad951b">ftostrf()</a> function, except that converts a <code>long</code> <code>double</code> value instead of a <code>float</code> value.</p>
<p><a class="el" href="group__avr__stdlib.html#ga8741c23a75d598221ca983f7599bce0f">ldtostre()</a> is currently only supported when <code>long</code> <code>double</code> is a 32-bit type. </p>

</div>
</div>
<a id="gab3f54f0f4d5418ac640eb53d9fc067e6" name="gab3f54f0f4d5418ac640eb53d9fc067e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3f54f0f4d5418ac640eb53d9fc067e6">&#9670;&#160;</a></span>lltoa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * lltoa </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a signed 64-bit integer to a string. </p>
<p>The function <a class="el" href="group__avr__stdlib.html#gab3f54f0f4d5418ac640eb53d9fc067e6" title="Convert a signed 64-bit integer to a string.">lltoa()</a> writes the ASCII representation of the signed 64-bit integer <code>val</code> to a string starting at <code>s</code>. Except for decimal conversions with a negative <code>val</code>, the effect is the same like with <code><a class="el" href="group__avr__stdlib.html#gab47b5d70f2429fb71c84dac6743f1819" title="Convert an unsigned 64-bit integer to a string.">ulltoa()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A signed 64-bit integral value for which the ASCII representation is computed.</td></tr>
    <tr><td class="paramname">s</td><td>The location to which the string representation should be stored. The caller is responsible for providing sufficient storage in <code>s</code>. The minimal size of the buffer <code>s</code> depends on the choice of the radix. For example, if the radix is 10 (decimal), the function will write at most 21 characters (including the terminating '\0').</td></tr>
    <tr><td class="paramname">radix</td><td>The Conversion is done using the <code>radix</code> as base, which may be a number between 2 (binary conversion) and up to 36. If <code>radix</code> is greater than 10, the next digit after <code>'9'</code> will be the letter <code>'a'</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__stdlib.html#gab3f54f0f4d5418ac640eb53d9fc067e6" title="Convert a signed 64-bit integer to a string.">lltoa()</a> function returns the pointer passed as <code>s</code>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>AVR-LibC v2.3 </dd></dl>

</div>
</div>
<a id="ga0fd3ced14fa7c0d51d59a00efcdbbfc7" name="ga0fd3ced14fa7c0d51d59a00efcdbbfc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fd3ced14fa7c0d51d59a00efcdbbfc7">&#9670;&#160;</a></span>ltoa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ltoa </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a long integer to a string. </p>
<p>The function <a class="el" href="group__avr__stdlib.html#ga0fd3ced14fa7c0d51d59a00efcdbbfc7" title="Convert a long integer to a string.">ltoa()</a> converts the long integer value from <code>val</code> into an ASCII representation that will be stored under <code>s</code>. The caller is responsible for providing sufficient storage in <code>s</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The minimal size of the buffer <code>s</code> depends on the choice of radix. For example, if the radix is 2 (binary), you need to supply a buffer with a minimal length of 8 * sizeof (long int) + 1 characters, i.e. one character for each bit plus one for the string terminator. Using a larger radix will require a smaller minimal buffer size.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the buffer is too small, you risk a buffer overflow.</dd></dl>
<p>Conversion is done using the <code>radix</code> as base, which may be a number between 2 (binary conversion) and up to 36. If <code>radix</code> is greater than 10, the next digit after <code>'9'</code> will be the letter <code>'a'</code>.</p>
<p>If radix is 10 and val is negative, a minus sign will be prepended.</p>
<p>The <a class="el" href="group__avr__stdlib.html#ga0fd3ced14fa7c0d51d59a00efcdbbfc7" title="Convert a long integer to a string.">ltoa()</a> function returns the pointer passed as <code>s</code>. </p>

</div>
</div>
<a id="gab97271fab94fab20520a8629621431de" name="gab97271fab94fab20520a8629621431de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab97271fab94fab20520a8629621431de">&#9670;&#160;</a></span>malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>__size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The malloc() function allocates <code>size</code> bytes of memory. If malloc() fails, a NULL pointer is returned.</p>
<p>Note that malloc() does <em>not</em> initialize the returned memory to zero bytes.</p>
<p>See the chapter about <a class="el" href="malloc.html">malloc() usage</a> for implementation details. </p>

</div>
</div>
<a id="gafd4bf2faec43342e7ad3d2ab37bac1fe" name="gafd4bf2faec43342e7ad3d2ab37bac1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd4bf2faec43342e7ad3d2ab37bac1fe">&#9670;&#160;</a></span>qsort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qsort </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>__base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>__nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>__size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__stdlib.html#ga35e28bfcc8d641e0eebd66f4dc559a3f">__compar_fn_t</a>&#160;</td>
          <td class="paramname"><em>__compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#gafd4bf2faec43342e7ad3d2ab37bac1fe">qsort()</a> function is a modified partition-exchange sort, or quicksort.</p>
<p>The <a class="el" href="group__avr__stdlib.html#gafd4bf2faec43342e7ad3d2ab37bac1fe">qsort()</a> function sorts an array of <code>nmemb</code> objects, the initial member of which is pointed to by <code>base</code>. The size of each object is specified by <code>size</code>. The contents of the array base are sorted in ascending order according to a comparison function pointed to by <code>compar</code>, which requires two arguments pointing to the objects being compared.</p>
<p>The comparison function must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second. </p>

</div>
</div>
<a id="gae23144bcbb8e3742b00eb687c36654d1" name="gae23144bcbb8e3742b00eb687c36654d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae23144bcbb8e3742b00eb687c36654d1">&#9670;&#160;</a></span>rand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rand </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#gae23144bcbb8e3742b00eb687c36654d1">rand()</a> function computes a sequence of pseudo-random integers in the range of 0 to <code>RAND_MAX</code> (as defined by the header file &lt;<a class="el" href="stdlib_8h.html">stdlib.h</a>&gt;).</p>
<p>The <a class="el" href="group__avr__stdlib.html#gacceff9dc95bb3c5562dc9e61fc3d9075">srand()</a> function sets its argument <code>seed</code> as the seed for a new sequence of pseudo-random numbers to be returned by <a class="el" href="group__avr__stdlib.html#gae23144bcbb8e3742b00eb687c36654d1">rand()</a>. These sequences are repeatable by calling <a class="el" href="group__avr__stdlib.html#gacceff9dc95bb3c5562dc9e61fc3d9075">srand()</a> with the same seed value.</p>
<p>If no seed value is provided, the functions are automatically seeded with a value of 1.</p>
<p>In compliance with the C standard, these functions operate on <code>int</code> arguments. Since the underlying algorithm already uses 32-bit calculations, this causes a loss of precision. See <code><a class="el" href="group__avr__stdlib.html#ga114aeb1751119382aaf3340355b22cfd">random()</a></code> for an alternate set of functions that retains full 32-bit precision. </p>

</div>
</div>
<a id="gaf5085001be836a0f2a5d3269a7c9fd04" name="gaf5085001be836a0f2a5d3269a7c9fd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5085001be836a0f2a5d3269a7c9fd04">&#9670;&#160;</a></span>rand_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rand_r </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>__ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variant of <a class="el" href="group__avr__stdlib.html#gae23144bcbb8e3742b00eb687c36654d1">rand()</a> that stores the context in the user-supplied variable located at <code>ctx</code> instead of a static library variable so the function becomes re-entrant. </p>

</div>
</div>
<a id="ga114aeb1751119382aaf3340355b22cfd" name="ga114aeb1751119382aaf3340355b22cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga114aeb1751119382aaf3340355b22cfd">&#9670;&#160;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long random </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga114aeb1751119382aaf3340355b22cfd">random()</a> function computes a sequence of pseudo-random integers in the range of 0 to <code>RANDOM_MAX</code> (as defined by the header file &lt;<a class="el" href="stdlib_8h.html">stdlib.h</a>&gt;).</p>
<p>The <a class="el" href="group__avr__stdlib.html#ga4fca27496ca29c0a723d197696641eff">srandom()</a> function sets its argument <code>seed</code> as the seed for a new sequence of pseudo-random numbers to be returned by <a class="el" href="group__avr__stdlib.html#gae23144bcbb8e3742b00eb687c36654d1">rand()</a>. These sequences are repeatable by calling <a class="el" href="group__avr__stdlib.html#ga4fca27496ca29c0a723d197696641eff">srandom()</a> with the same seed value.</p>
<p>If no seed value is provided, the functions are automatically seeded with a value of 1. </p>

</div>
</div>
<a id="gaa99a0733f06d2b9960a1401c2721af1e" name="gaa99a0733f06d2b9960a1401c2721af1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa99a0733f06d2b9960a1401c2721af1e">&#9670;&#160;</a></span>random_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long random_r </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>__ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variant of <a class="el" href="group__avr__stdlib.html#ga114aeb1751119382aaf3340355b22cfd">random()</a> that stores the context in the user-supplied variable located at <code>ctx</code> instead of a static library variable so the function becomes re-entrant. </p>

</div>
</div>
<a id="gaf145dbe75eee95212f77da6826eb7d4e" name="gaf145dbe75eee95212f77da6826eb7d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf145dbe75eee95212f77da6826eb7d4e">&#9670;&#160;</a></span>realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>__ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>__size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The realloc() function tries to change the size of the region allocated at <code>ptr</code> to the new <code>size</code> value. It returns a pointer to the new region. The returned pointer might be the same as the old pointer, or a pointer to a completely different region.</p>
<p>The contents of the returned region up to either the old or the new size value (whatever is less) will be identical to the contents of the old region, even in case a new region had to be allocated.</p>
<p>It is acceptable to pass <code>ptr</code> as NULL, in which case realloc() will behave identical to malloc().</p>
<p>If the new memory cannot be allocated, realloc() returns NULL, and the region at <code>ptr</code> will not be changed. </p>

</div>
</div>
<a id="gacfa0628fac4940c39a8a81947a6c116f" name="gacfa0628fac4940c39a8a81947a6c116f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfa0628fac4940c39a8a81947a6c116f">&#9670;&#160;</a></span>sqrtu16_floor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char sqrtu16_floor </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>radic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns the square root of the 16-bit value <code>radic</code>, rounded down to the next integral value. </dd></dl>

</div>
</div>
<a id="ga5a277fdc08e38ae3a42938db099298f7" name="ga5a277fdc08e38ae3a42938db099298f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a277fdc08e38ae3a42938db099298f7">&#9670;&#160;</a></span>sqrtu32_floor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sqrtu32_floor </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>radic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns the square root of the 32-bit value <code>radic</code>, rounded down to the next integral value. </dd></dl>

</div>
</div>
<a id="gacceff9dc95bb3c5562dc9e61fc3d9075" name="gacceff9dc95bb3c5562dc9e61fc3d9075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacceff9dc95bb3c5562dc9e61fc3d9075">&#9670;&#160;</a></span>srand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srand </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>__seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pseudo-random number generator seeding; see <a class="el" href="group__avr__stdlib.html#gae23144bcbb8e3742b00eb687c36654d1">rand()</a>. </p>

</div>
</div>
<a id="ga4fca27496ca29c0a723d197696641eff" name="ga4fca27496ca29c0a723d197696641eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fca27496ca29c0a723d197696641eff">&#9670;&#160;</a></span>srandom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srandom </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>__seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pseudo-random number generator seeding; see <a class="el" href="group__avr__stdlib.html#ga114aeb1751119382aaf3340355b22cfd">random()</a>. </p>

</div>
</div>
<a id="ga5ee4d110a3bb55d2eadda05e3ebedf8a" name="ga5ee4d110a3bb55d2eadda05e3ebedf8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ee4d110a3bb55d2eadda05e3ebedf8a">&#9670;&#160;</a></span>strtod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double strtod </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>__nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>__endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga5ee4d110a3bb55d2eadda05e3ebedf8a">strtod()</a> function is similar to <a class="el" href="group__avr__stdlib.html#ga699a1d102f9ea32765752559f978a590">strtof()</a>, except that the conversion result is of type <code>double</code> instead of <code>float</code>.</p>
<p><a class="el" href="group__avr__stdlib.html#ga5ee4d110a3bb55d2eadda05e3ebedf8a">strtod()</a> is currently only supported when <code>double</code> is a 32-bit type. </p>

</div>
</div>
<a id="ga699a1d102f9ea32765752559f978a590" name="ga699a1d102f9ea32765752559f978a590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga699a1d102f9ea32765752559f978a590">&#9670;&#160;</a></span>strtof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float strtof </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga699a1d102f9ea32765752559f978a590">strtof()</a> function converts the initial portion of the string pointed to by <em>nptr</em> to <code>float</code> representation.</p>
<p>The expected form of the string is an optional plus ( <code>'+'</code> ) or minus sign ( <code>'-'</code> ) followed by a sequence of digits optionally containing a decimal-point character, optionally followed by an exponent. An exponent consists of an <code>'E'</code> or <code>'e'</code>, followed by an optional plus or minus sign, followed by a sequence of digits.</p>
<p>Leading white-space characters in the string are skipped.</p>
<p>The <a class="el" href="group__avr__stdlib.html#ga699a1d102f9ea32765752559f978a590">strtof()</a> function returns the converted value, if any.</p>
<p>If <em>endptr</em> is not <code>NULL</code>, a pointer to the character after the last character used in the conversion is stored in the location referenced by <em>endptr</em>.</p>
<p>If no conversion is performed, zero is returned and the value of <em>nptr</em> is stored in the location referenced by <em>endptr</em>.</p>
<p>If the correct value would cause overflow, plus or minus <code>INFINITY</code> is returned (according to the sign of the value), and <code>ERANGE</code> is stored in <code>errno</code>. If the correct value would cause underflow, zero is returned and <code>ERANGE</code> is stored in <code>errno</code>. </p>

</div>
</div>
<a id="gaf8ce3b8dae3d45c34c3b172de503f7b3" name="gaf8ce3b8dae3d45c34c3b172de503f7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8ce3b8dae3d45c34c3b172de503f7b3">&#9670;&#160;</a></span>strtol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long strtol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>__nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>__endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>__base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#gaf8ce3b8dae3d45c34c3b172de503f7b3">strtol()</a> function converts the string in <code>nptr</code> to a long value. The conversion is done according to the given base, which must be between 2 and 36 inclusive, or be the special value 0.</p>
<p>The string may begin with an arbitrary amount of white space (as determined by <a class="el" href="group__ctype.html#ga16e58710aba8108549a1a3c33691b24e">isspace()</a>) followed by a single optional <code>'+'</code> or <code>'-'</code> sign. If <code>base</code> is zero or 16, the string may then include a <code>"0x"</code> or <code>"0X"</code> prefix, and the number will be read in base 16; otherwise, a zero base is taken as 10 (decimal) unless the next character is <code>'0'</code>, in which case it is taken as 8 (octal).</p>
<p>Similarly, prefixes <code>"0b"</code> and <code>"0B"</code> signify base 2, and <code>"0o"</code> and <code>"0O"</code> signify base 8.</p>
<p>The remainder of the string is converted to a long value in the obvious manner, stopping at the first character which is not a valid digit in the given base. (In bases above 10, the letter <code>'A'</code> in either upper or lower case represents 10, <code>'B'</code> represents 11, and so forth, with <code>'Z'</code> representing 35.)</p>
<p>If <code>endptr</code> is not NULL, <a class="el" href="group__avr__stdlib.html#gaf8ce3b8dae3d45c34c3b172de503f7b3">strtol()</a> stores the address of the first invalid character in <code>*endptr</code>. If there were no digits at all, however, <a class="el" href="group__avr__stdlib.html#gaf8ce3b8dae3d45c34c3b172de503f7b3">strtol()</a> stores the original value of <code>nptr</code> in <code>endptr</code>. (Thus, if <code>*nptr</code> is not <code>'\0'</code> but <code>**endptr</code> is <code>'\0'</code> on return, the entire string was valid.)</p>
<p>The <a class="el" href="group__avr__stdlib.html#gaf8ce3b8dae3d45c34c3b172de503f7b3">strtol()</a> function returns the result of the conversion, unless the value would underflow or overflow. If no conversion could be performed, 0 is returned. If an overflow or underflow occurs, <code>errno</code> is set to <a class="el" href="group__avr__errno.html">ERANGE</a> and the function return value is clamped to <code>LONG_MIN</code> or <code>LONG_MAX</code>, respectively. </p>

</div>
</div>
<a id="ga61043ae34c33c61780a2d9c52f065782" name="ga61043ae34c33c61780a2d9c52f065782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61043ae34c33c61780a2d9c52f065782">&#9670;&#160;</a></span>strtold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double strtold </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>__nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>__endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga61043ae34c33c61780a2d9c52f065782">strtold()</a> function is similar to <a class="el" href="group__avr__stdlib.html#ga699a1d102f9ea32765752559f978a590">strtof()</a>, except that the conversion result is of type <code>long</code> <code>double</code> instead of <code>float</code>.</p>
<p><a class="el" href="group__avr__stdlib.html#ga61043ae34c33c61780a2d9c52f065782">strtold()</a> is currently only supported when <code>long</code> <code>double</code> is a 32-bit type. </p>

</div>
</div>
<a id="ga5006f43088ee0321cf6191ce89eb78b7" name="ga5006f43088ee0321cf6191ce89eb78b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5006f43088ee0321cf6191ce89eb78b7">&#9670;&#160;</a></span>strtoll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long strtoll </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>__nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>__endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>__base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga5006f43088ee0321cf6191ce89eb78b7">strtoll()</a> function converts the string in <code>nptr</code> to a long long value. The conversion is done according to the given base, which must be between 2 and 36 inclusive, or be the special value 0.</p>
<p>The string may begin with an arbitrary amount of white space (as determined by <a class="el" href="group__ctype.html#ga16e58710aba8108549a1a3c33691b24e">isspace()</a>) followed by a single optional <code>'+'</code> or <code>'-'</code> sign. If <code>base</code> is zero or 16, the string may then include a <code>"0x"</code> or <code>"0X"</code> prefix, and the number will be read in base 16; otherwise, a zero base is taken as 10 (decimal) unless the next character is <code>'0'</code>, in which case it is taken as 8 (octal).</p>
<p>Similarly, prefixes <code>"0b"</code> and <code>"0B"</code> signify base 2, and <code>"0o"</code> and <code>"0O"</code> signify base 8.</p>
<p>The remainder of the string is converted to a long long value in the obvious manner, stopping at the first character which is not a valid digit in the given base. (In bases above 10, the letter <code>'A'</code> in either upper or lower case represents 10, <code>'B'</code> represents 11, and so forth, with <code>'Z'</code> representing 35.)</p>
<p>If <code>endptr</code> is not NULL, <a class="el" href="group__avr__stdlib.html#ga5006f43088ee0321cf6191ce89eb78b7">strtoll()</a> stores the address of the first invalid character in <code>*endptr</code>. If there were no digits at all, however, <a class="el" href="group__avr__stdlib.html#ga5006f43088ee0321cf6191ce89eb78b7">strtoll()</a> stores the original value of <code>nptr</code> in <code>endptr</code>. (Thus, if <code>*nptr</code> is not <code>'\0'</code> but <code>**endptr</code> is <code>'\0'</code> on return, the entire string was valid.)</p>
<p>The <a class="el" href="group__avr__stdlib.html#ga5006f43088ee0321cf6191ce89eb78b7">strtoll()</a> function returns the result of the conversion, unless the value would underflow or overflow. If no conversion could be performed, 0 is returned. If an overflow or underflow occurs, <code>errno</code> is set to <a class="el" href="group__avr__errno.html">ERANGE</a> and the function return value is clamped to <code>LLONG_MIN</code> or <code>LLONG_MAX</code>, respectively. </p><dl class="section since"><dt>Since</dt><dd>AVR-LibC v2.3 </dd></dl>

</div>
</div>
<a id="gaea44aa48bda8261f794dcb2d1e7ab2b2" name="gaea44aa48bda8261f794dcb2d1e7ab2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea44aa48bda8261f794dcb2d1e7ab2b2">&#9670;&#160;</a></span>strtoul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long strtoul </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>__nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>__endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>__base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#gaea44aa48bda8261f794dcb2d1e7ab2b2">strtoul()</a> function converts the string in <code>nptr</code> to an unsigned long value. The conversion is done according to the given base, which must be between 2 and 36 inclusive, or be the special value 0.</p>
<p>The string may begin with an arbitrary amount of white space (as determined by <a class="el" href="group__ctype.html#ga16e58710aba8108549a1a3c33691b24e">isspace()</a>) followed by a single optional <code>'+'</code> or <code>'-'</code> sign. If <code>base</code> is zero or 16, the string may then include a <code>"0x"</code> or <code>"0X"</code> prefix, and the number will be read in base 16; otherwise, a zero base is taken as 10 (decimal) unless the next character is <code>'0'</code>, in which case it is taken as 8 (octal).</p>
<p>Similarly, prefixes <code>"0b"</code> and <code>"0B"</code> signify base 2, and <code>"0o"</code> and <code>"0O"</code> signify base 8.</p>
<p>The remainder of the string is converted to an unsigned long value in the obvious manner, stopping at the first character which is not a valid digit in the given base. (In bases above 10, the letter <code>'A'</code> in either upper or lower case represents 10, <code>'B'</code> represents 11, and so forth, with <code>'Z'</code> representing 35.)</p>
<p>If <code>endptr</code> is not NULL, <a class="el" href="group__avr__stdlib.html#gaea44aa48bda8261f794dcb2d1e7ab2b2">strtoul()</a> stores the address of the first invalid character in <code>*endptr</code>. If there were no digits at all, however, <a class="el" href="group__avr__stdlib.html#gaea44aa48bda8261f794dcb2d1e7ab2b2">strtoul()</a> stores the original value of <code>nptr</code> in <code>endptr</code>. (Thus, if <code>*nptr</code> is not <code>'\0'</code> but <code>**endptr</code> is <code>'\0'</code> on return, the entire string was valid.)</p>
<p>The <a class="el" href="group__avr__stdlib.html#gaea44aa48bda8261f794dcb2d1e7ab2b2">strtoul()</a> function returns either the result of the conversion or, if there was a leading minus sign, the negation of the result of the conversion, unless the original (non-negated) value would overflow; in the latter case, <a class="el" href="group__avr__stdlib.html#gaea44aa48bda8261f794dcb2d1e7ab2b2">strtoul()</a> returns ULONG_MAX, and <code>errno</code> is set to <a class="el" href="group__avr__errno.html">ERANGE</a>. If no conversion could be performed, 0 is returned. </p>

</div>
</div>
<a id="ga1e125b8f54ff186f1627cfea739764f1" name="ga1e125b8f54ff186f1627cfea739764f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e125b8f54ff186f1627cfea739764f1">&#9670;&#160;</a></span>strtoull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long strtoull </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>__nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>__endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>__base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__avr__stdlib.html#ga1e125b8f54ff186f1627cfea739764f1">strtoull()</a> function converts the string in <code>nptr</code> to an unsigned long long value. The conversion is done according to the given base, which must be between 2 and 36 inclusive, or be the special value 0.</p>
<p>The string may begin with an arbitrary amount of white space (as determined by <a class="el" href="group__ctype.html#ga16e58710aba8108549a1a3c33691b24e">isspace()</a>) followed by a single optional <code>'+'</code> or <code>'-'</code> sign. If <code>base</code> is zero or 16, the string may then include a <code>"0x"</code> or <code>"0X"</code> prefix, and the number will be read in base 16; otherwise, a zero base is taken as 10 (decimal) unless the next character is <code>'0'</code>, in which case it is taken as 8 (octal).</p>
<p>Similarly, prefixes <code>"0b"</code> and <code>"0B"</code> signify base 2, and <code>"0o"</code> and <code>"0O"</code> signify base 8.</p>
<p>The remainder of the string is converted to an unsigned long long value in the obvious manner, stopping at the first character which is not a valid digit in the given base. (In bases above 10, the letter <code>'A'</code> in either upper or lower case represents 10, <code>'B'</code> represents 11, and so forth, with <code>'Z'</code> representing 35.)</p>
<p>If <code>endptr</code> is not NULL, <a class="el" href="group__avr__stdlib.html#ga1e125b8f54ff186f1627cfea739764f1">strtoull()</a> stores the address of the first invalid character in <code>*endptr</code>. If there were no digits at all, however, <a class="el" href="group__avr__stdlib.html#ga1e125b8f54ff186f1627cfea739764f1">strtoull()</a> stores the original value of <code>nptr</code> in <code>endptr</code>. (Thus, if <code>*nptr</code> is not <code>'\0'</code> but <code>**endptr</code> is <code>'\0'</code> on return, the entire string was valid.)</p>
<p>The <a class="el" href="group__avr__stdlib.html#ga1e125b8f54ff186f1627cfea739764f1">strtoull()</a> function returns either the result of the conversion or, if there was a leading minus sign, the negation of the result of the conversion, unless the original (non-negated) value would overflow; in the latter case, <a class="el" href="group__avr__stdlib.html#ga1e125b8f54ff186f1627cfea739764f1">strtoull()</a> returns ULLONG_MAX, and <code>errno</code> is set to <a class="el" href="group__avr__errno.html">ERANGE</a>. If no conversion could be performed, 0 is returned. </p><dl class="section since"><dt>Since</dt><dd>AVR-LibC v2.3 </dd></dl>

</div>
</div>
<a id="gab47b5d70f2429fb71c84dac6743f1819" name="gab47b5d70f2429fb71c84dac6743f1819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab47b5d70f2429fb71c84dac6743f1819">&#9670;&#160;</a></span>ulltoa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ulltoa </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an unsigned 64-bit integer to a string. </p>
<p>The function <a class="el" href="group__avr__stdlib.html#gab47b5d70f2429fb71c84dac6743f1819" title="Convert an unsigned 64-bit integer to a string.">ulltoa()</a> writes the ASCII representation of the unsigned 64-bit integer <code>val</code> to a string starting at <code>s</code>.</p>
<p>A very rough estimation of the execution time is</p>
<p>&#160;&#160;&#160;&#160;<em>Cycles</em> &asymp; 950 + 23&middot;<em>N</em> + 8.3&middot;<em>N</em><sup>2</sup>&middot;log(<em>radix</em>) &plusmn; 400</p>
<p>where <em>N</em> denotes the number of digits in the result, and log stands for the Natural Logarithm. This means a decimal conversion can take up to 9000 cycles, a hexadecimal conversions can take up to 7800 cycles, and a binary conversion can take more than 27000 cycles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>An unsigned 64-bit integral value for which the ASCII representation is computed.</td></tr>
    <tr><td class="paramname">s</td><td>The location to which the string representation should be stored. The caller is responsible for providing sufficient storage in <code>s</code>. The minimal size of the buffer <code>s</code> depends on the choice of the radix. For example, if the radix is 10 (decimal), the function will write at most 21 characters (including the terminating '\0').</td></tr>
    <tr><td class="paramname">radix</td><td>The Conversion is done using the <code>radix</code> as base, which may be a number between 2 (binary conversion) and up to 36. If <code>radix</code> is greater than 10, the next digit after <code>'9'</code> will be the letter <code>'a'</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__stdlib.html#gab47b5d70f2429fb71c84dac6743f1819" title="Convert an unsigned 64-bit integer to a string.">ulltoa()</a> function returns the pointer passed as <code>s</code>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>AVR-LibC v2.3 </dd></dl>

</div>
</div>
<a id="ga2ce93a5610dfd2c4c482b52fb363be47" name="ga2ce93a5610dfd2c4c482b52fb363be47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ce93a5610dfd2c4c482b52fb363be47">&#9670;&#160;</a></span>ulltoa_base10()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ulltoa_base10 </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an unsigned 64-bit integer to a decimal string. </p>
<p>The function <a class="el" href="group__avr__stdlib.html#ga2ce93a5610dfd2c4c482b52fb363be47" title="Convert an unsigned 64-bit integer to a decimal string.">ulltoa_base10()</a> writes the decimal ASCII representation of the unsigned 64-bit integer <code>val</code> to a string starting at <code>s</code>. The effect is the same like for <code>ulltoa(val, s, 10)</code>.</p>
<p>This function can be used for decimal ASCII conversions when <a class="el" href="group__avr__stdlib.html#gab47b5d70f2429fb71c84dac6743f1819" title="Convert an unsigned 64-bit integer to a string.">ulltoa()</a> is not fast enough. It consumes no more than 3300 cycles (no more than 2800 cycles with <code>MUL</code>), where <a class="el" href="group__avr__stdlib.html#gab47b5d70f2429fb71c84dac6743f1819" title="Convert an unsigned 64-bit integer to a string.">ulltoa()</a> may consume up to 9000 cycles for a decimal conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>An unsigned 64-bit integral value for which the decimal ASCII representation is computed.</td></tr>
    <tr><td class="paramname">s</td><td>The location to which the string representation should be stored. The caller is responsible for providing sufficient storage in <code>s</code>. The function will write at most 21 characters (including the terminating '\0').</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__stdlib.html#ga2ce93a5610dfd2c4c482b52fb363be47" title="Convert an unsigned 64-bit integer to a decimal string.">ulltoa_base10()</a> function returns the pointer passed as <code>s</code>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>AVR-LibC v2.3 </dd></dl>

</div>
</div>
<a id="gadfc2bdc0b74aaeba28efe5af3085a89f" name="gadfc2bdc0b74aaeba28efe5af3085a89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfc2bdc0b74aaeba28efe5af3085a89f">&#9670;&#160;</a></span>ultoa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ultoa </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an unsigned long integer to a string. </p>
<p>The function <a class="el" href="group__avr__stdlib.html#gadfc2bdc0b74aaeba28efe5af3085a89f" title="Convert an unsigned long integer to a string.">ultoa()</a> converts the unsigned long integer value from <code>val</code> into an ASCII representation that will be stored under <code>s</code>. The caller is responsible for providing sufficient storage in <code>s</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The minimal size of the buffer <code>s</code> depends on the choice of radix. For example, if the radix is 2 (binary), you need to supply a buffer with a minimal length of 8 * sizeof (unsigned long int) + 1 characters, i.e. one character for each bit plus one for the string terminator. Using a larger radix will require a smaller minimal buffer size.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the buffer is too small, you risk a buffer overflow.</dd></dl>
<p>Conversion is done using the <code>radix</code> as base, which may be a number between 2 (binary conversion) and up to 36. If <code>radix</code> is greater than 10, the next digit after <code>'9'</code> will be the letter <code>'a'</code>.</p>
<p>The <a class="el" href="group__avr__stdlib.html#gadfc2bdc0b74aaeba28efe5af3085a89f" title="Convert an unsigned long integer to a string.">ultoa()</a> function returns the pointer passed as <code>s</code>. </p>

</div>
</div>
<a id="gae73ba2b460809c0b7fee30ffe347083c" name="gae73ba2b460809c0b7fee30ffe347083c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae73ba2b460809c0b7fee30ffe347083c">&#9670;&#160;</a></span>utoa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * utoa </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an unsigned integer to a string. </p>
<p>The function <a class="el" href="group__avr__stdlib.html#gae73ba2b460809c0b7fee30ffe347083c" title="Convert an unsigned integer to a string.">utoa()</a> converts the unsigned integer value from <code>val</code> into an ASCII representation that will be stored under <code>s</code>. The caller is responsible for providing sufficient storage in <code>s</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The minimal size of the buffer <code>s</code> depends on the choice of radix. For example, if the radix is 2 (binary), you need to supply a buffer with a minimal length of 8 * sizeof (unsigned int) + 1 characters, i.e. one character for each bit plus one for the string terminator. Using a larger radix will require a smaller minimal buffer size.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the buffer is too small, you risk a buffer overflow.</dd></dl>
<p>Conversion is done using the <code>radix</code> as base, which may be a number between 2 (binary conversion) and up to 36. If <code>radix</code> is greater than 10, the next digit after <code>'9'</code> will be the letter <code>'a'</code>.</p>
<p>The <a class="el" href="group__avr__stdlib.html#gae73ba2b460809c0b7fee30ffe347083c" title="Convert an unsigned integer to a string.">utoa()</a> function returns the pointer passed as <code>s</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Decimal conversions can be sped up by using the <a class="el" href="group__avr__stdfix.html#ga156313d91e5696ecff3dd8cb7e4d8a09">uktoa()</a> function from <a class="el" href="group__avr__stdfix.html">&lt;stdfix.h&gt;</a> that converts fixed-point values to decimal ASCII, like in <code>uktoa((unsigned accum) val, s, FXTOA_TRUNC)</code> that converts <code>val</code> to a decimal ASCII representation with zero fractional digits. For example, converting 1000 using <a class="el" href="group__avr__stdlib.html#gae73ba2b460809c0b7fee30ffe347083c" title="Convert an unsigned integer to a string.">utoa()</a> takes around 700 cycles whereas <a class="el" href="group__avr__stdfix.html#ga156313d91e5696ecff3dd8cb7e4d8a09">uktoa()</a> does the job in less than 300 cycles. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga4d7b1bf0f75d529cc75229a266132115" name="ga4d7b1bf0f75d529cc75229a266132115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d7b1bf0f75d529cc75229a266132115">&#9670;&#160;</a></span>__malloc_heap_end</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* __malloc_heap_end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>malloc()</code> <a class="el" href="malloc.html#malloc_tunables">tunable</a>. </p>

</div>
</div>
<a id="ga9310042b3956282440c091d20cb98c5f" name="ga9310042b3956282440c091d20cb98c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9310042b3956282440c091d20cb98c5f">&#9670;&#160;</a></span>__malloc_heap_start</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* __malloc_heap_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>malloc()</code> <a class="el" href="malloc.html#malloc_tunables">tunable</a>. </p>

</div>
</div>
<a id="gaffadd67736fd340e893fb22c207de597" name="gaffadd67736fd340e893fb22c207de597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffadd67736fd340e893fb22c207de597">&#9670;&#160;</a></span>__malloc_margin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t __malloc_margin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>malloc()</code> <a class="el" href="malloc.html#malloc_tunables">tunable</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 27 2025 18:32:02 for AVR-LibC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.6
</small></address>
</body>
</html>
