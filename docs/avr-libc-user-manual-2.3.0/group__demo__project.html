<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<title>AVR-LibC: A simple project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AVR-LibC
   &#160;<span id="projectnumber">2.3.0git</span>
   </div>
   <div id="projectbrief">Standard C library for AVR-GCC</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table>
  <tr>
    <td align="left"><a href="https://avrdudes.github.io/avr-libc/"><h2>AVR-LibC Documen&shy;tation</h2></a></td>
    <td align="center" colspan=4>
      <div class="logo"><img src="avr-libc-logo.png" alt="Logo" align="middle" border="0"></div>
      <div class="invlogo"><img src="avr-libc-logo-inverted.png" alt="Logo" align="middle" border="0"></div>
    </td>
    <td align="right" colspan=2><a href="https://github.com/avrdudes/avr-libc/"><h2>AVR-LibC Development Pages</h2></a></td>
  </tr>
  <tr>
    <td align="center" width="15%"><a href="index.html"><h2>Main Page</h2></a></td>
    <td align="center" width="15%"><a href="pages.html"><h2>User Manual</h2></a></td>
    <td align="center" width="15%"><a href="modules.html"><h2>Library Refe&shy;rence</h2></a></td>
    <td align="center" width="8%"><a href="FAQ.html"><h2>FAQ</h2></a></td>
    <td align="center" width="15%"><a href="group__demos.html"><h2>Example Projects</h2></a></td>
    <td align="center" width="8%"><a href="files.html"><h2>File List</h2></a></td>
    <td align="center" width="8%"><a href="Global_01Index.html"><h2>Index</h2></a></td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">A simple project<div class="ingroups"><a class="el" href="group__demos.html">Demo projects</a></div></div></div>
</div><!--header-->
<div class="contents">
<p>At this point, you should have the GNU tools configured, built, and installed on your system. In this chapter, we present a simple example of using the GNU tools in an AVR project. After reading this chapter, you should have a better feel as to how the tools are used and how a <code>Makefile</code> can be configured.</p>
<h1><a class="anchor" id="demo_project_desc"></a>
The Project</h1>
<p>This project will use the pulse-width modulator (<code>PWM</code>) to ramp an LED on and off every two seconds. An AT90S2313 processor will be used as the controller. The circuit for this demonstration is shown in the <a class="el" href="group__demo__project.html#demo_project_schematic">schematic diagram</a>. If you have a development kit, you should be able to use it, rather than build the circuit, for this project.</p>
<dl class="section note"><dt>Note</dt><dd>Meanwhile, the AT90S2313 became obsolete. Either use its successor, the (pin-compatible) ATtiny2313 for the project, or perhaps the ATmega8 or one of its successors (ATmega48/88/168) which have become quite popular since the original demo project had been established. For all these more modern devices, it is no longer necessary to use an external crystal for clocking as they ship with the internal 1 MHz oscillator enabled, so C1, C2, and Q1 can be omitted. Normally, for this experiment, the external circuitry on /RESET (R1, C3) can be omitted as well, leaving only the AVR, the LED, the bypass capacitor C4, and perhaps R2. For the ATmega8/48/88/168, use PB1 (pin 15 at the DIP-28 package) to connect the LED to. Additionally, this demo has been ported to many different other AVRs. The location of the respective OC pin varies between different AVRs, and it is mandated by the AVR hardware.</dd></dl>
<p><a class="anchor" id="demo_project_schematic"></a></p><div class="image">
<img src="demo.png" alt=""/>
<div class="caption">
Schematic of circuit for demo project</div></div>
 <p>The source code is given in <a class="el" href="group__demo__project.html#demo_project_src">demo.c</a>. For the sake of this example, create a file called <code>demo.c</code> containing this source code. Some of the more important parts of the code are:</p>
<dl class="section user"><dt>Note [1]:</dt><dd>As the AVR microcontroller series has been developed during the past years, new features have been added over time. Even though the basic concepts of the timer/counter1 are still the same as they used to be back in early 2001 when this simple demo was written initially, the names of registers and bits have been changed slightly to reflect the new features. Also, the port and pin mapping of the output compare match 1A (or 1 for older devices) pin which is used to control the LED varies between different AVRs. The file <code><a class="el" href="iocompat_8h_source.html">iocompat.h</a></code> tries to abstract between all this differences using some preprocessor <code>#ifdef</code> statements, so the actual program itself can operate on a common set of symbolic names. The macros defined by that file are:</dd></dl>
<ul>
<li><code>OCR</code> the name of the OCR register used to control the PWM (usually either OCR1 or OCR1A)</li>
<li><code>DDROC</code> the name of the DDR (data direction register) for the OC output</li>
<li><code>OC1</code> the pin number of the OC1[A] output within its port</li>
<li><code>TIMER1_TOP</code> the TOP value of the timer used for the PWM (1023 for 10-bit PWMs, 255 for devices that can only handle an 8-bit PWM)</li>
<li><code>TIMER1_PWM_INIT</code> the initialization bits to be set into control register 1A in order to setup 10-bit (or 8-bit) phase and frequency correct PWM mode</li>
<li><code>TIMER1_CLOCKSOURCE</code> the clock bits to set in the respective control register to start the PWM timer; usually the timer runs at full CPU clock for 10-bit PWMs, while it runs on a prescaled clock for 8-bit PWMs</li>
</ul>
<dl class="section user"><dt>Note [2]:</dt><dd><a class="el" href="group__avr__interrupts.html#gad28590624d422cdf30d626e0a506255f">ISR()</a> is a macro that marks the function as an interrupt routine. In this case, the function will get called when timer 1 overflows. Setting up interrupts is explained in greater detail in <a class="el" href="group__avr__interrupts.html">&lt;avr/interrupt.h&gt;: Interrupts</a>.</dd></dl>
<dl class="section user"><dt>Note [3]:</dt><dd>The <code>PWM</code> is being used in 10-bit mode, so we need a 16-bit variable to remember the current value.</dd></dl>
<dl class="section user"><dt>Note [4]:</dt><dd>This section determines the new value of the <code>PWM</code>.</dd></dl>
<dl class="section user"><dt>Note [5]:</dt><dd>Here's where the newly computed value is loaded into the <code>PWM</code> register. Since we are in an interrupt routine, it is safe to use a 16-bit assignment to the register. Outside of an interrupt, the assignment should only be performed with interrupts disabled if there's a chance that an interrupt routine could also access this register (or another register that uses <code>TEMP</code>), see the appropriate <a class="el" href="FAQ.html#faq_16bitio">FAQ entry</a>.</dd></dl>
<dl class="section user"><dt>Note [6]:</dt><dd>This routine gets called after a reset. It initializes the <code>PWM</code> and enables interrupts.</dd></dl>
<dl class="section user"><dt>Note [7]:</dt><dd>The main loop of the program does nothing &ndash; all the work is done by the interrupt routine! The <code><a class="el" href="group__avr__sleep.html#ga3775b21f297187752bcfc434a541209a">sleep_mode()</a></code> puts the processor on sleep until the next interrupt, to conserve power. Of course, that probably won't be noticeable as we are still driving a LED, it is merely mentioned here to demonstrate the basic principle.</dd></dl>
<dl class="section user"><dt>Note [8]:</dt><dd>Early AVR devices saturate their outputs at rather low currents when sourcing current, so the LED can be connected directly, the resulting current through the LED will be about 15 mA. For modern parts (at least for the ATmega 128), however Atmel has drastically increased the IO source capability, so when operating at 5 V Vcc, R2 is needed. Its value should be about 150 Ohms. When operating the circuit at 3 V, it can still be omitted though.</dd></dl>
<h1><a class="anchor" id="demo_project_src"></a>
The Source Code</h1>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * ----------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> * &quot;THE BEER-WARE LICENSE&quot; (Revision 42):</span></div>
<div class="line"><span class="comment"> * &lt;joerg@FreeBSD.ORG&gt; wrote this file.  As long as you retain this notice you</span></div>
<div class="line"><span class="comment"> * can do whatever you want with this stuff. If we meet some day, and you think</span></div>
<div class="line"><span class="comment"> * this stuff is worth it, you can buy me a beer in return.        Joerg Wunsch</span></div>
<div class="line"><span class="comment"> * ----------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Simple AVR demonstration.  Controls a LED that can be directly</span></div>
<div class="line"><span class="comment"> * connected from OC1/OC1A to GND.  The brightness of the LED is</span></div>
<div class="line"><span class="comment"> * controlled with the PWM.  After each period of the PWM, the PWM</span></div>
<div class="line"><span class="comment"> * value is either incremented or decremented, that&#39;s all.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="inttypes_8h.html">inttypes.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io_8h.html">avr/io.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sleep_8h.html">avr/sleep.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;iocompat.h&quot;</span>       <span class="comment">/* Note [1] */</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum</span> { UP, DOWN };</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__avr__interrupts.html#gad28590624d422cdf30d626e0a506255f">ISR</a> (TIMER1_OVF_vect)       <span class="comment">/* Note [2] */</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> <a class="code hl_typedef" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> pwm;    <span class="comment">/* Note [3] */</span></div>
<div class="line">    <span class="keyword">static</span> <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> direction;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">switch</span> (direction)      <span class="comment">/* Note [4] */</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> UP:</div>
<div class="line">            <span class="keywordflow">if</span> (++pwm == TIMER1_TOP)</div>
<div class="line">                direction = DOWN;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">case</span> DOWN:</div>
<div class="line">            <span class="keywordflow">if</span> (--pwm == 0)</div>
<div class="line">                direction = UP;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    OCR = pwm;          <span class="comment">/* Note [5] */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">ioinit (<span class="keywordtype">void</span>)           <span class="comment">/* Note [6] */</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Timer 1 is 10-bit PWM (8-bit PWM on some ATtinys). */</span></div>
<div class="line">    TCCR1A = TIMER1_PWM_INIT;</div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * Start timer 1.</span></div>
<div class="line"><span class="comment">     *</span></div>
<div class="line"><span class="comment">     * NB: TCCR1A and TCCR1B could actually be the same register, so</span></div>
<div class="line"><span class="comment">     * take care to not clobber it.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    TCCR1B |= TIMER1_CLOCKSOURCE;</div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * Run any device-dependent timer 1 setup hook if present.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line"><span class="preprocessor">#if defined(TIMER1_SETUP_HOOK)</span></div>
<div class="line">    TIMER1_SETUP_HOOK();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Set PWM value to 0. */</span></div>
<div class="line">    OCR = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Enable OC1 as output. */</span></div>
<div class="line">    DDROC = <a class="code hl_define" href="group__avr__sfr.html#ga11643f271076024c395a93800b3d9546">_BV</a> (OC1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Enable timer 1 overflow interrupt. */</span></div>
<div class="line">    TIMSK = <a class="code hl_define" href="group__avr__sfr.html#ga11643f271076024c395a93800b3d9546">_BV</a> (TOIE1);</div>
<div class="line">    <a class="code hl_define" href="group__avr__interrupts.html#gaad5ebd34cb344c26ac87594f79b06b73">sei</a> ();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    ioinit ();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* loop forever, the interrupts are doing the rest */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (;;)            <span class="comment">/* Note [7] */</span></div>
<div class="line">        <a class="code hl_function" href="group__avr__sleep.html#ga3775b21f297187752bcfc434a541209a">sleep_mode</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> (0);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__interrupts_html_gaad5ebd34cb344c26ac87594f79b06b73"><div class="ttname"><a href="group__avr__interrupts.html#gaad5ebd34cb344c26ac87594f79b06b73">sei</a></div><div class="ttdeci">#define sei()</div><div class="ttdef"><b>Definition:</b> interrupt.h:74</div></div>
<div class="ttc" id="agroup__avr__interrupts_html_gad28590624d422cdf30d626e0a506255f"><div class="ttname"><a href="group__avr__interrupts.html#gad28590624d422cdf30d626e0a506255f">ISR</a></div><div class="ttdeci">#define ISR(vector, attributes)</div><div class="ttdef"><b>Definition:</b> interrupt.h:118</div></div>
<div class="ttc" id="agroup__avr__sfr_html_ga11643f271076024c395a93800b3d9546"><div class="ttname"><a href="group__avr__sfr.html#ga11643f271076024c395a93800b3d9546">_BV</a></div><div class="ttdeci">#define _BV(bit)</div><div class="ttdef"><b>Definition:</b> sfr_defs.h:206</div></div>
<div class="ttc" id="agroup__avr__sleep_html_ga3775b21f297187752bcfc434a541209a"><div class="ttname"><a href="group__avr__sleep.html#ga3775b21f297187752bcfc434a541209a">sleep_mode</a></div><div class="ttdeci">void sleep_mode(void)</div></div>
<div class="ttc" id="agroup__avr__stdint_html_ga1f1825b69244eb3ad2c7165ddc99c956"><div class="ttname"><a href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a></div><div class="ttdeci">unsigned int uint16_t</div><div class="ttdef"><b>Definition:</b> stdint.h:91</div></div>
<div class="ttc" id="agroup__avr__stdint_html_gaba7bc1797add20fe3efdf37ced1182c5"><div class="ttname"><a href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a></div><div class="ttdeci">unsigned char uint8_t</div><div class="ttdef"><b>Definition:</b> stdint.h:81</div></div>
<div class="ttc" id="ainterrupt_8h_html"><div class="ttname"><a href="interrupt_8h.html">interrupt.h</a></div></div>
<div class="ttc" id="ainttypes_8h_html"><div class="ttname"><a href="inttypes_8h.html">inttypes.h</a></div></div>
<div class="ttc" id="aio_8h_html"><div class="ttname"><a href="io_8h.html">io.h</a></div></div>
<div class="ttc" id="asleep_8h_html"><div class="ttname"><a href="sleep_8h.html">sleep.h</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="demo_project_compile"></a>
Compiling and Linking</h1>
<p>This first thing that needs to be done is compile the source. When compiling, the compiler needs to know the processor type so the <code>-mmcu</code> option is specified. The <code>-Os</code> option will tell the compiler to optimize the code for efficient space usage (at the possible expense of code execution speed). The <code>-g</code> is used to embed debug info. The debug info is useful for disassemblies and doesn't end up in the <code></code>.hex files, so I usually specify it. Finally, the <code>-c</code> tells the compiler to compile and stop &ndash; don't link. This demo is small enough that we could compile and link in one step. However, real-world projects will have several modules and will typically need to break up the building of the project into several compiles and one link.</p>
<pre class="fragment">    $ avr-gcc -g -Os -mmcu=atmega8 -c demo.c
</pre><p>The compilation will create a <code>demo.o</code> file. Next we link it into a binary called <code>demo.elf</code>.</p>
<pre class="fragment">    $ avr-gcc -g -mmcu=atmega8 -o demo.elf demo.o
</pre><p>It is important to specify the MCU type when linking. The compiler uses the <code>-mmcu</code> option to choose start-up files and run-time libraries that get linked together. If this option isn't specified, the compiler defaults to the 8515 processor environment, which is most certainly what you didn't want.</p>
<h1><a class="anchor" id="demo_project_obj"></a>
Examining the Object File</h1>
<p><a id="a17_disassembling" name="a17_disassembling"></a></p>
<p>Now we have a binary file. Can we do anything useful with it (besides put it into the processor?) The GNU Binutils suite is made up of many useful tools for manipulating object files that get generated. One tool is <code>avr-objdump</code>, which takes information from the object file and displays it in many useful ways. Typing the command by itself will cause it to list out its options.</p>
<p>For instance, to get a feel of the application's size, the <code>-h</code> option can be used. The output of this option shows how much space is used in each of the sections (the <code></code>.stab and <code></code>.stabstr sections hold the debugging information and won't make it into the ROM file).</p>
<p>An even more useful option is <code>-S</code>. This option disassembles the binary file and intersperses the source code in the output! This method is much better, in my opinion, than using the <code>-S</code> with the compiler because this listing includes routines from the libraries and the vector table contents. Also, all the "fix-ups" have been satisfied. In other words, the listing generated by this option reflects the actual code that the processor will run.</p>
<pre class="fragment">    $ avr-objdump -h -S demo.elf &gt; demo.lst
</pre><p>Here's the output as saved in the <code>demo.lst</code> file:</p>
<pre class="fragment">
demo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000d0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  000000d0  00000164  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000003  00800060  00800060  00000164  2**0
                  ALLOC
  3 .comment      0000001b  00000000  00000000  00000164  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000180  2**2
                  CONTENTS, READONLY, OCTETS
  5 .debug_aranges 00000068  00000000  00000000  000001c0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_info   000005d5  00000000  00000000  00000228  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_abbrev 00000555  00000000  00000000  000007fd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   000002d6  00000000  00000000  00000d52  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_frame  00000050  00000000  00000000  00001028  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_str    000002c3  00000000  00000000  00001078  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line_str 000000e9  00000000  00000000  0000133b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_rnglists 00000019  00000000  00000000  00001424  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 &lt;__vectors&gt;:
   0:	12 c0       	rjmp	.+36     	; 0x26 &lt;__ctors_end&gt;
   2:	58 c0       	rjmp	.+176    	; 0xb4 &lt;__bad_interrupt&gt;
   4:	57 c0       	rjmp	.+174    	; 0xb4 &lt;__bad_interrupt&gt;
   6:	56 c0       	rjmp	.+172    	; 0xb4 &lt;__bad_interrupt&gt;
   8:	55 c0       	rjmp	.+170    	; 0xb4 &lt;__bad_interrupt&gt;
   a:	54 c0       	rjmp	.+168    	; 0xb4 &lt;__bad_interrupt&gt;
   c:	53 c0       	rjmp	.+166    	; 0xb4 &lt;__bad_interrupt&gt;
   e:	52 c0       	rjmp	.+164    	; 0xb4 &lt;__bad_interrupt&gt;
  10:	14 c0       	rjmp	.+40     	; 0x3a &lt;__vector_8&gt;
  12:	50 c0       	rjmp	.+160    	; 0xb4 &lt;__bad_interrupt&gt;
  14:	4f c0       	rjmp	.+158    	; 0xb4 &lt;__bad_interrupt&gt;
  16:	4e c0       	rjmp	.+156    	; 0xb4 &lt;__bad_interrupt&gt;
  18:	4d c0       	rjmp	.+154    	; 0xb4 &lt;__bad_interrupt&gt;
  1a:	4c c0       	rjmp	.+152    	; 0xb4 &lt;__bad_interrupt&gt;
  1c:	4b c0       	rjmp	.+150    	; 0xb4 &lt;__bad_interrupt&gt;
  1e:	4a c0       	rjmp	.+148    	; 0xb4 &lt;__bad_interrupt&gt;
  20:	49 c0       	rjmp	.+146    	; 0xb4 &lt;__bad_interrupt&gt;
  22:	48 c0       	rjmp	.+144    	; 0xb4 &lt;__bad_interrupt&gt;
  24:	47 c0       	rjmp	.+142    	; 0xb4 &lt;__bad_interrupt&gt;

00000026 &lt;__ctors_end&gt;:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63

0000002a &lt;__do_clear_bss&gt;:
/* __do_clear_bss is only necessary if there is anything in .bss section.  */

#ifdef L_clear_bss
	.section .init4,"ax",@progbits
DEFUN __do_clear_bss
	ldi	r18, hi8(__bss_end)
  2a:	20 e0       	ldi	r18, 0x00	; 0

0000002c &lt;.Loc.1&gt;:
	ldi	r26, lo8(__bss_start)
  2c:	a0 e6       	ldi	r26, 0x60	; 96

0000002e &lt;.Loc.2&gt;:
	ldi	r27, hi8(__bss_start)
  2e:	b0 e0       	ldi	r27, 0x00	; 0

00000030 &lt;.Loc.3&gt;:
	rjmp	.do_clear_bss_start
  30:	01 c0       	rjmp	.+2      	; 0x34 &lt;.Loc.5&gt;

00000032 &lt;.Loc.4&gt;:
.do_clear_bss_loop:
	st	X+, __zero_reg__
  32:	1d 92       	st	X+, r1

00000034 &lt;.Loc.5&gt;:
.do_clear_bss_start:
	cpi	r26, lo8(__bss_end)
  34:	a3 36       	cpi	r26, 0x63	; 99

00000036 &lt;.Loc.6&gt;:
	cpc	r27, r18
  36:	b2 07       	cpc	r27, r18

00000038 &lt;.Loc.7&gt;:
	brne	.do_clear_bss_loop
  38:	e1 f7       	brne	.-8      	; 0x32 &lt;.Loc.4&gt;

0000003a &lt;__vector_8&gt;:
#include "iocompat.h"		/* Note [1] */

enum { UP, DOWN };

ISR (TIMER1_OVF_vect)		/* Note [2] */
{
  3a:	1f 92       	push	r1
  3c:	1f b6       	in	r1, 0x3f	; 63
  3e:	1f 92       	push	r1
  40:	11 24       	eor	r1, r1
  42:	2f 93       	push	r18
  44:	8f 93       	push	r24
  46:	9f 93       	push	r25

00000048 &lt;.Loc.1&gt;:
    static uint16_t pwm;	/* Note [3] */
    static uint8_t direction;

    switch (direction)		/* Note [4] */
  48:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 &lt;direction.1&gt;

0000004c &lt;.Loc.4&gt;:
    {
        case UP:
            if (++pwm == TIMER1_TOP)
  4c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 &lt;pwm.0&gt;
  50:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 &lt;pwm.0+0x1&gt;

00000054 &lt;.Loc.5&gt;:
    switch (direction)		/* Note [4] */
  54:	21 30       	cpi	r18, 0x01	; 1
  56:	a0 f0       	brcs	.+40     	; 0x80 &lt;.L2&gt;
  58:	49 f0       	breq	.+18     	; 0x6c &lt;.L3&gt;

0000005a &lt;.L4&gt;:
            if (--pwm == 0)
                direction = UP;
            break;
    }

    OCR = pwm;			/* Note [5] */
  5a:	9b bd       	out	0x2b, r25	; 43
  5c:	8a bd       	out	0x2a, r24	; 42

0000005e &lt;.Loc.8&gt;:
}
  5e:	9f 91       	pop	r25
  60:	8f 91       	pop	r24
  62:	2f 91       	pop	r18
  64:	1f 90       	pop	r1
  66:	1f be       	out	0x3f, r1	; 63
  68:	1f 90       	pop	r1
  6a:	18 95       	reti

0000006c &lt;.L3&gt;:
            if (--pwm == 0)
  6c:	01 97       	sbiw	r24, 0x01	; 1

0000006e &lt;.Loc.11&gt;:
  6e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 &lt;pwm.0&gt;
  72:	90 93 61 00 	sts	0x0061, r25	; 0x800061 &lt;pwm.0+0x1&gt;
  76:	00 97       	sbiw	r24, 0x00	; 0
  78:	81 f7       	brne	.-32     	; 0x5a &lt;.L4&gt;

0000007a &lt;.Loc.12&gt;:
                direction = UP;
  7a:	10 92 62 00 	sts	0x0062, r1	; 0x800062 &lt;direction.1&gt;
  7e:	ed cf       	rjmp	.-38     	; 0x5a &lt;.L4&gt;

00000080 &lt;.L2&gt;:
            if (++pwm == TIMER1_TOP)
  80:	01 96       	adiw	r24, 0x01	; 1

00000082 &lt;.Loc.16&gt;:
  82:	80 93 60 00 	sts	0x0060, r24	; 0x800060 &lt;pwm.0&gt;
  86:	90 93 61 00 	sts	0x0061, r25	; 0x800061 &lt;pwm.0+0x1&gt;
  8a:	8f 3f       	cpi	r24, 0xFF	; 255
  8c:	23 e0       	ldi	r18, 0x03	; 3
  8e:	92 07       	cpc	r25, r18
  90:	21 f7       	brne	.-56     	; 0x5a &lt;.L4&gt;

00000092 &lt;.Loc.17&gt;:
                direction = DOWN;
  92:	21 e0       	ldi	r18, 0x01	; 1
  94:	20 93 62 00 	sts	0x0062, r18	; 0x800062 &lt;direction.1&gt;
  98:	e0 cf       	rjmp	.-64     	; 0x5a &lt;.L4&gt;

0000009a &lt;ioinit&gt;:

void
ioinit (void)			/* Note [6] */
{
    /* Timer 1 is 10-bit PWM (8-bit PWM on some ATtinys). */
    TCCR1A = TIMER1_PWM_INIT;
  9a:	83 e8       	ldi	r24, 0x83	; 131
  9c:	8f bd       	out	0x2f, r24	; 47

0000009e &lt;.Loc.22&gt;:
     * Start timer 1.
     *
     * NB: TCCR1A and TCCR1B could actually be the same register, so
     * take care to not clobber it.
     */
    TCCR1B |= TIMER1_CLOCKSOURCE;
  9e:	8e b5       	in	r24, 0x2e	; 46

000000a0 &lt;.Loc.23&gt;:
  a0:	81 60       	ori	r24, 0x01	; 1
  a2:	8e bd       	out	0x2e, r24	; 46

000000a4 &lt;.Loc.24&gt;:
#if defined(TIMER1_SETUP_HOOK)
    TIMER1_SETUP_HOOK();
#endif

    /* Set PWM value to 0. */
    OCR = 0;
  a4:	1b bc       	out	0x2b, r1	; 43
  a6:	1a bc       	out	0x2a, r1	; 42

000000a8 &lt;.Loc.26&gt;:

    /* Enable OC1 as output. */
    DDROC = _BV (OC1);
  a8:	82 e0       	ldi	r24, 0x02	; 2
  aa:	87 bb       	out	0x17, r24	; 23

000000ac &lt;.Loc.28&gt;:

    /* Enable timer 1 overflow interrupt. */
    TIMSK = _BV (TOIE1);
  ac:	84 e0       	ldi	r24, 0x04	; 4
  ae:	89 bf       	out	0x39, r24	; 57

000000b0 &lt;.Loc.30&gt;:
    sei ();
  b0:	78 94       	sei

000000b2 &lt;.Loc.31&gt;:
}
  b2:	08 95       	ret

000000b4 &lt;__bad_interrupt&gt;:
  b4:	a5 cf       	rjmp	.-182    	; 0x0 &lt;__vectors&gt;

000000b6 &lt;main&gt;:

int
main (void)
{

    ioinit ();
  b6:	f1 df       	rcall	.-30     	; 0x9a &lt;ioinit&gt;

000000b8 &lt;.L10&gt;:

    /* loop forever, the interrupts are doing the rest */

    for (;;)			/* Note [7] */
        sleep_mode();
  b8:	85 b7       	in	r24, 0x35	; 53
  ba:	80 68       	ori	r24, 0x80	; 128
  bc:	85 bf       	out	0x35, r24	; 53

000000be &lt;.Loc.38&gt;:
  be:	88 95       	sleep

000000c0 &lt;.Loc.41&gt;:
  c0:	85 b7       	in	r24, 0x35	; 53
  c2:	8f 77       	andi	r24, 0x7F	; 127
  c4:	85 bf       	out	0x35, r24	; 53

000000c6 &lt;.Loc.44&gt;:
    for (;;)			/* Note [7] */
  c6:	f8 cf       	rjmp	.-16     	; 0xb8 &lt;.L10&gt;

000000c8 &lt;exit&gt;:
  c8:	f8 94       	cli
  ca:	00 c0       	rjmp	.+0      	; 0xcc &lt;_exit&gt;

000000cc &lt;_exit&gt;:
	cli
  cc:	f8 94       	cli

000000ce &lt;__stop_program&gt;:
	rjmp	__stop_program
  ce:	ff cf       	rjmp	.-2      	; 0xce &lt;__stop_program&gt;
</pre><h1><a class="anchor" id="demo_project_map"></a>
Linker Map Files</h1>
<p><code>avr-objdump</code> is very useful, but sometimes it's necessary to see information about the link that can only be generated by the linker. A map file contains this information. A map file is useful for monitoring the sizes of your code and data. It also shows where modules are loaded and which modules were loaded from libraries. It is yet another view of your application. To get a map file, I usually add <code><b>-Wl,-Map,demo.map</b></code> to my link command. Relink the application using the following command to generate <code>demo.map</code> (a portion of which is shown below).</p>
<pre class="fragment">    $ avr-gcc -g -mmcu=atmega8 -Wl,-Map,demo.map -o demo.elf demo.o
</pre><p></p>
<p>Some points of interest in the <code>demo.map</code> file are:</p>
<div class="fragment"><div class="line">.rela.plt</div>
<div class="line"> *(.rela.plt)</div>
<div class="line"> </div>
<div class="line">.text           0x00000000       0xd0</div>
<div class="line"> *(.vectors)</div>
<div class="line"> .vectors       0x00000000       0x26 /home/john/gnu/build/avr-libc/avr/devices/atmega8/crtatmega8.o</div>
<div class="line">                0x00000000                __vectors</div>
<div class="line">                0x00000000                __vector_default</div>
<div class="line"> *(.vectors)</div>
<div class="line">                0x00000026                        __progmem_start = .</div>
<div class="line"> *(.progmem)</div>
<div class="line"> *(.progmem.*)</div>
<div class="line">                0x00000026                        __progmem_end = .</div>
<div class="line">                0x00000001                        ASSERT (((__progmem_start == __progmem_end) || (__progmem_end &lt;= 0x10000)), .progmem section exceeds 0x10000)</div>
<div class="line">                0x00000026                        . = ALIGN (0x2)</div>
<div class="line">                0x00000026                        __trampolines_start = .</div>
<div class="line"> *(.trampolines)</div>
<div class="line"> .trampolines   0x00000026        0x0 linker stubs</div>
<div class="line"> *(.trampolines*)</div>
<div class="line">                0x00000026                        __trampolines_end = .</div>
<div class="line">                0x00000026                        . = ALIGN (0x2)</div>
<div class="line"> *(.lowtext)</div>
<div class="line"> *(.lowtext*)</div>
<div class="line">                0x00000026                        __ctors_start = .</div>
</div><!-- fragment --><p> The <code></code>.text segment (where program instructions are stored) starts at location 0x0.</p>
<div class="fragment"><div class="line"> *(.fini2)</div>
<div class="line"> *(.fini2)</div>
<div class="line"> *(.fini1)</div>
<div class="line"> *(.fini1)</div>
<div class="line"> *(.fini0)</div>
<div class="line"> .fini0         0x000000cc        0x4 /home/DATA/gnu/install/gcc-nolibc-avr/bin/../lib/gcc/avr/15.2.1/avr4/libgcc.a(_exit.o)</div>
<div class="line"> *(.fini0)</div>
<div class="line"> *(.hightext)</div>
<div class="line"> *(.hightext*)</div>
<div class="line"> *(.progmemx)</div>
<div class="line"> *(.progmemx.*)</div>
<div class="line">                0x000000d0                        . = ALIGN (0x2)</div>
<div class="line"> *(.jumptables)</div>
<div class="line"> *(.jumptables*)</div>
<div class="line">                0x000000d0                        _etext = .</div>
<div class="line"> </div>
<div class="line">.data           0x00800060        0x0 load address 0x000000d0</div>
<div class="line">                [!provide]                        PROVIDE (__data_start = .)</div>
<div class="line"> *(.data)</div>
<div class="line"> .data          0x00800060        0x0 demo.o</div>
<div class="line"> .data          0x00800060        0x0 /home/john/gnu/build/avr-libc/avr/lib/avr4/exit.o</div>
<div class="line"> .data          0x00800060        0x0 /home/john/gnu/build/avr-libc/avr/devices/atmega8/crtatmega8.o</div>
<div class="line"> .data          0x00800060        0x0 /home/DATA/gnu/install/gcc-nolibc-avr/bin/../lib/gcc/avr/15.2.1/avr4/libgcc.a(_exit.o)</div>
<div class="line"> .data          0x00800060        0x0 /home/DATA/gnu/install/gcc-nolibc-avr/bin/../lib/gcc/avr/15.2.1/avr4/libgcc.a(_clear_bss.o)</div>
<div class="line"> *(.data*)</div>
<div class="line"> *(.gnu.linkonce.d*)</div>
<div class="line"> *(.rodata)</div>
<div class="line"> *(.rodata*)</div>
<div class="line"> *(.gnu.linkonce.r*)</div>
<div class="line">                0x00800060                        . = ALIGN (0x2)</div>
<div class="line">                0x00800060                        _edata = .</div>
<div class="line">                [!provide]                        PROVIDE (__data_end = .)</div>
<div class="line"> </div>
<div class="line">.bss            0x00800060        0x3</div>
<div class="line">                0x00800060                        PROVIDE (__bss_start = .)</div>
<div class="line"> *(.bss)</div>
<div class="line"> .bss           0x00800060        0x3 demo.o</div>
<div class="line"> .bss           0x00800063        0x0 /home/john/gnu/build/avr-libc/avr/lib/avr4/exit.o</div>
<div class="line"> .bss           0x00800063        0x0 /home/john/gnu/build/avr-libc/avr/devices/atmega8/crtatmega8.o</div>
<div class="line"> .bss           0x00800063        0x0 /home/DATA/gnu/install/gcc-nolibc-avr/bin/../lib/gcc/avr/15.2.1/avr4/libgcc.a(_exit.o)</div>
<div class="line"> .bss           0x00800063        0x0 /home/DATA/gnu/install/gcc-nolibc-avr/bin/../lib/gcc/avr/15.2.1/avr4/libgcc.a(_clear_bss.o)</div>
<div class="line"> *(.bss*)</div>
<div class="line"> *(COMMON)</div>
<div class="line">                0x00800063                        PROVIDE (__bss_end = .)</div>
<div class="line">                0x000000d0                        __data_load_start = LOADADDR (.data)</div>
<div class="line">                0x000000d0                        __data_load_end = (__data_load_start + SIZEOF (.data))</div>
<div class="line"> </div>
<div class="line">.noinit         0x00800063        0x0</div>
<div class="line">                [!provide]                        PROVIDE (__noinit_start = .)</div>
<div class="line"> *(.noinit .noinit.* .gnu.linkonce.n.*)</div>
<div class="line">                [!provide]                        PROVIDE (__noinit_end = .)</div>
<div class="line">                0x00800063                        _end = .</div>
<div class="line">                [!provide]                        PROVIDE (__heap_start = .)</div>
<div class="line">                0x00000000                        __flmap_init_label = DEFINED (__flmap_noinit_start)?__flmap_noinit_start:0x0</div>
<div class="line">                0x00000000                        __flmap = DEFINED (__flmap)?__flmap:0x0</div>
<div class="line"> </div>
<div class="line">.eeprom         0x00810000        0x0</div>
<div class="line"> *(.eeprom*)</div>
<div class="line">                0x00810000                        __eeprom_end = .</div>
</div><!-- fragment --><p> The last address in the <code></code>.text segment is location <code>0x114</code> ( denoted by <code>_etext</code> ), so the instructions use up 276 bytes of FLASH.</p>
<p>The <code></code>.data segment (where initialized static variables are stored) starts at location <code>0x60</code>, which is the first address after the register bank on an ATmega8 processor.</p>
<p>The next available address in the <code></code>.data segment is also location <code>0x60</code>, so the application has no initialized data.</p>
<p>The <code></code>.bss segment (where uninitialized data is stored) starts at location <code>0x60</code>.</p>
<p>The next available address in the <code></code>.bss segment is location 0x63, so the application uses 3 bytes of uninitialized data.</p>
<p>The <code></code>.eeprom segment (where EEPROM variables are stored) starts at location 0x0.</p>
<p>The next available address in the <code></code>.eeprom segment is also location 0x0, so there aren't any EEPROM variables.</p>
<h1><a class="anchor" id="demo_ihex"></a>
Generating Intel Hex Files</h1>
<p>We have a binary of the application, but how do we get it into the processor? Most (if not all) programmers will not accept a GNU executable as an input file, so we need to do a little more processing. The next step is to extract portions of the binary and save the information into <code></code>.hex files. The GNU utility that does this is called <code>avr-objcopy</code>.</p>
<p>The ROM contents can be pulled from our project's binary and put into the file demo.hex using the following command:</p>
<pre class="fragment">    $ avr-objcopy -j .text -j .data -O ihex demo.elf demo.hex
</pre><p>The resulting <code>demo.hex</code> file contains:</p>
<pre class="fragment">:1000000012C058C057C056C055C054C053C052C08B
:1000100014C050C04FC04EC04DC04CC04BC04AC0B1
:1000200049C048C047C011241FBE20E0A0E6B0E090
:1000300001C01D92A336B207E1F71F921FB61F92AF
:1000400011242F938F939F932091620080916000E1
:10005000909161002130A0F049F09BBD8ABD9F9135
:100060008F912F911F901FBE1F901895019780931D
:10007000600090936100009781F710926200EDCFCD
:10008000019680936000909361008F3F23E0920778
:1000900021F721E020936200E0CF83E88FBD8EB589
:1000A00081608EBD1BBC1ABC82E087BB84E089BF27
:1000B00078940895A5CFF1DF85B7806885BF8895CE
:1000C00085B78F7785BFF8CFF89400C0F894FFCF3D
:00000001FF
</pre><p>The <code>-j</code> option indicates that we want the information from the <code></code>.text and <code></code>.data segment extracted. If we specify the EEPROM segment, we can generate a <code></code>.hex file that can be used to program the EEPROM:</p>
<pre class="fragment">    $ avr-objcopy -j .eeprom --change-section-lma .eeprom=0 -O ihex demo.elf demo_eeprom.hex
</pre><p>There is no <code>demo_eeprom.hex</code> file written, as that file would be empty.</p>
<p>Starting with version 2.17 of the GNU binutils, the <code>avr-objcopy</code> command that used to generate the empty EEPROM files now aborts because of the empty input section <code></code>.eeprom, so these empty files are not generated. It also signals an error to the Makefile which will be caught there, and makes it print a message about the empty file not being generated.</p>
<h1><a class="anchor" id="demo_make"></a>
Letting Make Build the Project</h1>
<p>Rather than type these commands over and over, they can all be placed in a make file. To build the demo project using <code>make</code>, save the following in a file called <code>Makefile</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This <code>Makefile</code> can only be used as input for the GNU version of <code>make</code>.</dd></dl>
<div class="fragment"><div class="line">PRG            = demo</div>
<div class="line">OBJ            = demo.o</div>
<div class="line">#MCU_TARGET     = at90s2313</div>
<div class="line">#MCU_TARGET     = at90s2333</div>
<div class="line">#MCU_TARGET     = at90s4414</div>
<div class="line">#MCU_TARGET     = at90s4433</div>
<div class="line">#MCU_TARGET     = at90s4434</div>
<div class="line">#MCU_TARGET     = at90s8515</div>
<div class="line">#MCU_TARGET     = at90s8535</div>
<div class="line">#MCU_TARGET     = atmega128</div>
<div class="line">#MCU_TARGET     = atmega1280</div>
<div class="line">#MCU_TARGET     = atmega1281</div>
<div class="line">#MCU_TARGET     = atmega1284p</div>
<div class="line">#MCU_TARGET     = atmega16</div>
<div class="line">#MCU_TARGET     = atmega163</div>
<div class="line">#MCU_TARGET     = atmega164p</div>
<div class="line">#MCU_TARGET     = atmega165</div>
<div class="line">#MCU_TARGET     = atmega165p</div>
<div class="line">#MCU_TARGET     = atmega168</div>
<div class="line">#MCU_TARGET     = atmega169</div>
<div class="line">#MCU_TARGET     = atmega169p</div>
<div class="line">#MCU_TARGET     = atmega2560</div>
<div class="line">#MCU_TARGET     = atmega2561</div>
<div class="line">#MCU_TARGET     = atmega32</div>
<div class="line">#MCU_TARGET     = atmega324p</div>
<div class="line">#MCU_TARGET     = atmega325</div>
<div class="line">#MCU_TARGET     = atmega3250</div>
<div class="line">#MCU_TARGET     = atmega329</div>
<div class="line">#MCU_TARGET     = atmega3290</div>
<div class="line">#MCU_TARGET     = atmega32u4</div>
<div class="line">#MCU_TARGET     = atmega48</div>
<div class="line">#MCU_TARGET     = atmega64</div>
<div class="line">#MCU_TARGET     = atmega640</div>
<div class="line">#MCU_TARGET     = atmega644</div>
<div class="line">#MCU_TARGET     = atmega644p</div>
<div class="line">#MCU_TARGET     = atmega645</div>
<div class="line">#MCU_TARGET     = atmega6450</div>
<div class="line">#MCU_TARGET     = atmega649</div>
<div class="line">#MCU_TARGET     = atmega6490</div>
<div class="line">MCU_TARGET     = atmega8</div>
<div class="line">#MCU_TARGET     = atmega8515</div>
<div class="line">#MCU_TARGET     = atmega8535</div>
<div class="line">#MCU_TARGET     = atmega88</div>
<div class="line">#MCU_TARGET     = attiny2313</div>
<div class="line">#MCU_TARGET     = attiny24</div>
<div class="line">#MCU_TARGET     = attiny25</div>
<div class="line">#MCU_TARGET     = attiny26</div>
<div class="line">#MCU_TARGET     = attiny261</div>
<div class="line">#MCU_TARGET     = attiny44</div>
<div class="line">#MCU_TARGET     = attiny45</div>
<div class="line">#MCU_TARGET     = attiny461</div>
<div class="line">#MCU_TARGET     = attiny84</div>
<div class="line">#MCU_TARGET     = attiny85</div>
<div class="line">#MCU_TARGET     = attiny861</div>
<div class="line">OPTIMIZE       = -O2</div>
<div class="line"> </div>
<div class="line">DEFS           =</div>
<div class="line">LIBS           =</div>
<div class="line"> </div>
<div class="line"># You should not have to change anything below here.</div>
<div class="line"> </div>
<div class="line">CC             = avr-gcc</div>
<div class="line"> </div>
<div class="line"># Override is only needed by avr-lib build system.</div>
<div class="line"> </div>
<div class="line">override CFLAGS        = -g -Wall $(OPTIMIZE) -mmcu=$(MCU_TARGET) $(DEFS)</div>
<div class="line">override LDFLAGS       = -Wl,-Map,$(PRG).map</div>
<div class="line"> </div>
<div class="line">OBJCOPY        = avr-objcopy</div>
<div class="line">OBJDUMP        = avr-objdump</div>
<div class="line"> </div>
<div class="line">all: $(PRG).elf lst text eeprom</div>
<div class="line"> </div>
<div class="line">$(PRG).elf: $(OBJ)</div>
<div class="line">    $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS)</div>
<div class="line"> </div>
<div class="line"># dependency:</div>
<div class="line">demo.o: demo.c iocompat.h</div>
<div class="line"> </div>
<div class="line">clean:</div>
<div class="line">    rm -rf *.o $(PRG).elf *.eps *.png *.pdf *.bak</div>
<div class="line">    rm -rf *.lst *.map $(EXTRA_CLEAN_FILES)</div>
<div class="line"> </div>
<div class="line">lst:  $(PRG).lst</div>
<div class="line"> </div>
<div class="line">%.lst: %.elf</div>
<div class="line">    $(OBJDUMP) -h -S $&lt; &gt; $@</div>
<div class="line"> </div>
<div class="line"># Rules for building the .text rom images</div>
<div class="line"> </div>
<div class="line">text: hex bin srec</div>
<div class="line"> </div>
<div class="line">hex:  $(PRG).hex</div>
<div class="line">bin:  $(PRG).bin</div>
<div class="line">srec: $(PRG).srec</div>
<div class="line"> </div>
<div class="line">%.hex: %.elf</div>
<div class="line">    $(OBJCOPY) -j .text -j .data -O ihex $&lt; $@</div>
<div class="line"> </div>
<div class="line">%.srec: %.elf</div>
<div class="line">    $(OBJCOPY) -j .text -j .data -O srec $&lt; $@</div>
<div class="line"> </div>
<div class="line">%.bin: %.elf</div>
<div class="line">    $(OBJCOPY) -j .text -j .data -O binary $&lt; $@</div>
<div class="line"> </div>
<div class="line"># Rules for building the .eeprom rom images</div>
<div class="line"> </div>
<div class="line">eeprom: ehex ebin esrec</div>
<div class="line"> </div>
<div class="line">ehex:  $(PRG)_eeprom.hex</div>
<div class="line">ebin:  $(PRG)_eeprom.bin</div>
<div class="line">esrec: $(PRG)_eeprom.srec</div>
<div class="line"> </div>
<div class="line">%_eeprom.hex: %.elf</div>
<div class="line">    $(OBJCOPY) -j .eeprom --change-section-lma .eeprom=0 -O ihex $&lt; $@ \</div>
<div class="line">    || { echo empty $@ not generated; exit 0; }</div>
<div class="line"> </div>
<div class="line">%_eeprom.srec: %.elf</div>
<div class="line">    $(OBJCOPY) -j .eeprom --change-section-lma .eeprom=0 -O srec $&lt; $@ \</div>
<div class="line">    || { echo empty $@ not generated; exit 0; }</div>
<div class="line"> </div>
<div class="line">%_eeprom.bin: %.elf</div>
<div class="line">    $(OBJCOPY) -j .eeprom --change-section-lma .eeprom=0 -O binary $&lt; $@ \</div>
<div class="line">    || { echo empty $@ not generated; exit 0; }</div>
<div class="line"> </div>
<div class="line"># Every thing below here is used by avr-libc&#39;s build system and can be ignored</div>
<div class="line"># by the casual user.</div>
<div class="line"> </div>
<div class="line">FIG2DEV                 = fig2dev</div>
<div class="line">EXTRA_CLEAN_FILES       = *.hex *.bin *.srec</div>
<div class="line"> </div>
<div class="line">dox: eps png pdf</div>
<div class="line"> </div>
<div class="line">eps: $(PRG).eps</div>
<div class="line">png: $(PRG).png</div>
<div class="line">pdf: $(PRG).pdf</div>
<div class="line"> </div>
<div class="line">%.eps: %.fig</div>
<div class="line">    $(FIG2DEV) -L eps $&lt; $@</div>
<div class="line"> </div>
<div class="line">%.pdf: %.fig</div>
<div class="line">    $(FIG2DEV) -L pdf $&lt; $@</div>
<div class="line"> </div>
<div class="line">%.png: %.fig</div>
<div class="line">    $(FIG2DEV) -L png $&lt; $@</div>
<div class="line"> </div>
</div><!-- fragment --><h1><a class="anchor" id="demo_sourceref"></a>
Reference to the source code</h1>
<p> 
<ul>
  <li><a href="examples/demo/demo.c">demo.c</a></li>
  <li><a href="examples/demo/iocompat.h">iocompat.h</a></li>
  <li><a href="examples/demo/Makefile">Makefile</a></li>
</ul>
</p>
<p> </p>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 24 2025 20:40:11 for AVR-LibC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.6
</small></address>
</body>
</html>
