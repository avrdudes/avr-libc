<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<title>AVR-LibC: Inline Assembler Cookbook</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AVR-LibC
   &#160;<span id="projectnumber">2.3.0git</span>
   </div>
   <div id="projectbrief">Standard C library for AVR-GCC</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table>
  <tr>
    <td align="left"><a href="https://avrdudes.github.io/avr-libc/"><h2>AVR-LibC Documen&shy;tation</h2></a></td>
    <td align="center" colspan=4>
      <div class="logo"><img src="avr-libc-logo.png" alt="Logo" align="middle" border="0"></div>
      <div class="invlogo"><img src="avr-libc-logo-inverted.png" alt="Logo" align="middle" border="0"></div>
    </td>
    <td align="right" colspan=2><a href="https://github.com/avrdudes/avr-libc/"><h2>AVR-LibC Development Pages</h2></a></td>
  </tr>
  <tr>
    <td align="center" width="15%"><a href="index.html"><h2>Main Page</h2></a></td>
    <td align="center" width="15%"><a href="pages.html"><h2>User Manual</h2></a></td>
    <td align="center" width="15%"><a href="modules.html"><h2>Library Refe&shy;rence</h2></a></td>
    <td align="center" width="8%"><a href="FAQ.html"><h2>FAQ</h2></a></td>
    <td align="center" width="15%"><a href="group__demos.html"><h2>Example Projects</h2></a></td>
    <td align="center" width="8%"><a href="files.html"><h2>File List</h2></a></td>
    <td align="center" width="8%"><a href="Global_01Index.html"><h2>Index</h2></a></td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Inline Assembler Cookbook </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>AVR-GCC<br  />
 Inline Assembler Cookbook</p>
<ul>
<li><a class="el" href="inline_asm.html#inline_asm_about">About this Document</a></li>
<li><a class="el" href="inline_asm.html#inline_asm_building_blocks">Building Blocks</a><ul>
<li><a class="el" href="inline_asm.html#inline_asm_anatomy">The Anatomy of a GCC asm Statement</a></li>
<li><a class="el" href="inline_asm.html#inline_asm_special_sequences">Special Sequences</a></li>
<li><a class="el" href="inline_asm.html#inline_asm_constraints">Constraints</a><ul>
<li><a class="el" href="inline_asm.html#constraint_modifiers">Constraint Modifiers</a></li>
<li><a class="el" href="inline_asm.html#instructions_and_constraints">Instructions and Constraints</a></li>
</ul>
</li>
<li><a class="el" href="inline_asm.html#inline_asm_print_modifiers">Print Modifiers</a></li>
<li><a class="el" href="inline_asm.html#assembly_operand_modifiers">Operand Modifiers</a></li>
</ul>
</li>
<li><a class="el" href="inline_asm.html#inline_asm_examples">Examples</a><ul>
<li><a class="el" href="inline_asm.html#inline_asm_swap_nibbles">Swapping Nibbles</a></li>
<li><a class="el" href="inline_asm.html#inline_asm_swap_bytes">Swapping Bytes</a></li>
<li><a class="el" href="inline_asm.html#inline_asm_access_memory">Accessing Memory</a></li>
<li><a class="el" href="inline_asm.html#inline_asm_bytes">Accessing Bytes of wider Expressions</a></li>
<li><a class="el" href="inline_asm.html#builtin_constant_p_in_inline_functions">Inline Functions and __builtin_constant_p</a></li>
<li><a class="el" href="inline_asm.html#inline_asm_jumping">Jumping and Branching</a></li>
</ul>
</li>
<li><a class="el" href="inline_asm.html#inline_asm_local_vars">Binding local Variables to Registers</a><ul>
<li><a class="el" href="inline_asm.html#inline_asm_abi_interface">Interfacing non-ABI Functions</a></li>
</ul>
</li>
<li><a class="el" href="inline_asm.html#c_names_in_asm">Specifying the Assembly Name of Static Objects</a></li>
<li><a class="el" href="inline_asm.html#inline_asm_fails">What won't work</a></li>
</ul>
<h1><a class="anchor" id="inline_asm_about"></a>
About this Document</h1>
<p>The GNU C/C++ compiler for AVR RISC processors offers to embed assembly language code into C/C++ programs. This cool feature may be used for manually optimizing time critical parts of the software, or to use specific processor instructions which are not available in the C language.</p>
<p>It's assumed that you are familiar with writing AVR assembler programs, because this is not an AVR assembler programming tutorial. It's not a C/C++ tutorial either.</p>
<p>Note that this document does not cover files written completely in assembly language, refer to <a class="el" href="assembler.html">AVR-LibC and Assembler Programs</a> for this.</p>
<p>Copyright (C) 2001-2002 by egnite Software GmbH</p>
<p>Permission is granted to copy and distribute verbatim copies of this manual provided that the copyright notice and this permission notice are preserved on all copies. Permission is granted to copy and distribute modified versions of this manual provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</p>
<p>This document describes version 4.7 of the compiler or newer.</p>
<p>Herne, 17th of May 2002 Harald Kipp harald.kipp-at-egnite.de</p>
<p><a class="anchor" id="inline_asm_building_blocks"></a> </p>
<h1><a class="anchor" id="inline_asm_anatomy"></a>
The Anatomy of a GCC asm Statement</h1>
<p>A GCC inline assembly statement starts with the keyword <code>asm</code>, <code>__asm</code> or <code>__asm__</code>, where the first one is not available in strict ANSI mode.</p>
<p>In its simplest form, the inline assembly statement has no operands and injects just one instruction into the code stream, like in </p><div class="fragment"><div class="line">__asm (<span class="stringliteral">&quot;nop&quot;</span>);</div>
</div><!-- fragment --><p> In its generic form, an asm statements can have one of the following three forms:</p>
<dl>
<dt>A simple asm without operands </dt>
<dd><div class="fragment"><div class="line">__asm (code-string);</div>
</div><!-- fragment --><p> <code>code-string</code> is a string literal that will be added as is into the generated assembly code. This even applies to the % character. The only replacement is that \n and \t are interpreted as newline resp. TAB character.</p>
<p class="interdd">This type of asm statement may occur at top level, outside any function as global asm. When its placement relative to functions is important, consider <code>-fno-toplevel-reorder</code>. </p>
<p class="enddd"></p>
</dd>
<dt>An asm with operands </dt>
<dd><div class="fragment"><div class="line">__asm volatile (code-string : output-operands : input-operands : clobbers);</div>
</div><!-- fragment --><p> This is the most widely used form of an asm statement. It must be located in a function.</p>
<p class="interdd"><code>output-operands</code>, <code>input-operands</code> and <code>clobbers</code> are comma-separated lists of operands resp. clobber specifications. Any of them may be empty, for example when the asm has no outputs. At least one <code></code>: (colon) must be present, otherwise it will be a simple asm without operands and without <code>%</code> replacements. </p>
<p class="enddd"></p>
</dd>
<dt>An asm goto statement </dt>
<dd><div class="fragment"><div class="line">__asm goto (code-string : : input-operands : clobbers : labels);</div>
</div><!-- fragment --> Like the asm above, but <code>labels</code> is a comma-separated list of C/C++ code labels which would be valid in a <code>goto</code> statement. And <code>output-operands</code> must be empty, because it is impossible to generate output reloads after the code has transferred control to one of the labels. <br  />
 As there are no output operands, asm goto is implicitly volatile. When <code>volatile</code> is specified explicitly, the <code>goto</code> keyword may be placed after or before the <code>volatile</code>.  </dd>
</dl>
<p>Notes on the various parts:</p>
<dl>
<dt>Volatility </dt>
<dd><p class="startdd">Keyword <code>volatile</code> is optional and means that the asm statement has side effects that are not expressed in terms of the operands or clobbers. The asm statement must not be optimized away or reordered with respect to other volatile statements like volatile memory accesses or other volatile asm.</p>
<p class="interdd">Any asm statement without <code>output-operands</code> is implicitly volatile.</p>
<p class="interdd">A non-volatile asm statement with output operands that are all unused may be optimized away when all output operands are unused.</p>
<p class="interdd">Instead of <code>volatile</code>, <code>__volatile</code> or <code>__volatile__</code> can be used. </p>
<p class="enddd"></p>
</dd>
<dt><code>code-string</code> </dt>
<dd><p class="startdd">A string literal that contains the code that is to be injected in the assembly code generated by the compiler. <code>%-expressions</code> are replaced by the string representations of the operands, and the number of lines is determined to estimate the code size of the asm.<br  />
 Apart from that, <b>the compiler does not analyze the code provided in the code template.</b><br  />
 This means that the code appears to the compiler <em>as if it was executed in one parallel chunk, all at once</em>. It is important to keep that in mind, in particular for cases where input and output operands may overlap. </p>
<p class="enddd"></p>
</dd>
<dt><code>output-operands</code> </dt>
<dd></dd>
<dt><code>input-operands</code> </dt>
<dd><p class="startdd">A comma-separated list of operands, which may take the following forms. In any case, the first operand can be referred to as <code>"%0"</code> in <code>code-string</code>, the second one as <code>"%1"</code> etc. </p><dl>
<dt><code>"constraints" (expr)</code> </dt>
<dd><code>expr</code> is a C expression that's an input or output (or both) to the asm statement. An output expression must be an lvalue, i.e. it must be valid to assign a value to it. <br  />
 <code>"constraints"</code> is a string literal with <a class="el" href="inline_asm.html#constraints">constraints</a> and <a class="el" href="inline_asm.html#constraint_modifiers">constraint modifiers</a>. For example, constraint <code>"r"</code> stands for <em>general-purpose register</em>. A simple input operand would be <div class="fragment"><div class="line"><span class="stringliteral">&quot;r&quot;</span> (value + 1)</div>
</div><!-- fragment --> The compiler computes <code>value + 1</code> and supplies it in some general-purpose register R2...R31. In many cases, an upper d-register R16...R31 is required for instructions like <code>LDI</code> or <code>ANDI</code>. A respective output operand specification is <div class="fragment"><div class="line"><span class="stringliteral">&quot;=d&quot;</span> (result)</div>
</div><!-- fragment --> <b>Notice that this operand may overlap with input operands!</b><br  />
 When an operand is written before all input operands are consumed, then in almost all cases the output operand requires an early-clobber modifier <code>&amp;</code> so that it won't overlap with any input operand: <div class="fragment"><div class="line"><span class="stringliteral">&quot;=&amp;d&quot;</span> (result)</div>
</div><!-- fragment --> An operand that's both an output and an input can be expressed with the <code>+</code> constraint modifier: <div class="fragment"><div class="line"><span class="stringliteral">&quot;+d&quot;</span> (result)</div>
</div><!-- fragment --> Such an operand is both output and input, and hence it won't overlap with other operands.  </dd>
<dt><code>[name] "constraints" (expr)</code> </dt>
<dd>Like above. In addition, a named operand can be referred to as <code>%[name]</code> in <code>code-string</code>. This is useful in long asm statements with many operands.  </dd>
</dl>
<p class="enddd"></p>
</dd>
<dt><code>clobbers</code> </dt>
<dd><p class="startdd">A comma-separated list of string literals like <code>"16"</code>, "r16" or "memory".</p>
<p class="interdd">The first two clobbers mean that the asm destroys register R16. Only the lower-case form is allowed, and register names like Z are not recognized. A register that's clobbered will not be used as (part of) an input or output operand.</p>
<p class="interdd"><code>"memory"</code> means that the asm touches memory in some way. When the asm writes to some RAM location for example, the compiler must not optimize RAM accesses across the asm because the memory may change.</p>
<p class="interdd">Clobbering <code><a class="el" href="FAQ.html#tmp_reg">__tmp_reg__</a></code> by means of <code>"r0"</code> has no effect, but such a clobber may be added to indicate to the reader that the asm clobbers R0.</p>
<p class="interdd">Clobbering <code><a class="el" href="FAQ.html#zero_reg">__zero_reg__</a></code> by means of <code>"r1"</code> has no effect. When the asm destroys the zero register, for example by means of a <code>MUL</code> instruction, then the code must restore the register at the end by means of <code>"clr __zero_reg__"</code> </p>
<p class="enddd"></p>
</dd>
<dt>The size of an asm<a class="anchor" id="inline_asm_size"></a> </dt>
<dd><p class="startdd">The code size of an asm statement is the number of lines multiplied by 4&#160;bytes, the maximal possible AVR instruction length. The length is needed when (conditional) jumps cross the asm statement in order to compute (upper bounds for) jump offsets of PC-relative jumps.</p>
<p class="enddd">The number of lines is one plus the number of line breaks in <code>code-string</code>. These may be physical line breaks from <code>\n</code> characters and logical line breaks from <code>$</code> characters.  </p>
</dd>
</dl>
<p>Before we start with the first examples, we list all the bells and whistles that can be used to compose an inline assembly statement: <a class="el" href="inline_asm.html#special_sequences">special sequences</a>, <a class="el" href="inline_asm.html#constraints">constraints</a>, <a class="el" href="inline_asm.html#constraint_modifiers">constraint modifiers</a>, <a class="el" href="inline_asm.html#print_modifiers">print modifiers</a> and <a class="el" href="inline_asm.html#operand_modifiers">operand modifiers</a>.</p>
<h1><a class="anchor" id="inline_asm_special_sequences"></a>
Special Sequences</h1>
<p>There are special sequences that can be used in the assembly template.</p>
<p>Resolution of <code>%</code> is only performed when the inline asm has operands or clobbers. For example, <code>asm("%%")</code> inserts <em>two</em> <code>%</code>'s whereas <code>asm("%%":)</code> only inserts one.</p>
<p><a class="anchor" id="special_sequences"></a></p><table class="doxtable">
<caption>Inline asm Special Sequences</caption>
<tr>
<th>Sequence </th><th>Description  </th></tr>
<tr>
<td><code>__SREG__</code> </td><td>The I/O address of the status register SREG at 0x3F  </td></tr>
<tr>
<td><code>__tmp_reg__</code> </td><td>The <a class="el" href="FAQ.html#tmp_reg">temporary register</a> R0 (R16 on reduced Tiny)  </td></tr>
<tr>
<td><code>__zero_reg__</code> </td><td>The <a class="el" href="FAQ.html#zero_reg">zero register</a> R1, always zero (R17 on reduced Tiny)  </td></tr>
<tr>
<td><code>$</code> </td><td>A logical line separator, used to separate multiple instructions in one physical line  </td></tr>
<tr>
<td><code>\n</code> </td><td>A physical newline, used to separate multiple instructions  </td></tr>
<tr>
<td><code>\t</code> </td><td>A TAB character, can be used for better legibility of the generated asm  </td></tr>
<tr>
<td><code>\"</code> </td><td>A <code>"</code> character (double quote)  </td></tr>
<tr>
<td><code>\\</code> </td><td>A <code>\</code> character (backslash)  </td></tr>
<tr>
<td><code>%%</code> </td><td>A <code>%</code> charater (percent)  </td></tr>
<tr>
<td><code>%~</code> </td><td><code>"r"</code> or <code>""</code>, used to construct <code>call</code> or <code>rcall</code> by means of <code>"%~call"</code>, depending on the architecture  </td></tr>
<tr>
<td><code>%!</code> </td><td><code>""</code> or <code>"e"</code>, used to construct indirect calls like <code>icall</code> or <code>eicall</code> by means of <code>"%!icall"</code>, depending on the architecture  </td></tr>
<tr>
<td><code>%=</code> </td><td>A number that's unique for the compilation unit and the respective inline asm code, used to construct unique labels  </td></tr>
<tr>
<th>Comment </th><th>Description  </th></tr>
<tr>
<td><code>; text</code> </td><td>A single-line assembly comment that extends to the end of the physical line  </td></tr>
<tr>
<td><code>/* text */</code> </td><td>A multi-line C comment  </td></tr>
</table>
<ul>
<li>Moreover, the following I/O addresses are defined provided the device supports the respective SFR: <code>__SP_L__</code>, <code>__SP_H__</code>, <code>__CCP__</code>, <code>__RAMPX__</code>, <code>__RAMPY__</code>, <code>__RAMPZ__</code>, <code>__RAMPD__</code>.</li>
<li>Register <code>__tmp_reg__</code> may be freely used by inline assembly code and need not be restored at the end of the code.</li>
<li>Register <code>__zero_reg__</code> contains a value of zero. When that value is destroyed, for example by a <code>MUL</code> instruction, its value has to be restored at the end of the code by means of <div class="fragment"><div class="line">clr __zero_reg__</div>
</div><!-- fragment --></li>
<li>In inline asm without operands (i.e without a single colon), a <code>%</code> will always insert a single <code>%</code>. No <code>%-codes</code> are available.</li>
</ul>
<p>Sequences like <code>__SREG__</code> are not evaluated as part of the inline asm, they are just copied to the asm code as they are. At the top of each assembly file, the compiler prints definitions like </p><div class="fragment"><div class="line">__SREG__ = 0x3f</div>
</div><!-- fragment --><p> so that they can also be used in inline assembly.</p>
<h1><a class="anchor" id="inline_asm_constraints"></a>
Constraints</h1>
<p>The most up-to-date and detailed information on constraints for the AVR can be found in the <a href="https://gcc.gnu.org/wiki/avr-gcc#Constraints">avr-gcc Wiki</a>.</p>
<p><a class="anchor" id="constraints"></a></p><table class="doxtable">
<caption>Inline asm Operand Constraints</caption>
<tr>
<th>Constraint </th><th>Registers </th><th>Range  </th></tr>
<tr>
<td><code>a</code> </td><td>Simple upper registers that support <code>FMUL</code>  </td><td>R16 ... R23 </td></tr>
<tr>
<td><code>b</code> </td><td>Base pointer registers that support <code>LDD</code>, <code>STD</code>  </td><td>Y, Z (R28 ... R31) </td></tr>
<tr>
<td><code>d</code> </td><td>Upper registers</td><td>R16 ... R31 </td></tr>
<tr>
<td><code>e</code> </td><td>Pointer registers that support <code>LD</code>, <code>ST</code>  </td><td>X, Y, Z (R26 ... R31) </td></tr>
<tr>
<td><code>l</code> </td><td>Lower registers</td><td>R2 ... R15 </td></tr>
<tr>
<td><code>r</code> </td><td>Any register</td><td>R2 ... R31 </td></tr>
<tr>
<td><code>w</code> </td><td>Upper registers that support <code>ADIW</code>  </td><td>R24 ... R31 </td></tr>
<tr>
<td><code>x</code> </td><td>X pointer registers</td><td>R26, R27 </td></tr>
<tr>
<td><code>y</code> </td><td>Y pointer registers</td><td>R28, R29 </td></tr>
<tr>
<td><code>z</code> </td><td>Z pointer registers</td><td>R30, R31 </td></tr>
<tr>
<th>Constraint </th><th>Constant </th><th>Range  </th></tr>
<tr>
<td><code>I</code> </td><td>6-bit unsigned integer constant</td><td>0 to 63 </td></tr>
<tr>
<td><code>J</code> </td><td>6-bit negative integer constant</td><td>&minus;63 to 0 </td></tr>
<tr>
<td><code>M</code> </td><td>8-bit unsigned integer constant</td><td>0 to 255 </td></tr>
<tr>
<td><code>n</code> </td><td>Integer constant</td><td></td></tr>
<tr>
<td><code>i</code> </td><td>Immediate value known at link-time, like the address of a variable in static storage</td><td></td></tr>
<tr>
<td><code>F</code> </td><td>floating-point constant</td><td></td></tr>
<tr>
<td><code>Ynn</code> </td><td>Fixed-point or integer constant</td><td></td></tr>
<tr>
<th>Constraint </th><th>Explanation </th><th>Notes  </th></tr>
<tr>
<td><code>m</code> </td><td>A memory location</td><td></td></tr>
<tr>
<td><code>X</code> </td><td>Any valid operand</td><td></td></tr>
<tr>
<td><code>0</code> ... <code>9</code> </td><td>Matches the respective operand number</td><td></td></tr>
</table>
<p><a class="anchor" id="constraint_modifiers"></a></p><ul>
<li>Constraints without a modifier specify input operands.</li>
<li>Constraints with a modifier specify output operands.</li>
<li>More than one constraint like in <code>"rn"</code> specifies the union of the specified constraints; <code>"r"</code> and <code>"n"</code> in this case.</li>
<li>All constraints listed above are single-letter constraints, except <code>Ynn</code> which is a 3-letter constraint.</li>
<li>According to the avr-gcc ABI, values that occupy more than one register will start at an even register number.</li>
</ul>
<p>Constraint modifiers are:</p>
<table class="doxtable">
<caption>Constraint Modifiers</caption>
<tr>
<th>Modifier </th><th>Meaning  </th></tr>
<tr>
<td><code>=</code> </td><td>Output-only operand. Without <code>&amp;</code> it may overlap with input operands  </td></tr>
<tr>
<td><code>+</code> </td><td>Output operand that's also an input  </td></tr>
<tr>
<td><code>=&amp;</code> </td><td>"Early-clobber". Register should be used for output only and won't overlap with any input operand(s)  </td></tr>
</table>
<p>Examples:</p>
<dl>
<dt><code>"a" (10)</code> </dt>
<dd>Load the value of 10 into a register in the range of the <code>a</code> constraint, i.e. R16...R23. As <code>int</code> is a 16-bit value, so is <code>10</code>, and the constant will occupy two consecutive hard registers.  </dd>
<dt><code>"a" ((uint8_t) 10)</code> </dt>
<dd>Same, but this time the constant only occupies one register.  </dd>
<dt><code>"I" (10)</code> </dt>
<dd>The literal value <code>10</code> can be used in the according <code>%</code> operand.  </dd>
<dt><code>"J" (10)</code> </dt>
<dd>An error: The value 10 is not in the range &minus;63...0 of the <code>J</code> constraint.  </dd>
<dt><code>"=a" (10)</code> </dt>
<dd>An error: <code>10</code> is not an lvalue and cannot be written to.  </dd>
<dt><code>"a" (var)</code> </dt>
<dd>The variable <code>var</code> will be loaded into a register in the range R16...R23. A 4-byte value will occupy 4 consecutive registers etc.  </dd>
<dt><code>"+a" (var)</code> </dt>
<dd>The variable <code>var</code> will be loaded into a register in the range R16...R23. It is an input as well as an output of the inline asm, i.e. it must be an lvalue. Otherwise, e.g. when <code>var</code> is read-only, the compiler will complain.  </dd>
<dt><code>"I" (var)</code> </dt>
<dd>In most cases, this is an error because <code>var</code> is not known at compile-time. Only when <code>__builtin_constant_p(var)</code> is true and <code>var</code> is in the range 0...63, then <code>var</code> is accepted by the compiler.  </dd>
</dl>
<p>The selection of the proper constraint depends on the range of the constants or registers, which must be acceptable to the AVR instruction they are used with. The C compiler doesn't check any line of your assembler code. But it is able to check the constraint against your C expression. However, if you specify the wrong constraints, then the compiler may silently pass wrong code to the assembler. And, of course, the assembler will fail with some cryptic output or internal errors, or in the worst case wrong code may be the result.</p>
<p>For example, if you specify the constraint <code>"r"</code> and you are using this register with an <code>ORI</code> instruction, then the compiler may select any register. This will fail if the compiler chooses <code>R2</code> to <code>R15</code>. (It will never choose <code>R0</code> or <code>R1</code>, because these are uses for special purposes.) That's why the correct constraint in that case is <code>"d"</code>. On the other hand, if you use the constraint <code>"M"</code>, the compiler will make sure that you don't pass anything else but an 8-bit unsigned integer value known at compile-time.</p>
<p>The following table shows all AVR assembler mnemonics which require operands, and the related constraints.</p>
<p><a class="anchor" id="instructions_and_constraints"></a></p><table class="doxtable">
<caption>AVR Instructions and Constraints</caption>
<tr>
<th>Mnemonic </th><th>Constraints </th><td></td><th>Mnemonic </th><th>Constraints  </th></tr>
<tr>
<td><code>adc</code> </td><td><code>r,r</code> </td><td rowspan="36"></td><td><code>add</code> </td><td><code>r,r</code>  </td></tr>
<tr>
<td><code>adiw</code> </td><td><code>w,I</code> </td><td><code>and</code> </td><td><code>r,r</code>  </td></tr>
<tr>
<td><code>andi</code> </td><td><code>d,M</code> </td><td><code>asr</code> </td><td><code>r</code>  </td></tr>
<tr>
<td><code>bclr</code> </td><td><code>I</code> </td><td><code>bld</code> </td><td><code>r,I</code>  </td></tr>
<tr>
<td><code>brbc</code> </td><td><code>I,label</code> </td><td><code>brbs</code> </td><td><code>I,label</code>  </td></tr>
<tr>
<td><code>bset</code> </td><td><code>I</code> </td><td><code>bst</code> </td><td><code>r,I</code>  </td></tr>
<tr>
<td><code>call</code> </td><td><code>i</code> </td><td><code>cbi</code> </td><td><code>I,I</code>  </td></tr>
<tr>
<td><code>cbr</code> </td><td><code>d,I</code> </td><td><code>clr</code> </td><td><code>r</code>  </td></tr>
<tr>
<td><code>com</code> </td><td><code>r</code> </td><td><code>cp</code> </td><td><code>r,r</code>  </td></tr>
<tr>
<td><code>cpc</code> </td><td><code>r,r</code> </td><td><code>cpi</code> </td><td><code>d,M</code>  </td></tr>
<tr>
<td><code>cpse</code> </td><td><code>r,r</code> </td><td><code>dec</code> </td><td><code>r</code>  </td></tr>
<tr>
<td><code>elpm</code> </td><td><code>r,z</code> </td><td><code>eor</code> </td><td><code>r,r</code>  </td></tr>
<tr>
<td><code>fmul</code> </td><td><code>a,a</code> </td><td><code>fmuls</code> </td><td><code>a,a</code>  </td></tr>
<tr>
<td><code>fmulsu</code> </td><td><code>a,a</code> </td><td><code>in</code> </td><td><code>r,I</code>  </td></tr>
<tr>
<td><code>inc</code> </td><td><code>r</code> </td><td><code>jmp</code> </td><td><code>i</code>  </td></tr>
<tr>
<td><code>lac</code> </td><td><code>z,r</code> </td><td><code>las</code> </td><td><code>z,r</code>  </td></tr>
<tr>
<td><code>lat</code> </td><td><code>z,r</code> </td><td><code>ld</code> </td><td><code>r,e</code>  </td></tr>
<tr>
<td><code>ldd</code> </td><td><code>r,b</code> </td><td><code>ldi</code> </td><td><code>d,M</code>  </td></tr>
<tr>
<td><code>lds</code> </td><td><code>r,i</code> </td><td><code>lpm</code> </td><td><code>r,z</code>  </td></tr>
<tr>
<td><code>lsl</code> </td><td><code>r</code> </td><td><code>lsr</code> </td><td><code>r</code>  </td></tr>
<tr>
<td><code>mov</code> </td><td><code>r,r</code> </td><td><code>movw</code> </td><td><code>r,r</code>  </td></tr>
<tr>
<td><code>mul</code> </td><td><code>r,r</code> </td><td><code>muls</code> </td><td><code>r,r</code>  </td></tr>
<tr>
<td><code>mulsu</code> </td><td><code>a,a</code> </td><td><code>neg</code> </td><td><code>r</code>  </td></tr>
<tr>
<td><code>or</code> </td><td><code>r,r</code> </td><td><code>ori</code> </td><td><code>d,M</code>  </td></tr>
<tr>
<td><code>out</code> </td><td><code>I,r</code> </td><td><code>pop</code> </td><td><code>r</code>  </td></tr>
<tr>
<td><code>push</code> </td><td><code>r</code> </td><td><code>rcall</code> </td><td><code>i</code>  </td></tr>
<tr>
<td><code>rjmp</code> </td><td><code>i</code> </td><td><code>rol</code> </td><td><code>r</code>  </td></tr>
<tr>
<td><code>ror</code> </td><td><code>r</code> </td><td><code>sbc</code> </td><td><code>r,r</code>  </td></tr>
<tr>
<td><code>sbci</code> </td><td><code>d,M</code> </td><td><code>sbi</code> </td><td><code>I,I</code>  </td></tr>
<tr>
<td><code>sbic</code> </td><td><code>I,I</code> </td><td><code>sbiw</code> </td><td><code>w,I</code>  </td></tr>
<tr>
<td><code>sbr</code> </td><td><code>d,M</code> </td><td><code>sbrc</code> </td><td><code>r,I</code>  </td></tr>
<tr>
<td><code>sbrs</code> </td><td><code>r,I</code> </td><td><code>ser</code> </td><td><code>d</code>  </td></tr>
<tr>
<td><code>st</code> </td><td><code>e,r</code> </td><td><code>std</code> </td><td><code>b,r</code>  </td></tr>
<tr>
<td><code>sts</code> </td><td><code>i,r</code> </td><td><code>sub</code> </td><td><code>r,r</code>  </td></tr>
<tr>
<td><code>subi</code> </td><td><code>d,M</code> </td><td><code>swap</code> </td><td><code>r</code>  </td></tr>
<tr>
<td><code>tst</code> </td><td><code>r</code> </td><td><code>xch</code> </td><td><code>z,r</code>  </td></tr>
</table>
<h1><a class="anchor" id="inline_asm_print_modifiers"></a>
Print Modifiers</h1>
<p>The %-operands in the inline assembly template can be adjusted by special print-modify characters. The one-letter modifier follows the <code>%</code> and precedes the operand number like in <code>"%a0"</code>, or precedes the name in named operands like in <code>"%a[address]"</code>.</p>
<p><a class="anchor" id="print_modifiers"></a></p><table class="doxtable">
<caption>Inline asm Print Modifiers</caption>
<tr>
<th>Modifier </th><th>Number of<br  />
Arguments </th><th>Explanation </th><th>Suitable<br  />
Constraints  </th></tr>
<tr>
<td><code>%a0</code> </td><td>1 </td><td>Print pointer register as address <code>X</code>, <code>Y</code> or <code>Z</code>, like in <code>"LD r0, %a0+"</code> </td><td><code>x</code>, <code>y</code>, <code>z</code>, <code>b</code>, <code>e</code>  </td></tr>
<tr>
<td><code>%i0</code> </td><td>1 </td><td>Print compile-time RAM address as I/O address, like in <code>"OUT %i0, r0"</code> with argument <code>"n"(&amp;SREG)</code> </td><td><code>n</code>  </td></tr>
<tr>
<td><code>%n0</code> </td><td>1 </td><td>Print the negative of a compile-time integer constant </td><td><code>n</code>  </td></tr>
<tr>
<td><code>%r0</code> </td><td>1 </td><td>Print the register number of a register, like in <code>"CLR %r0+7"</code> for the MSB of a 64-bit register </td><td>reg  </td></tr>
<tr>
<td><code>%x0</code> </td><td>1 </td><td>Print a function name without <code>gs()</code> modifier, like in <code>"%~CALL %x0"</code> with argument <code>"s"(main)</code> </td><td><code>s</code>  </td></tr>
<tr>
<td><code>%A0</code> </td><td>1 </td><td>Add 0 to the register number (no effect) </td><td>reg  </td></tr>
<tr>
<td><code>%B0</code> </td><td>1 </td><td>Add 1 to the register number </td><td>reg  </td></tr>
<tr>
<td><code>%C0</code> </td><td>1 </td><td>Add 2 to the register number </td><td>reg  </td></tr>
<tr>
<td><code>%D0</code> </td><td>1 </td><td>Add 3 to the register number </td><td>reg  </td></tr>
<tr>
<td><code>%T0%t1</code> </td><td>2 </td><td>Print the register that holds bit number <code>%1</code> of register <code>%0</code> </td><td>reg + <code>n</code>  </td></tr>
<tr>
<td><code>%T0%T1</code> </td><td>2 </td><td>Print operands suitable for <code>BLD</code>/<code>BST</code>, like in <code>"BST %T0%T1"</code>, including the required <code>,</code> </td><td>reg + <code>n</code>  </td></tr>
</table>
<ul>
<li>Register constraints are: <code>r</code>, <code>d</code>, <code>w</code>, <code>x</code>, <code>y</code>, <code>z</code>, <code>b</code>, <code>e</code>, <code>a</code>, <code>l</code>.</li>
</ul>
<h1><a class="anchor" id="assembly_operand_modifiers"></a>
Operand Modifiers</h1>
<p><a class="anchor" id="operand_modifiers"></a></p><table class="doxtable">
<caption>Assembly Code Operand Modifiers</caption>
<tr>
<th>Modifier </th><th>Explanation </th><th>Purpose  </th></tr>
<tr>
<td><code>lo8()</code> </td><td>1<sup>st</sup> Byte of a link-time constant, bits 0...7 </td><td rowspan="5">Getting parts<br  />
of a byte-address  </td></tr>
<tr>
<td><code>hi8()</code> </td><td>2<sup>nd</sup> Byte of a link-time constant, bits 8...15  </td></tr>
<tr>
<td><code>hlo8()</code> </td><td>3<sup>rd</sup> Byte of a link-time constant, bits 16...23  </td></tr>
<tr>
<td><code>hhi8()</code> </td><td>4<sup>th</sup> Byte of a link-time constant, bits 24...31  </td></tr>
<tr>
<td><code>hh8()</code> </td><td>Same like <code>hlo8</code>  </td></tr>
<tr>
<td><code>pm_lo8()</code> </td><td>1<sup>st</sup> Byte of a link-time constant divided by 2, bits 1...8 </td><td rowspan="3">Getting parts<br  />
of a word-address  </td></tr>
<tr>
<td><code>pm_hi8()</code> </td><td>2<sup>nd</sup> Byte of a link-time constant divided by 2, bits 9...16  </td></tr>
<tr>
<td><code>pm_hh8()</code> </td><td>3<sup>rd</sup> Byte of a link-time constant divided by 2, bits 17...24  </td></tr>
<tr>
<td><code>pm()</code> </td><td>Link-time constant divided by 2 in order to get a <b>p</b>rogram <b>m</b>emory (word) addresses, like in <code>lo8(pm(main))</code> </td><td>Word-address  </td></tr>
<tr>
<td><code>gs()</code> </td><td>Function address divided by 2 in order to get a (word) addresses, like in <code>lo8(gs(main))</code>. <b>G</b>enerate <b>s</b>tub (trampoline) as needed. This is required to calculate the address of a code label on devices with more than 128&#160;KiB of program memory that's supposed to be used in <code>EICALL</code>. For rationale, see the <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#eind">GCC documentation</a>. On devices with less program memory, <code>gs()</code> behaves like <code>pm()</code> </td><td>Function address<br  />
for <code>[E]ICALL</code>  </td></tr>
</table>
<p>When the argument of a modifier is not computable at assembler-time, then the assembler has to encode the expression in an abstract form using <a href="https://github.com/bminor/binutils-gdb/blob/master/include/elf/avr.h">RELOCs</a>. Consequence is that only a very limited number of argument expressions is supported when they are not computable at assembler-time.</p>
<h1><a class="anchor" id="inline_asm_examples"></a>
Examples</h1>
<p>Some examples show the assembly code as generated by the compiler. It's the code from the <code>.s</code> files as generated with option <code>-save-temps</code>. Adding the high-level source to the generated assembly can be turned on with <code><a class="el" href="using_tools.html#opt_fverbose_asm">-fverbose-asm</a></code> since GCC v8.</p>
<h2><a class="anchor" id="inline_asm_swap_nibbles"></a>
Swapping Nibbles</h2>
<p>The first example uses the <code>swap</code> instruction to swap the nibbles of a byte. Input and output of <code>swap</code> are located in the same general purpose register. This means the input operand, operand 1 below, must be located in the same register(s) like operand 0, so that the right <a class="el" href="inline_asm.html#constraints">constraint</a> for operand 1 is <code>"0"</code>: </p><div class="fragment"><div class="line"><span class="keyword">asm</span> (<span class="stringliteral">&quot;swap&quot;</span> : <span class="stringliteral">&quot;=r&quot;</span> (value) : <span class="stringliteral">&quot;0&quot;</span> (value));</div>
</div><!-- fragment --><p> All side effects of the code are described by the constraints and the clobbers, so that there is no need for this asm to be volatile. In particular, this asm may be optimized out when the output value is unused.<br  />
 A shorter pattern to state that <code>value</code> is both input and output is by means of <a class="el" href="inline_asm.html#constraint_modifiers">constraint modifier</a> <code>+</code> </p><div class="fragment"><div class="line"><span class="keyword">asm</span> (<span class="stringliteral">&quot;swap&quot;</span> : <span class="stringliteral">&quot;+r&quot;</span> (value));</div>
</div><!-- fragment --><h2><a class="anchor" id="inline_asm_swap_bytes"></a>
Swapping Bytes</h2>
<p>Swapping nibbles was a piece of cake, so let's swap the bytes of a 16-bit value. In order to access the constituent bytes of the 16-bit input and output values, we use the <a class="el" href="inline_asm.html#inline_asm_print_modifiers">print modifiers</a> <code>%A</code> and <code>%B</code>.</p>
<p>The asm is placed in a small C test case so that we can inspect the resulting assembly code as generated by the compiler with <code>-save-temps</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> callee (<span class="keywordtype">int</span>, <span class="keywordtype">int</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> func (<span class="keywordtype">int</span> param)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> swapped;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">asm</span> (<span class="stringliteral">&quot;mov %A0, %B1&quot;</span> <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">         <span class="stringliteral">&quot;mov %B0, %A1&quot;</span></div>
<div class="line">         : <span class="stringliteral">&quot;=r&quot;</span> (swapped) : <span class="stringliteral">&quot;r&quot;</span> (param));</div>
<div class="line"> </div>
<div class="line">    callee (param, swapped);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>"\n\t"</code> <a class="el" href="inline_asm.html#special_sequences">sequence</a> adds a line feed that is required between the two instructions, and a TAB to align the two instructions in the generated assembly. There is no <code>"\n\t"</code> after the last instruction because that would just increase the <a class="el" href="inline_asm.html#inline_asm_size">size of the asm</a>.<br  />
 The generated assembly works as expected. The compiler wraps it in <code>#APP</code> / <code>#NOAPP</code> annotations: </p><div class="fragment"><div class="line">func:</div>
<div class="line"><span class="comment">/* #APP */</span></div>
<div class="line">    mov r22, r25     ;  swapped, param</div>
<div class="line">    mov r23, r24     ;  swapped, param</div>
<div class="line"><span class="comment">/* #NOAPP */</span></div>
<div class="line">    jmp callee</div>
</div><!-- fragment --><p>Wrong! <b>While the generated code above is correct, the inline asm itself is not!</b> <br  />
 We see this with a slightly adjusted test case where the arguments of <code>callee</code> have been swapped, but that uses the same inline asm: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func (<span class="keywordtype">int</span> param)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> swapped;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">asm</span> (<span class="stringliteral">&quot;mov %A0, %B1&quot;</span> <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">         <span class="stringliteral">&quot;mov %B0, %A1&quot;</span></div>
<div class="line">         : <span class="stringliteral">&quot;=r&quot;</span> (swapped) : <span class="stringliteral">&quot;r&quot;</span> (param));</div>
<div class="line"> </div>
<div class="line">    callee (swapped, param);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The result is the following assembly:</p>
<div class="fragment"><div class="line">func:</div>
<div class="line">    movw r22,r24</div>
<div class="line"><span class="comment">/* #APP */</span></div>
<div class="line">    mov r24, r25     ;  swapped, param</div>
<div class="line">    mov r25, r24     ;  swapped, param</div>
<div class="line"><span class="comment">/* #NOAPP */</span></div>
<div class="line">    jmp callee</div>
</div><!-- fragment --><p>which is obviously wrong, because after the code from the inline asm, the low byte of <code>swapped</code> and the high byte will always have the same value of <code>r25</code>.</p>
<p>The reason is that the output operand overlaps the input, <em>and</em> the output is changed before all of the input operands are consumed. This is a so-called <em>early-clobber</em> situation. There are two possible solutions to this predicament:</p>
<ul>
<li>Mark the output operand with the early-clobber <a class="el" href="inline_asm.html#constraint_modifiers">constraint modifier</a>: <div class="fragment"><div class="line"><span class="keyword">asm</span> (<span class="stringliteral">&quot;mov %A0, %B1&quot;</span> <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">     <span class="stringliteral">&quot;mov %B0, %A1&quot;</span></div>
<div class="line">     : <span class="stringliteral">&quot;=&amp;r&quot;</span> (swapped) : <span class="stringliteral">&quot;r&quot;</span> (param));</div>
</div><!-- fragment --></li>
<li>Use constraints and a code sequence that expect input and output in the same registers: <div class="fragment"><div class="line"><span class="keyword">asm</span> (<span class="stringliteral">&quot;eor %A0, %B0&quot;</span> <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">     <span class="stringliteral">&quot;eor %B0, %A0&quot;</span> <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">     <span class="stringliteral">&quot;eor %A0, %B0&quot;</span></div>
<div class="line">     : <span class="stringliteral">&quot;=r&quot;</span> (swapped) : <span class="stringliteral">&quot;0&quot;</span> (param));</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="inline_asm_access_memory"></a>
Accessing Memory</h2>
<p>Accessing memory requires that the AVR instructions that perform the memory access are provided with the appropriate memory address.</p>
<ol type="1">
<li>The address can be provided directly, like <code>__SREG__</code>, 0x3f, as a symbol, or as a symbol plus a constant offset.</li>
<li>Provide the address by means of an inline asm operand.</li>
</ol>
<p>Approach 1 is simpler as it does not require an asm operand, while approach 2 is in many cases more powerful because macros defined per, say, <code>#include &lt;<a class="el" href="io_8h.html">avr/io.h</a>&gt;</code> can be used as operands, whereas such headers are not included in the assembly code as generated by the compiler.</p>
<p>Reading a SFR like <code>PORTB</code> can be performed by </p><div class="fragment"><div class="line"><span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">&quot;in %0, %i1&quot;</span> : <span class="stringliteral">&quot;=r&quot;</span> (result) : <span class="stringliteral">&quot;I&quot;</span> (&amp; PORTB));</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line"><span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">&quot;in %0, %1&quot;</span> : <span class="stringliteral">&quot;=r&quot;</span> (result) : <span class="stringliteral">&quot;I&quot;</span> (_SFR_IO_ADDR (PORTB)));</div>
</div><!-- fragment --><p>where the former with <a class="el" href="inline_asm.html#print_modifiers">print modifier</a> <code>%i</code> is only supported since GCC v4.7. Macro <code>_SFR_IO_ADDR</code> is provided by <code><a class="el" href="sfr__defs_8h_source.html">avr/sfr_defs.h</a></code> which is included by <code><a class="el" href="io_8h.html">avr/io.h</a></code>.</p>
<p>When the address is not an I/O address, then <code>LDS</code> or <code>LD</code> must be used, depending on whether the address is known at link-time or only at run-time. For example, the following macro provides the functionality to clear an SFR. The code discriminates between the possibilities that</p><ul>
<li>The SFR address is known at compile-time and is an I/O address.</li>
<li>The SFR address is known at compile-time but is not in the I/O range.</li>
<li>The SFR address is not known at compile-time.</li>
</ul>
<div class="fragment"><div class="line">#include &lt;avr/io.h&gt;</div>
<div class="line"> </div>
<div class="line">#define CLEAR_REG(sfr)                          \</div>
<div class="line">do {                                            \</div>
<div class="line">  if (__builtin_constant_p (&amp; (sfr))            \</div>
<div class="line">      &amp;&amp; _SFR_IO_REG_P (sfr))                   \</div>
<div class="line">    asm volatile (&quot;out %i0, __zero_reg__&quot;       \</div>
<div class="line">                  :: &quot;I&quot; (&amp; (sfr)) : &quot;memory&quot;); \</div>
<div class="line">  else if (__builtin_constant_p (&amp; (sfr)))      \</div>
<div class="line">    asm volatile (&quot;sts %0, __zero_reg__&quot;        \</div>
<div class="line">                  :: &quot;n&quot; (&amp; (sfr)) : &quot;memory&quot;); \</div>
<div class="line">  else                                          \</div>
<div class="line">    asm volatile (&quot;st %a0, __zero_reg__&quot;        \</div>
<div class="line">                  :: &quot;e&quot; (&amp; (sfr)) : &quot;memory&quot;); \</div>
<div class="line">} while (0)</div>
</div><!-- fragment --><p>The last case with constraint <code>"e"</code> works because <code>&amp;sfr</code> is a 16-bit value, and 16-bit values (and larger) start in even registers. Therefore, the address will be located in R27:R26, R29:R28 or in R31:R30, which print modifier <code>%a</code> will print as X, Y or Z, respectively. The address will never end up in, say, R30:R29.</p>
<p>The test case</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> clear_3_regs (<a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> <span class="keyword">volatile</span> *psfr)</div>
<div class="line">{</div>
<div class="line">    CLEAR_REG (PORTB);</div>
<div class="line">    CLEAR_REG (UDR0);</div>
<div class="line">    CLEAR_REG (*psfr);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__stdint_html_gaba7bc1797add20fe3efdf37ced1182c5"><div class="ttname"><a href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a></div><div class="ttdeci">unsigned char uint8_t</div><div class="ttdef"><b>Definition:</b> stdint.h:81</div></div>
</div><!-- fragment --><p>compiles for ATmega328 and with optimization turned on to</p>
<div class="fragment"><div class="line">clear_3_regs:</div>
<div class="line">    movw r30,r24</div>
<div class="line"><span class="comment">/* #APP */</span></div>
<div class="line">    out 0x5, __zero_reg__</div>
<div class="line">    sts 198, __zero_reg__</div>
<div class="line">    st Z,    __zero_reg__   ;  psfr</div>
<div class="line"><span class="comment">/* #NOAPP */</span></div>
<div class="line">    ret</div>
</div><!-- fragment --><p><a class="anchor" id="builtin_constant_p_in_inline_functions"></a>As <code>__builtin_constant_p</code> is used to infer whether the address of the SFR is known at compile-time, extra care must be taken when the functionality is implemented as an inline function: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __attribute__((__always_inline__))</div>
<div class="line"><span class="keywordtype">void</span> clear_reg (<a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> <span class="keyword">volatile</span> *psfr)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// !!! The following cast is required to make __builtin_constant_p</span></div>
<div class="line">  <span class="comment">// !!! work as expected in the inline function.</span></div>
<div class="line">  <a class="code hl_typedef" href="group__avr__stdint.html#ga2c8c1b9f53772a86b0827ce7399b68aa">uintptr_t</a> addr = (<a class="code hl_typedef" href="group__avr__stdint.html#ga2c8c1b9f53772a86b0827ce7399b68aa">uintptr_t</a>) psfr;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (__builtin_constant_p (addr)</div>
<div class="line">      &amp;&amp; _SFR_IO_REG_P (* psfr))</div>
<div class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">&quot;out %i0, __zero_reg__&quot;</span></div>
<div class="line">                  :: <span class="stringliteral">&quot;I&quot;</span> (addr) : <span class="stringliteral">&quot;memory&quot;</span>);</div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (__builtin_constant_p (addr))</div>
<div class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">&quot;sts %0, __zero_reg__&quot;</span></div>
<div class="line">                  :: <span class="stringliteral">&quot;n&quot;</span> (addr) : <span class="stringliteral">&quot;memory&quot;</span>);</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">&quot;st %a0, __zero_reg__&quot;</span></div>
<div class="line">                  :: <span class="stringliteral">&quot;e&quot;</span> (addr) : <span class="stringliteral">&quot;memory&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> clear_3_pregs (<a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> <span class="keyword">volatile</span> *psfr)</div>
<div class="line">{</div>
<div class="line">  clear_reg (&amp; PORTB);</div>
<div class="line">  clear_reg (&amp; UDR0);</div>
<div class="line">  clear_reg (psfr);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__stdint_html_ga2c8c1b9f53772a86b0827ce7399b68aa"><div class="ttname"><a href="group__avr__stdint.html#ga2c8c1b9f53772a86b0827ce7399b68aa">uintptr_t</a></div><div class="ttdeci">uint16_t uintptr_t</div><div class="ttdef"><b>Definition:</b> stdint.h:160</div></div>
</div><!-- fragment --><p><b>Casting the address <code>psfr</code> to an integer type in the inline function is required</b> so that the compiler will recognize constant addresses.<br  />
 Also notice that we have to pass the <em>address of the SFR</em> to the inline function. Passing the SFR directly like in the marco approach won't work for obvious reasons.</p>
<h2><a class="anchor" id="inline_asm_bytes"></a>
Accessing Bytes of wider Expressions</h2>
<p>Finally, an example that atomically increments a 16-bit integer. The code is wrapped in <code>IN SREG</code> / <code>CLI</code> / <code>OUT SREG</code> to make it atomic. It reads the 16-bit value <code>data</code> from its absolute address, increments it and then writes it back:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> <span class="keyword">volatile</span> data;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> inc_data (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> tmp;</div>
<div class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">&quot;in __tmp_reg__, __SREG__&quot;</span>   <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">                  <span class="stringliteral">&quot;cli&quot;</span>                        <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">                  <span class="stringliteral">&quot;lds %A[temp], %[addr]&quot;</span>      <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">                  <span class="stringliteral">&quot;lds %B[temp], %[addr]+1&quot;</span>    <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line"><span class="preprocessor">#ifdef __AVR_TINY__</span></div>
<div class="line">                  <span class="comment">// Reduced Tiny does not have ADIW.</span></div>
<div class="line">                  <span class="stringliteral">&quot;subi %A[temp], lo8(-1)&quot;</span>     <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">                  <span class="stringliteral">&quot;sbci %B[temp], hi8(-1)&quot;</span>     <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">                  <span class="stringliteral">&quot;adiw %[temp], 1&quot;</span>            <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">                  <span class="stringliteral">&quot;sts %[addr]+1, %B[temp]&quot;</span>    <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">                  <span class="stringliteral">&quot;sts %[addr],   %A[temp]&quot;</span>    <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">                  <span class="stringliteral">&quot;out __SREG__, __tmp_reg__&quot;</span></div>
<div class="line"><span class="preprocessor">#ifdef __AVR_TINY__</span></div>
<div class="line">                  <span class="comment">// No need to restrict tmp to a &quot;w&quot; register. And on</span></div>
<div class="line">                  <span class="comment">// avr-gcc v13.2 and older, &quot;w&quot; contains no regs.</span></div>
<div class="line">                  : [temp] <span class="stringliteral">&quot;=d&quot;</span> (tmp), <span class="stringliteral">&quot;+m&quot;</span> (data)</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">                  : [temp] <span class="stringliteral">&quot;=w&quot;</span> (tmp), <span class="stringliteral">&quot;+m&quot;</span> (data)</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">                  : [addr] <span class="stringliteral">&quot;i&quot;</span> (&amp; data));</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__stdint_html_ga1f1825b69244eb3ad2c7165ddc99c956"><div class="ttname"><a href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a></div><div class="ttdeci">unsigned int uint16_t</div><div class="ttdef"><b>Definition:</b> stdint.h:91</div></div>
</div><!-- fragment --><p>Notice there are three different ways required to access the different bytes of the involved 16-bit entities:</p>
<ul>
<li>For the 16-bit general purpose register <code>%</code>[temp], <a class="el" href="inline_asm.html#print_modifiers">print modifiers</a> <code>%A</code> and <code>%B</code> are used.</li>
<li>For the 16-bit value <code>data</code> in static storage, <code>%[addr]+1</code> is used to access the high byte. The resulting expression <code>data+1</code> is computable at link-time and evaluated by the linker.</li>
<li>In the compilation variant for Reduced Tiny, the bytes of the 16-bit subtrahend <code>&minus;1</code> are accessed with the <a class="el" href="inline_asm.html#operand_modifiers">operand modifiers</a> <code>lo8</code> and <code>hi8</code> that are evaluated by the assembler because <code>&minus;1</code> is known at assembler-time.</li>
</ul>
<p><code>data</code> is located in static storage, hence its address is known to the linker and fits <a class="el" href="inline_asm.html#constraints">constraint</a> <code>"i"</code>.</p>
<p>The sole purpose of operand <code>"+m" (data)</code> is to describe the effect of the asm on data memory: It changes <code>data</code>. Notice that there is no <code>"memory"</code> clobber, because that operand already describes all memory side effects, and it does this in a less intrusive way than a catch-all <code>"memory"</code>. The operand is not used in the asm template; but in principle it would be possible to use it as operand with <code>LDS</code> and <code>STS</code> instead of operand <code>[addr] "i" (&amp; data)</code>. However, there are many situations where a memory operand constrained by <code>"m"</code> takes a form that cannot be used with AVR instructions because there are no matching print modifiers, or because it is not known a priori what specific form the memory operand takes. In such cases, one would take the address of the operand and supply it as address in a pointer register to the inline asm. The compiler generates the required instructions for address computation, and the inline asm knows that it can use <code>LD</code> and <code>ST</code>.</p>
<h2><a class="anchor" id="inline_asm_jumping"></a>
Jumping and Branching</h2>
<p>When an inline asm contains jumps, then it also requires labels. When the label is inside the asm, then care must be taken that the label is unique in the compilation unit even when the inline asm is used multiple times, e.g. when the code is located in an unrolled loop or a function has multiple incarnations due to cloning, or simply because a macro or inline function that contains an asm statement is used more than once. <br  />
 There are two kinds of labels that can be used:</p>
<ul>
<li>Local labels of the form <code><em>n</em>:</code> where <em>n</em> is some (small, non-negative) number. They can be targeted by means of <code><em>n</em>b</code> or <code><em>n</em>f</code>, depending on whether the jump direction is <b>b</b>ackwards or <b>f</b>orwards. Such a numeric labels may be present more than once. The taken label is the first one with the specified number in the respective direction: <div class="fragment"><div class="line"><span class="comment">// Loop until bit PORTB.7 is set.</span></div>
<div class="line"><span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">&quot;1: sbrs %i[sfr], %[bitno]&quot;</span>  <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">              <span class="stringliteral">&quot;rjmp 1b&quot;</span></div>
<div class="line">              :: [sfr] <span class="stringliteral">&quot;I&quot;</span> (&amp; PORTB), [bitno] <span class="stringliteral">&quot;n&quot;</span> (PB7));</div>
</div><!-- fragment --></li>
<li>Local labels that contain the <a class="el" href="inline_asm.html#special_sequences">sequence</a> <code>%=</code> which yields some number that's unique amongst all asm incarnations in the respective compilation unit: <div class="fragment"><div class="line"><span class="comment">// Loop until bit PORTB.7 is set.</span></div>
<div class="line"><span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">&quot;.Loop.%=: sbrs %i[sfr], %[bitno]&quot;</span>  <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">              <span class="stringliteral">&quot;rjmp .Loop.%=&quot;</span></div>
<div class="line">              :: [sfr] <span class="stringliteral">&quot;I&quot;</span> (&amp; PORTB), [bitno] <span class="stringliteral">&quot;n&quot;</span> (PB7));</div>
</div><!-- fragment --></li>
</ul>
<p>Which form is used is a matter of taste. In practice, the first variant is often preferred in short sequences, whereas the second form is usually seen in longer algorithms.</p>
<p>For labels that are defined in the surrounding C/C++ code, asm goto has to be used. The <a class="el" href="inline_asm.html#print_modifiers">print modifier</a> <code>%x0</code> prints <code>panic</code> as a raw label, not as <code>gs(panic)</code> like it would be the case with <code>%0</code>. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">asm</span> <span class="keywordflow">goto</span> (<span class="stringliteral">&quot;tst __zero_reg__&quot;</span> <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">              <span class="stringliteral">&quot;brne %x0&quot;</span></div>
<div class="line">              :::: panic);</div>
<div class="line">    <span class="comment">/* ...Application code here... */</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">panic:</div>
<div class="line">    <span class="comment">// __zero_reg__ is supposed to contain 0, but doesn&#39;t.</span></div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This assumes that the jump offset can be encoded in the <code>brne</code> instruction in all situations. When static analysis cannot prove that the jump offset fits, then a jumpity jump has to be used: </p><div class="fragment"><div class="line"><span class="keyword">asm</span> <span class="keywordflow">goto</span> (<span class="stringliteral">&quot;tst   __zero_reg__&quot;</span> <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">          <span class="stringliteral">&quot;breq  1f&quot;</span>           <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">          <span class="stringliteral">&quot;%~jmp %x0&quot;</span>          <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">          <span class="stringliteral">&quot;1: ;; all fine&quot;</span></div>
<div class="line">          :::: panic);</div>
</div><!-- fragment --><p>Sequence <code>"%~jmp"</code> yields <code>"rjmp"</code> or <code>"jmp"</code> depending on the architecture. Notice that a <code>jmp</code> can be relaxed to an <code>rjmp</code> with option <code>-mrelax</code> provided the jump offset fits.</p>
<h1><a class="anchor" id="inline_asm_local_vars"></a>
Binding local Variables to Registers</h1>
<p>One use of GCC's <code>asm</code> keyword is to bind local register variables to hardware registers.<br  />
 <b>Such bindings of local variables to registers are only guaranteed during inline asm which has these variables as operands.</b></p>
<h2><a class="anchor" id="inline_asm_abi_interface"></a>
Interfacing non-ABI Functions</h2>
<p>Suppose we want to interface a non-<a href="https://gcc.gnu.org/wiki/avr-gcc#Calling_Convention">ABI</a> assembly function <code>mul_8_16</code> that multiplies R24 with R27:R26, clobbers R0, R1 and R25, and returns the 24-bit result in R20:R19:R18. One way to implement such an interface would be to provide an assembly function that performs the required copying and call to <code>mul_8_16</code>. Such a function would destroy some of the performance gain obtained by using assembly for <code>mul_8_16:</code> Additional copying back and forth and extra <code>CALL</code> and <code>RET</code> instructions.</p>
<p>The compiler comes to the rescue. We can bind local variables to the required registers: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> mul_8_16 (<span class="keywordtype">void</span>); <span class="comment">// Non-ABI function. Don&#39;t call in C/C++!</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __attribute__((__always_inline__))</div>
<div class="line">__uint24 mul_8_16_gccabi (<a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> val8, <a class="code hl_typedef" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> val16)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">register</span> <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> r24 __asm(<span class="stringliteral">&quot;r24&quot;</span>) = val8;</div>
<div class="line">    <span class="keyword">register</span> __uint24 r18 __asm(<span class="stringliteral">&quot;r18&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">asm</span> (<span class="stringliteral">&quot;%~call %x[func]&quot;</span>  <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">         <span class="stringliteral">&quot;clr    __zero_reg__&quot;</span></div>
<div class="line">         : <span class="stringliteral">&quot;=r&quot;</span> (r18)</div>
<div class="line">         : <span class="stringliteral">&quot;r&quot;</span> (r24), <span class="stringliteral">&quot;x&quot;</span> (val16), [func] <span class="stringliteral">&quot;i&quot;</span> (mul_8_16)</div>
<div class="line">         : <span class="stringliteral">&quot;r25&quot;</span>, <span class="stringliteral">&quot;r0&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> r18;</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>The 8-bit parameter is bound to R24, and the 24-bit return value is bound to R18...R20.</li>
<li>The <code>register</code> keyword is mandatory.</li>
<li>The hard register is specified as a string literal for the lower case register name or register number, like <code>"18"</code> or <code>"r18"</code>. Specifications like <code>"R18"</code>, <code>18</code> or <code>"Z"</code> are not supported.</li>
<li>The 16-bit parameter of <code>mul_8_16</code> happens to be required in R27:R26, which is the X register for which there is <a class="el" href="inline_asm.html#constraints">register constraint</a> <code>"x"</code>. Therefore, no register binding is required for <code>val16</code>.</li>
<li>As <code>mul_8_16</code> clobbers the zero register R1, it has to be restored by means of <div class="fragment"><div class="line">clr __zero_reg__</div>
</div><!-- fragment --></li>
<li>The asm is pure arithmetic and hence not volatile. (It might be advisable to make it volatile anyway, so that it won't be reorderd across <code><a class="el" href="group__avr__interrupts.html#gaad5ebd34cb344c26ac87594f79b06b73">sei()</a></code> or <code><a class="el" href="group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162">cli()</a></code> instructions.)</li>
</ul>
<p>Let's have a look at how this performs in a test case: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> use_mul_8_16_gccabi (<a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> val, <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> a, <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (mul_8_16_gccabi (val, a * b) &gt;= 0x2010)</div>
<div class="line">        __builtin_abort();</div>
<div class="line">}</div>
</div><!-- fragment --><p> For ATmega8 we get the following assembly: </p><div class="fragment"><div class="line">use_mul_8_16_gccabi:</div>
<div class="line">    mul  r22,r20</div>
<div class="line">    movw r26,r0</div>
<div class="line">    clr  __zero_reg__</div>
<div class="line"><span class="comment">/* #APP */</span></div>
<div class="line">    rcall mul_8_16</div>
<div class="line">    clr   __zero_reg__</div>
<div class="line"><span class="comment">/* #NOAPP */</span></div>
<div class="line">    cpi  r18,16</div>
<div class="line">    sbci r19,32</div>
<div class="line">    cpc  r20,__zero_reg__</div>
<div class="line">    brlo .L1</div>
<div class="line">    rcall <a class="code hl_function" href="group__avr__stdlib.html#ga8dec7c95227ff149687066cf04029191">abort</a></div>
<div class="line">.L1:</div>
<div class="line">    ret</div>
<div class="ttc" id="agroup__avr__stdlib_html_ga8dec7c95227ff149687066cf04029191"><div class="ttname"><a href="group__avr__stdlib.html#ga8dec7c95227ff149687066cf04029191">abort</a></div><div class="ttdeci">void abort(void)</div><div class="ttdef"><b>Definition:</b> abort.c:34</div></div>
</div><!-- fragment --><p>No superfluous register moves. Great!</p>
<h1><a class="anchor" id="c_names_in_asm"></a>
Specifying the Assembly Name of Static Objects</h1>
<p>Sometimes, it is desirable to use a different name for an object or function rather than the (mangled) name from the C/C++ implementation. Just add an asm specifier with the desired name as a string literal at the end of the declaration.</p>
<p>For example, this is how <code><a class="el" href="eeprom_8h.html">avr/eeprom.h</a></code> implements the <code><a class="el" href="group__avr__eeprom.html#ga5c995e0556de15665502891c4f08076a">eeprom_read_double()</a></code> function: </p><div class="fragment"><div class="line"><span class="preprocessor">#if __SIZEOF_DOUBLE__ == 4</span></div>
<div class="line"><span class="keywordtype">double</span> <a class="code hl_function" href="group__avr__eeprom.html#ga5c995e0556de15665502891c4f08076a">eeprom_read_double</a> (<span class="keyword">const</span> <span class="keywordtype">double</span>*) __asm(<span class="stringliteral">&quot;eeprom_read_dword&quot;</span>);</div>
<div class="line"><span class="preprocessor">#elif __SIZEOF_DOUBLE__ == 8</span></div>
<div class="line"><span class="keywordtype">double</span> <a class="code hl_function" href="group__avr__eeprom.html#ga5c995e0556de15665502891c4f08076a">eeprom_read_double</a> (<span class="keyword">const</span> <span class="keywordtype">double</span>*) __asm(<span class="stringliteral">&quot;eeprom_read_qword&quot;</span>);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="ttc" id="agroup__avr__eeprom_html_ga5c995e0556de15665502891c4f08076a"><div class="ttname"><a href="group__avr__eeprom.html#ga5c995e0556de15665502891c4f08076a">eeprom_read_double</a></div><div class="ttdeci">double eeprom_read_double(const double *__p)</div></div>
</div><!-- fragment --><ul>
<li>It uses the implementation of <code>eeprom_read_dword</code> for <code>eeprom_read_double</code>, provided <code>double</code> is a 32-bit type.</li>
<li>It uses the implementation of <code>eeprom_read_qword</code> for 64-bit doubles.</li>
</ul>
<h1><a class="anchor" id="inline_asm_fails"></a>
What won't work</h1>
<p>GCC inline asm has some limitations.</p>
<h2><a class="anchor" id="inline_asm_fails_split"></a>
Setting a Register in one asm and using it in a different one</h2>
<p>Sequences like the following are not supposed to work: </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> var;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> set_var (<span class="keywordtype">char</span> c)</div>
<div class="line">{</div>
<div class="line">    __asm (<span class="stringliteral">&quot;inc r24&quot;</span>);</div>
<div class="line">    __asm (<span class="stringliteral">&quot;sts var, r24&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>There is no guarantee whatsoever that the value in R24 will survive from one asm to the next. <b>Such code might work in many situations, but it is still wrong.</b> The compiler may very well put instructions between the asm statements that change R24.</li>
<li>R24 is changed without noticing the compiler. When R24 contains other data, then that data will be trashed.</li>
</ul>
<p>A correct code would be </p><div class="fragment"><div class="line">__asm (<span class="stringliteral">&quot;inc %0&quot;</span>    <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;sts var, %0&quot;</span></div>
<div class="line">       :: <span class="stringliteral">&quot;r&quot;</span> (c) : <span class="stringliteral">&quot;memory&quot;</span>);</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line">__asm (<span class="stringliteral">&quot;inc %1&quot;</span>    <span class="stringliteral">&quot;\n\t&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;sts %0, %1&quot;</span></div>
<div class="line">       : <span class="stringliteral">&quot;=m&quot;</span> (var) : <span class="stringliteral">&quot;r&quot;</span> (c));</div>
</div><!-- fragment --><h2><a class="anchor" id="inline_asm_fails_lreg"></a>
Referring to a Local Register Variable that's not an Operand to the asm</h2>
<p>Code like the following won't work:</p>
<div class="fragment"><div class="line"><span class="keyword">register</span> <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> reg2 __asm(<span class="stringliteral">&quot;r2&quot;</span>);</div>
<div class="line">__asm (<span class="stringliteral">&quot;clr r2&quot;</span>);</div>
</div><!-- fragment --><p>That code assumes that the local register variable <code>reg2</code> is bound to register R2 in the inline asm, but that is not the case. Only when a local register variable is used as an operand it will be loaded to the specified register:</p>
<div class="fragment"><div class="line">__asm (<span class="stringliteral">&quot;clr r2&quot;</span> : <span class="stringliteral">&quot;=r&quot;</span> (reg2));</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line">__asm (<span class="stringliteral">&quot;clr %0&quot;</span> : <span class="stringliteral">&quot;=r&quot;</span> (reg2));</div>
</div><!-- fragment --><h2><a class="anchor" id="inline_asm_fails_regvar"></a>
Letting an Operand cross the Boundaries of the Y Register</h2>
<p>It is not possible to bind a value to a local register variable that crosses the boundaries of the Y register. For example, trying to bind a 32-bit value to R31:R28 by means of </p><div class="fragment"><div class="line"><span class="keyword">register</span> <a class="code hl_typedef" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a> r28 __asm (<span class="stringliteral">&quot;28&quot;</span>);</div>
<div class="ttc" id="agroup__avr__stdint_html_ga33594304e786b158f3fb30289278f5af"><div class="ttname"><a href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a></div><div class="ttdeci">unsigned long int uint32_t</div><div class="ttdef"><b>Definition:</b> stdint.h:101</div></div>
</div><!-- fragment --><p> will result in an error message like </p><div class="fragment"><div class="line">error: register specified for &#39;r28&#39; isn&#39;t suitable for data type</div>
</div><!-- fragment --><p>Similarly, an operand described by a constraint will be located either completely below the Y register, as part of Y register, or above it.</p>
<h2><a class="anchor" id="asm_fails_output_match"></a>
Using Matching Constraints "=0"..."=9" with Output Operands</h2>
<p>Suppose we want an inline asm that returns the low byte of a 16-bit value <code>val16:</code> </p><div class="fragment"><div class="line"><span class="keyword">asm</span> (<span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;=1&quot;</span> (lo8) : <span class="stringliteral">&quot;r&quot;</span> (val16));</div>
</div><!-- fragment --><p> The diagnostic will be: </p><div class="fragment"><div class="line">error: matching constraint not valid in output operand</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 27 2025 18:32:01 for AVR-LibC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.6
</small></address>
</body>
</html>
