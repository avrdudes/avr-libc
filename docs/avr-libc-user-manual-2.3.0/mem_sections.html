<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<title>AVR-LibC: Memory Sections</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AVR-LibC
   &#160;<span id="projectnumber">2.3.0git</span>
   </div>
   <div id="projectbrief">Standard C library for AVR-GCC</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table>
  <tr>
    <td align="left"><a href="https://avrdudes.github.io/avr-libc/"><h2>AVR-LibC Documen&shy;tation</h2></a></td>
    <td align="center" colspan=4>
      <div class="logo"><img src="avr-libc-logo.png" alt="Logo" align="middle" border="0"></div>
      <div class="invlogo"><img src="avr-libc-logo-inverted.png" alt="Logo" align="middle" border="0"></div>
    </td>
    <td align="right" colspan=2><a href="https://github.com/avrdudes/avr-libc/"><h2>AVR-LibC Development Pages</h2></a></td>
  </tr>
  <tr>
    <td align="center" width="15%"><a href="index.html"><h2>Main Page</h2></a></td>
    <td align="center" width="15%"><a href="pages.html"><h2>User Manual</h2></a></td>
    <td align="center" width="15%"><a href="modules.html"><h2>Library Refe&shy;rence</h2></a></td>
    <td align="center" width="8%"><a href="FAQ.html"><h2>FAQ</h2></a></td>
    <td align="center" width="15%"><a href="group__demos.html"><h2>Example Projects</h2></a></td>
    <td align="center" width="8%"><a href="files.html"><h2>File List</h2></a></td>
    <td align="center" width="8%"><a href="Global_01Index.html"><h2>Index</h2></a></td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Memory Sections </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section are used to organize code and data of a program on the binary level.</p>
<p>The (compiler-generated) assembly code assigns code, data and other entities like debug information to so called input sections. These sections serve as input to the linker, which bundles similar sections together to output sections like <code>.text</code> and <code>.data</code> according to rules defined in the linker description file.</p>
<p>The final ELF binary is then used by programming tools like <code>avrdude</code>, simulators, debuggers and other programs, for example programs from the GNU Binutils family like <code>avr-size</code>, <code>avr-objdump</code> and <code>avr-readelf</code>.</p>
<p>Sections may have extra properties like <a class="el" href="mem_sections.html#sec_align">section alignment</a>, <a class="el" href="mem_sections.html#sec_flags">section flags</a>, <a class="el" href="mem_sections.html#sec_type">section type</a> and rules to locate them or to assign them to <a class="el" href="mem_sections.html#sec_memory_regions">memory regions</a>.</p>
<ul>
<li><a class="el" href="mem_sections.html#sec_concepts">Concepts</a><ul>
<li><a class="el" href="mem_sections.html#sec_named">Named Sections</a><ul>
<li><a class="el" href="mem_sections.html#sec_flags">Section Flags</a></li>
<li><a class="el" href="mem_sections.html#sec_type">Section Type</a></li>
<li><a class="el" href="mem_sections.html#sec_align">Section Alignment</a></li>
<li><a class="el" href="mem_sections.html#sec_subsection">Subsections</a></li>
</ul>
</li>
<li><a class="el" href="mem_sections.html#sec_orphan">Orphan Sections</a></li>
<li><a class="el" href="mem_sections.html#sec_lma">LMA: Load Memory Address</a></li>
<li><a class="el" href="mem_sections.html#sec_vma">VMA: Virtual Memory Address</a></li>
</ul>
</li>
<li><a class="el" href="mem_sections.html#sec_ld_script_blocks">The Linker Script: Building Blocks</a><ul>
<li><a class="el" href="mem_sections.html#sec_input_output">Input Sections and Output Sections</a></li>
<li><a class="el" href="mem_sections.html#sec_memory_regions">Memory Regions</a></li>
</ul>
</li>
<li><a class="el" href="mem_sections.html#sec_ld_script">Output Sections of the Default Linker Script</a><ul>
<li><a class="el" href="mem_sections.html#sec_dot_text">.text</a><ul>
<li><a class="el" href="mem_sections.html#sec_dot_init">.initN: startup code</a></li>
</ul>
</li>
<li><a class="el" href="mem_sections.html#sec_dot_data">.data</a></li>
<li><a class="el" href="mem_sections.html#sec_dot_bss">.bss</a></li>
<li><a class="el" href="mem_sections.html#sec_dot_noinit">.noinit</a></li>
<li><a class="el" href="mem_sections.html#sec_dot_rodata">.rodata</a></li>
<li><a class="el" href="mem_sections.html#sec_dot_eeprom">.eeprom</a></li>
<li><a class="el" href="mem_sections.html#sec_dot_fuse">.fuse, .lock and .signature</a></li>
<li><a class="el" href="mem_sections.html#sec_dot_note">.note.gnu.avr.deviceinfo</a></li>
</ul>
</li>
<li><a class="el" href="mem_sections.html#sec_symbols">Symbols in the Default Linker Script</a></li>
<li><a class="el" href="mem_sections.html#sec_size">Output Sections and Code Size</a></li>
<li><a class="el" href="mem_sections.html#sec_using">Using Sections</a><ul>
<li><a class="el" href="mem_sections.html#c_sections">In C/C++ Code</a></li>
<li><a class="el" href="mem_sections.html#asm_sections">In Assembly Code</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="sec_concepts"></a>
Concepts</h1>
<h2><a class="anchor" id="sec_named"></a>
Named Sections</h2>
<p><em>Named sections</em> are sections that can be referred to by their name. The name and other properties can be provided with the <code>.section</code> directive like in </p><div class="fragment"><div class="line">.section name, <span class="stringliteral">&quot;flags&quot;</span>, @type</div>
</div><!-- fragment --><p> or with the <code>.pushsection</code> directive, which directs the assembler to assemble the following code into the named section.</p>
<p>An example of a section that is not referred to by its name is the COMMON section. In order to put an object in that section, special directives like <code>.comm name,size</code> or <code>.lcomm name,size</code> have to be used.</p>
<p>Directives like <code>.text</code> are basically the same like <code>.section .text</code>, where the assembler assumes appropriate section flags and type; same for directives <code>.data</code> and <code>.bss</code>.</p>
<h3><a class="anchor" id="sec_flags"></a>
Section Flags</h3>
<p>The <em>section flags</em> can be specified with the <code>.section</code> and <code>.pushsection</code> directives, see <a class="el" href="mem_sections.html#sec_type">section type</a> for an example. Section flags of output sections can be specified in the linker description file, and the linker implements heuristics to determine the section flags of output sections from the various input section that go into it.</p>
<table class="doxtable">
<caption>Section Flags</caption>
<tr>
<th>Flag </th><th>Meaning  </th></tr>
<tr>
<td><code>a</code> </td><td>The section will be <b>a</b>llocated, i.e. it occupies space on the target hardware  </td></tr>
<tr>
<td><code>w</code> </td><td>The section contains data that can be <b>w</b>ritten at run-time. Sections that only contain read-only entities don't have the <code>w</code> flag set  </td></tr>
<tr>
<td><code>x</code> </td><td>The section contains e<b>x</b>ecutable code, though the section may also contain non-executable objects  </td></tr>
<tr>
<td><code>M</code> </td><td>A <b>m</b>ergeable section  </td></tr>
<tr>
<td><code>S</code> </td><td>A <b>s</b>tring section  </td></tr>
<tr>
<td><code>G</code> </td><td>A section <b>g</b>roup, like used with <code>comdat</code> objects  </td></tr>
</table>
<p>The last three flags are listed for completeness. They are used by the compiler, for example for header-only C++ modules and to ensure that multiple instantiations of the same template in different compilation units does occur at most once in the executable file.</p>
<h3><a class="anchor" id="sec_type"></a>
Section Type</h3>
<p>The <em>section type</em> can be specified with the <code>.section</code> and <code>.pushsection</code> directives, like in </p><div class="fragment"><div class="line">.section .text.myfunc,<span class="stringliteral">&quot;ax&quot;</span>,@progbits</div>
<div class="line">.pushsection <span class="stringliteral">&quot;.data.myvar&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;progbits&quot;</span></div>
</div><!-- fragment --><p> On ELF level, the section type is stored in the section header like <code>Elf32_Shdr.sh_type = SHT_PROGBITS</code>.</p>
<table class="doxtable">
<caption>Section Types</caption>
<tr>
<th>Type </th><th>Meaning  </th></tr>
<tr>
<td><code>@progbits</code> </td><td>The section contains data that will be loaded to the target, like objects in the <code>.text</code> and <code>.data</code> sections.  </td></tr>
<tr>
<td><code>@nobits</code> </td><td>The section does not contain data that needs to be transferred to the target device, like data in the <code>.bss</code> and <code>.noinit</code> sections. The section still occupies space on the target.  </td></tr>
<tr>
<td><code>@note</code> </td><td>The section is a note, like for example the <a class="el" href="mem_sections.html#sec_dot_note">.note.gnu.avr.deviceinfo</a> section.  </td></tr>
</table>
<h3><a class="anchor" id="sec_align"></a>
Section Alignment</h3>
<p>The <em>alignment</em> of a section is the maximum over the alignments of the objects in the section.</p>
<h3><a class="anchor" id="sec_subsection"></a>
Subsections</h3>
<p><em>Subsections</em> are compartments of named sections and are introduced with the <code><a class="el" href="assembler.html#dot_subsection">.subsection</a></code> directive. Subsections are located in order of increasing index in their input section. The default subsection after switching to a new section is subsection&#160;0.</p>
<dl class="section note"><dt>Note</dt><dd>A common misconception is that a section like <code>.text.module.func</code> were a subsection of <code>.text.module</code>. This is not the case. These two sections are independent, and there is no subset relation. The sections may have different flags and type, and they may be assigned to different output sections.</dd></dl>
<h2><a class="anchor" id="sec_orphan"></a>
Orphan Sections</h2>
<p><em>Orphan sections</em> are sections that are not mentioned in the linker description file. When an input section is orphan, then the GNU linker implicitly generates an output section of the same name. The linker implements various heuristics to determine sections flags, section type and location of orphaned sections. One use of orphan sections is to <a class="el" href="FAQ.html#faq_reloc_code">locate code to a fixed address</a>.</p>
<p>Like for any other output section, the start address can be specified by means of linking with<br  />
 <code>-Wl,--section-start,<em>secname</em>=<em>address</em></code></p>
<h2><a class="anchor" id="sec_lma"></a>
LMA: Load Memory Address</h2>
<p>The LMA of an object is the address where a loader like <code>avrdude</code> puts the object when the binary is being uploaded to the target device.</p>
<h2><a class="anchor" id="sec_vma"></a>
VMA: Virtual Memory Address</h2>
<p>The VMA is the address of an object as used by the running program.</p>
<p>VMA and LMA may be different: Suppose a small ATmega8 program with executable code that extends from byte address 0x0 to 0x20f, and one variable <code>my_var</code> in static storage. The default linker script puts the content of the <code>.data</code> output section after the <code>.text</code> output section and into the <code>text</code> <a class="el" href="mem_sections.html#sec_memory_regions">segment</a>. The startup code then copies <code>my_data</code> from its LMA location beginning at 0x210 to its VMA location beginning at 0x800060, because C/C++ requires that all data in static storage must have been initialized when <code>main</code> is entered.</p>
<p>The internal SRAM of ATmega8 starts at RAM address 0x60, which is offset by 0x800000 in order to linearize the address space (VMA 0x60 is a flash address). The AVR program only ever uses the lower 16 bits of VMAs in static storage so that the offset of 0x800000 is masked out. But code like <code>"LDI r24,hh8(my_data)"</code> actually sets R24 to 0x80 and reveals that <code>my_data</code> is an object located in RAM.</p>
<h1><a class="anchor" id="sec_ld_script_blocks"></a>
The Linker Script: Building Blocks</h1>
<p>The linker description file is the central hub to channel functions and static storage objects of a program to the various memory spaces and address ranges of a device.</p>
<p><a class="anchor" id="sec_input"></a><a class="anchor" id="sec_output"></a> </p>
<h2><a class="anchor" id="sec_input_output"></a>
Input Sections and Output Sections</h2>
<p><em>Input sections</em> are sections that are inputs to the linker. Functions and static variables but also additional notes and debug information are assigned to different input sections by means of <a class="el" href="assembler.html#ass_directives">assembler directives</a> like <code>.section</code> or <code>.text</code>. The linker takes all these sections and assigns them to output sections as specified in the linker script.</p>
<p><em>Output sections</em> are defined in the linker description file. Contrary to the unlimited number of input sections a program can come up with, there is only a handful of output sections like <code>.text</code> and <code>.data</code>, that roughly correspond to the memory spaces of the target device.</p>
<p>One step in the final link is to <em>locate</em> the sections, that is the linker/locator determines at which memory location to put the output sections, and how to arrange the many input sections within their assigned output section. <em>Locating</em> means that the linker assigns <a class="el" href="mem_sections.html#sec_lma">Load Memory Addresses</a> &mdash; addresses as used by a loader like <code>avrdude</code> &mdash; and <a class="el" href="mem_sections.html#sec_vma">Virtual Memory Addresses</a>, which are the addresses as used by the running program.</p>
<p>While it is possible to directly assign LMAs and VMAs to output sections in the linker script, the default linker scripts provided by Binutils assign <em>memory regions</em> (aka. <em>memory segments</em>) to the output sections. This has some advantages like a linker script that is easier to maintain. An output sections can be assigned to more than one memory region. For example, non-zero data in static storage (<code>.data</code>) goes to</p><ol type="1">
<li>the <code>data</code> region (VMA), because such variables occupy RAM which has to be allocated</li>
<li>the <code>text</code> region (LMA), because the initializers for such data has to be kept in some non-volatile memory (program ROM), so that the startup code can initialize that data so that the variables have their expected initial values when <code>main()</code> is entered.</li>
</ol>
<p>The <code>SECTIONS{}</code> portion of a linker script models the input and output section, and it assigns the output section to the memory regions defined in the <code>MEMORY{}</code> part.</p>
<h2><a class="anchor" id="sec_memory_regions"></a>
Memory Regions</h2>
<p>The <em>memory regions</em> defined in the default linker script model and correspond to the different kinds of memories of a device.</p>
<table class="doxtable">
<caption>Memory Regions of the Default Linker Script</caption>
<tr>
<th>Region </th><th>Virtual<br  />
Address<sup>1</sup> </th><th>Flags </th><th>Purpose  </th></tr>
<tr>
<td><code>text</code> </td><td><code>0</code><sup>2</sup> </td><td><code>rx</code> </td><td><a class="el" href="mem_sections.html#sec_text_text">Executable code</a>, <a class="el" href="mem_sections.html#sec_dot_vectors">vector table</a>, data in <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>, <a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a>, <a class="el" href="group__avr__flash.html#ga23fa8e089930723df0ce4bbdbf8d02bc">__flashx</a> and __memx, <a class="el" href="mem_sections.html#sec_dot_init">startup code</a>, <a class="el" href="mem_sections.html#sec_dot_trampolines">linker stubs</a>, initializers for <code>.data</code>  </td></tr>
<tr>
<td><code>data</code> </td><td><code>0x800000</code><sup>2</sup> </td><td><code>rw</code> </td><td>Data in static storage  </td></tr>
<tr>
<td><code>rodata</code><sup>3</sup> </td><td><code>0xa00000</code><sup>2</sup> </td><td><code>r</code> </td><td>Read-only data in static storage  </td></tr>
<tr>
<td><code>eeprom</code> </td><td><code>0x810000</code> </td><td><code>rw</code> </td><td>EEPROM data  </td></tr>
<tr>
<td><code>fuse</code> </td><td><code>0x820000</code> </td><td><code>rw</code> </td><td>Fuse bytes  </td></tr>
<tr>
<td><code>lock</code> </td><td><code>0x830000</code> </td><td><code>rw</code> </td><td>Lock bytes  </td></tr>
<tr>
<td><code>signature</code> </td><td><code>0x840000</code> </td><td><code>rw</code> </td><td>Device signature  </td></tr>
<tr>
<td><code>user_signatures</code> </td><td><code>0x850000</code> </td><td><code>rw</code> </td><td>User signature  </td></tr>
</table>
<p><a class="anchor" id="harvard_arch"></a>Notes</p>
<ol type="1">
<li>The <a class="el" href="mem_sections.html#sec_vma">VMA</a>s for regions other than <code>text</code> are offset in order to linearize the non-linear memory address space of the AVR Harvard architecture. The target code only ever uses the lower 16 bits of the VMA to access objects in non-<code>text</code> regions.</li>
<li>The addresses for regions <code>text</code>, <code>data</code> <code>and</code> rodata are actually defined as symbols like <code>__TEXT_REGION_ORIGIN__</code>, so that they can be adjusted by means of, say <code>-Wl,--defsym,__DATA_REGION_ORIGIN__=0x800060</code>. Same applies for the lengths of all the regions, which is <code>__<em>NAME</em>_REGION_LENGTH__</code> for region <em>name</em>.</li>
<li>The <code>rodata</code> region is only present in the <code>avrxmega2_flmap</code> and <code>avrxmega4_flmap</code> emulations, which is the case for Binutils since v2.42 for the AVR64 and AVR128 devices without <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#index-mrodata-in-ram"><code>-mrodata-in-ram</code></a>.</li>
</ol>
<h1><a class="anchor" id="sec_ld_script"></a>
Output Sections of the Default Linker Script</h1>
<p>This section describes the various <a class="el" href="mem_sections.html#sec_output">output sections</a> defined in the default linker description files.</p>
<table class="doxtable">
<caption>Output Sections and Memory Regions</caption>
<tr>
<th>Output </th><th>Purpose </th><th colspan="2">Memory Region  </th></tr>
<tr>
<th>Section </th><th></th><th>LMA </th><th>VMA  </th></tr>
<tr>
<td><code><a class="el" href="mem_sections.html#sec_dot_text">.text</a></code> </td><td>Executable code, data in progmem </td><td>text </td><td>text  </td></tr>
<tr>
<td><code><a class="el" href="mem_sections.html#sec_dot_data">.data</a></code> </td><td>Non-zero data in static storage </td><td>text </td><td>data  </td></tr>
<tr>
<td><code><a class="el" href="mem_sections.html#sec_dot_bss">.bss</a></code> </td><td>Zero data in static storage </td><td>&mdash; </td><td>data  </td></tr>
<tr>
<td><code><a class="el" href="mem_sections.html#sec_dot_noinit">.noinit</a></code> </td><td>Non-initialized data in static storage </td><td>&mdash; </td><td>data  </td></tr>
<tr>
<td><code><a class="el" href="mem_sections.html#sec_dot_rodata">.rodata</a></code><sup>1</sup> </td><td>Read-only data in static storage </td><td>text </td><td>LMA + offset<sup>3</sup>  </td></tr>
<tr>
<td><code><a class="el" href="mem_sections.html#sec_dot_rodata">.rodata</a></code><sup>2</sup> </td><td>Read-only data in static storage </td><td>0x8000 * <code>__flmap</code><sup>4</sup> </td><td>rodata  </td></tr>
<tr>
<td><code><a class="el" href="mem_sections.html#sec_dot_eeprom">.eeprom</a></code> </td><td>Data in EEPROM </td><td rowspan="5">Note<sup>5</sup> </td><td>eeprom  </td></tr>
<tr>
<td><code><a class="el" href="mem_sections.html#sec_dot_fuse">.fuse</a></code> </td><td>Fuse bytes </td><td>fuse  </td></tr>
<tr>
<td><code><a class="el" href="mem_sections.html#sec_dot_fuse">.lock</a></code> </td><td>Lock bytes </td><td>lock  </td></tr>
<tr>
<td><code><a class="el" href="mem_sections.html#sec_dot_fuse">.signature</a></code> </td><td>Signature bytes </td><td>signature  </td></tr>
<tr>
<td></td><td>User signature bytes </td><td>user_signatures  </td></tr>
</table>
<p>Notes</p>
<ol type="1">
<li>On <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrxmega3">avrxmega3</a> and <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrtiny">avrtiny</a> devices.</li>
<li>On <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrxmega2">AVR64</a> and <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrxmega4">AVR128</a> devices without <code>-mrodata-in-ram</code>.</li>
<li>With an offset <code>__RODATA_PM_OFFSET__</code> of 0x4000 or 0x8000 depending on the device.</li>
<li>The value of symbol <code>__flmap</code> defaults to the last 32 KiB block of program memory, see the GCC <a href="https://gcc.gnu.org/gcc-14/changes.html#avr">v14 release notes</a>.</li>
<li>The <a class="el" href="mem_sections.html#sec_lma">LMA</a> actually equals the <a class="el" href="mem_sections.html#sec_vma">VMA</a>, but is unused. The flash loader like avrdude knows where to put the data,</li>
</ol>
<h2><a class="anchor" id="sec_dot_text"></a>
The .text Output Section</h2>
<p>The <code>.text</code> output section contains the actual machine instructions which make up the program, but also additional code like jump tables and lookup tables placed in program memory with the <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> attribute.</p>
<p>The <code>.text</code> output section contains the input sections described below. Input sections that are not used by the tools are omitted. A <b><code>*</code></b> wildcard stands for any sequence of characters, including empty ones, that are valid in a section name.</p>
<dl>
<dt><a class="anchor" id="sec_dot_vectors"></a><code>.vectors</code> </dt>
<dd><p class="startdd">The <code>.vectors</code> sections contains the interrupt vector table which consists of jumps to <a class="el" href="assembler.html#dot_weak">weak</a>ly defined labels: To <code>__init</code> for the first entry at index&#160;0, and to <code>__vector_<em>N</em></code> for the entry at index <code><em>N</em></code>&#160;&ge;&#160;1. The default value for <code>__vector_<em>N</em></code> is <code>__bad_interrupt</code>, which jumps to weakly defined <code>__vector_default</code>, which jumps to <code>__vectors</code>, which is the start of the <code>.vectors</code> section.</p>
<p class="enddd">Implementing an interrupt service routine (ISR) is performed with the help of the <code><a class="el" href="group__avr__interrupts.html#gad28590624d422cdf30d626e0a506255f">ISR</a></code> macro in C/C++ code.  </p>
</dd>
<dt><a class="anchor" id="sec_dot_progmem"></a><code>.progmem.data</code> </dt>
<dd></dd>
<dt><code>.progmem.data.*</code> </dt>
<dd></dd>
<dt><code>.progmem.gcc.*</code> </dt>
<dd><p class="startdd">This section is used for read-only data declared with attribute <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>, and for data in address-space <a class="el" href="group__avr__flash.html#ga9640f3080a04903165ca21f35da81a38">__flash</a>.</p>
<p class="enddd">The compiler assumes that the <code>.progmem.data</code> sections are located in the lower 64 KiB of program memory. When it does not fit in the lower 64 KiB block, then the program reads garbage except address-space <a class="el" href="group__avr__flash.html#ga23fa8e089930723df0ce4bbdbf8d02bc">__flashx</a> or <a class="el" href="group__avr__pgmspace.html">pgm_read_*_far</a> is used. In that case however, data can be located in the <a class="el" href="mem_sections.html#sec_dot_progmemx">.progmemx.data</a> section which does not require to be located in the lower program memory.  </p>
</dd>
<dt><a class="anchor" id="sec_dot_trampolines"></a>.trampolines </dt>
<dd>Linker stubs for indirect jumps and calls on devices with more than 128 KiB of program memory. This section must be located in the same 128 KiB block like the interrupt vector table. For some background on linker stubs, see the GCC documentation on <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#eind">EIND</a>.  </dd>
<dt><a class="anchor" id="sec_text_text"></a><code>.text</code> </dt>
<dd></dd>
<dt><code>.text.*</code> </dt>
<dd>Executable code. This is where almost all of the executable code of an application will go.  </dd>
<dt><a class="anchor" id="sec_dot_ctors"></a><code>.ctors</code> </dt>
<dd></dd>
<dt><a class="anchor" id="sec_dot_dtors"></a><code>.dtors</code> </dt>
<dd>Tables with addresses of static constructors and destructors, like C++ static constructors and functions declared with attribute <code>constructor</code>.  </dd>
<dt><a class="anchor" id="sec_dot_init"></a>The <code>.init<em>N</em></code> Sections </dt>
<dd><p class="startdd">These sections are used to hold the startup code from reset up through the start of main().</p>
<p class="interdd">The <code>.init<em>N</em></code> sections are executed in order from 0 to 9: The code from one init section falls through to the next higher init section. This is the reason for why code in these sections must be naked (more precisely, it must not contain return instructions), and why code in these sections must never be called explicitly.</p>
<p class="interdd">When several modules put code in the same init section, the order of execution is not specified.</p>
<table class="doxtable">
<caption>The <code>.init<em>N</em></code> Sections</caption>
<tr>
<th>Section </th><th>Performs </th><th>Hosted By </th><th>Symbol<sup>1</sup>  </th></tr>
<tr>
<td><code>.init0</code> </td><td><a class="el" href="assembler.html#dot_weak">Weak</a>ly defines the <code>__init</code> label which is the jump target of the first vector in the interrupt vector table. When the user defines the <code>__init()</code> function, it will be jumped to instead. </td><td>AVR-LibC<sup>2</sup> </td><td rowspan="3"></td></tr>
<tr>
<td><code>.init1</code> </td><td>Unused </td><td>&mdash;  </td></tr>
<tr>
<td><code>.init2</code> </td><td><ul>
<li>Clears <a class="el" href="FAQ.html#zero_reg"><code>__zero_reg__</code> </a></li>
<li>Initializes <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#eind"><code>EIND</code></a> to <code>hh8(pm(__vectors))</code> on devices that have it</li>
<li>Initializes <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#ramp"><code>RAMPX</code>, <code>RAMPY</code>, <code>RAMPZ</code> and <code>RAMPD</code></a> on devices that have all of them </li>
</ul>
</td><td>AVR-LibC  </td></tr>
<tr>
<td><code>.init2</code> </td><td>Initializes the stack pointer to the value of weak symbol <code>__stack</code>, which has a default value of <code>RAMEND</code> as defined in <code><a class="el" href="io_8h.html">avr/io.h</a></code> </td><td>AVR-LibC </td><td><code>__init_sp<sup>3</sup></code>  </td></tr>
<tr>
<td><code>.init3</code> </td><td>Initializes the <code>NVMCTRLB.FLMAP</code> bit-field on devices that have it, except when <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#index-mrodata-in-ram"><code>-mrodata-in-ram</code></a> is specified </td><td>AVR-LibC </td><td><code>__do_flmap_init<sup>v2.2</sup></code>  </td></tr>
<tr>
<td><code>.init3</code> </td><td>Sets the <code>CPUINT_CTRLA.CPUINT_CVT</code> bit provided a compact vector table is in effect (<a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#index-mcvt"><code>-mcvt</code></a>). </td><td>AVR-LibC </td><td><code>__init_cvt<sup>v2.3</sup></code>  </td></tr>
<tr>
<td><code>.init3</code> </td><td>Paints the RAM from __heap_start up to RAMEND in preparation for <a class="el" href="group__util__ram__usage.html#ga9913f782c88128a7e05f61d09c046965">_get_ram_unused()</a>. </td><td>AVR-LibC </td><td><code>__init_ram_color<sup>v2.3</sup></code>  </td></tr>
<tr>
<td><code>.init4</code> </td><td>Initializes data in static storage: Initializes <code><a class="el" href="mem_sections.html#sec_dot_data">.data</a></code> and clears <code><a class="el" href="mem_sections.html#sec_dot_bss">.bss</a></code> </td><td>libgcc </td><td><code>__do_copy_data</code> <br  />
<code>__do_clear_bss</code>  </td></tr>
<tr>
<td><code>.init5</code> </td><td>Unused </td><td>&mdash; </td><td></td></tr>
<tr>
<td><code>.init6</code> </td><td>Run static C++ constructors and functions defined with <code>__attribute__((constructor))</code>. </td><td>libgcc </td><td><code>__do_global_ctors</code>  </td></tr>
<tr>
<td><code>.init7</code> </td><td>Unused </td><td>&mdash; </td><td rowspan="2"></td></tr>
<tr>
<td><code>.init8</code> </td><td>Unused </td><td>&mdash;  </td></tr>
<tr>
<td><code>.init9</code> </td><td>Calls <code>main</code> and then jumps to <code><a class="el" href="group__avr__stdlib.html#ga037e1211798125c945a26bfbfdf26b8f">exit</a></code> </td><td>AVR-LibC </td><td><code>__call_main<sup>3</sup></code>  </td></tr>
</table>
<p class="enddd">Notes</p><ol type="1">
<li>Code in the <code>.init3</code>, <code>.init4</code> and <code>.init6</code> sections is optional; it will only be present when there is something to do. This will be tracked by the compiler &mdash; or has to be tracked by the assembly programmer &mdash; which pulls in the code from the respective library by means of the mentioned symbols, e.g. by linking with <code>-Wl,-u,__do_flmap_init</code> or by means of <div class="fragment"><div class="line">.global __do_copy_data</div>
</div><!-- fragment --> Conversely, when the respective code is not desired for some reason, the symbol can be satisfied by defining it with, say, <code>-Wl,--defsym,__do_copy_data=0</code> so that the code is not pulled in any more.</li>
<li>The code is provided by <a href="https://github.com/avrdudes/avr-libc/blob/main/crt1/gcrt1.S"><code>gcrt1.S</code></a>.</li>
<li>Since AVR-LibC v2.3, the startup code pulls in the respective code from <code>lib<em>mcu</em>.a</code>. Prior to that, the code was located in <code>gcrt1.S</code>.  </li>
</ol>
</dd>
<dt><a class="anchor" id="sec_dot_fini"></a>The <code>.fini<em>N</em></code> Sections </dt>
<dd><p class="startdd">Shutdown code. These sections are used to hold the exit code executed after return from main() or a call to <a class="el" href="group__avr__stdlib.html#ga037e1211798125c945a26bfbfdf26b8f">exit()</a>.</p>
<p class="interdd">The <code>.fini<em>N</em></code> sections are executed in descending order from 9 to 0 in a fallthrough manner.</p>
<table class="doxtable">
<caption>The <code>.fini<em>N</em></code> Sections</caption>
<tr>
<th>Section </th><th>Performs </th><th>Hosted By </th><th>Symbol  </th></tr>
<tr>
<td><code>.fini9</code> </td><td>Defines <code>_exit</code> and weakly defines the <code><a class="el" href="group__avr__stdlib.html#ga037e1211798125c945a26bfbfdf26b8f">exit</a></code> label </td><td>libgcc </td><td rowspan="3"></td></tr>
<tr>
<td><code>.fini8</code> </td><td>Run functions registered with <code><a class="el" href="group__avr__stdlib.html#ga7fd89c82095df80e5e12d6b2834a2acc">atexit()</a></code> </td><td>AVR-LibC  </td></tr>
<tr>
<td><code>.fini7</code> </td><td>Unused </td><td>&mdash;  </td></tr>
<tr>
<td><code>.fini6</code> </td><td>Run static C++ destructors and functions defined with <code>__attribute__((destructor))</code> </td><td>libgcc </td><td><code>__do_global_dtors</code>  </td></tr>
<tr>
<td><code>.fini5...1</code> </td><td>Unused </td><td>&mdash; </td><td rowspan="2"></td></tr>
<tr>
<td><code>.fini0</code> </td><td>Globally disables interrupts and enters an infinite loop to label <code>__stop_program</code> </td><td>libgcc  </td></tr>
</table>
<p>It is unlikely that ordinary code uses the fini sections. When there are no static destructors and <code><a class="el" href="group__avr__stdlib.html#ga7fd89c82095df80e5e12d6b2834a2acc">atexit()</a></code> is not used, then the respective code is not pulled in form the libraries, and the fini code just consumes four bytes: a <code>CLI</code> and a RJMP to itself. Common use cases of fini code is when running the GCC test suite where it reduces fallout, and in simulators to determine (un)orderly termination of a simulated program.  </p>
</dd>
<dt><a class="anchor" id="sec_dot_progmemx"></a><code>.progmemx.*</code> </dt>
<dd>Read-only data in program memory without the requirement that it must reside in the lower 64 KiB. The compiler uses this section for data in the named address-spaces <a class="el" href="group__avr__flash.html#ga23fa8e089930723df0ce4bbdbf8d02bc">__flashx</a> and __memx. Data can be accessed with <a class="el" href="group__avr__pgmspace.html">pgm_read_*_far</a> when it is not in a named address-space: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> __memx <span class="keywordtype">int</span> array1[] = { 1, 4, 9, 16, 25, 36 };</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__avr__pgmspace.html#gae59d3b5091405672ec394d3903ee60c5">PROGMEM_FAR</a></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> array2[] = { 2, 3, 5, 7, 11, 13, 17 };</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> add (<a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> id1, <a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> id2)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> p_array2 = <a class="code hl_define" href="group__avr__pgmspace.html#ga8ddf0e398bde8078aa9395ac77c83f0a">pgm_get_far_address</a> (array2);</div>
<div class="line">    <span class="keywordtype">int</span> val2 = <a class="code hl_function" href="group__avr__pgmspace.html#gab8873f0cfca49b15e1a0588c6f1dfeec">pgm_read_int_far</a> (p_array2 + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * id2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> val2 + array1[id1];</div>
<div class="line">}</div>
<div class="ttc" id="agroup__avr__inttypes_html_ga72b6692e3f3123903c1a0d9a960c59b1"><div class="ttname"><a href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a></div><div class="ttdeci">uint32_t uint_farptr_t</div><div class="ttdef"><b>Definition:</b> inttypes.h:124</div></div>
<div class="ttc" id="agroup__avr__pgmspace_html_ga8ddf0e398bde8078aa9395ac77c83f0a"><div class="ttname"><a href="group__avr__pgmspace.html#ga8ddf0e398bde8078aa9395ac77c83f0a">pgm_get_far_address</a></div><div class="ttdeci">#define pgm_get_far_address(var)</div><div class="ttdef"><b>Definition:</b> pgmspace.h:956</div></div>
<div class="ttc" id="agroup__avr__pgmspace_html_gab8873f0cfca49b15e1a0588c6f1dfeec"><div class="ttname"><a href="group__avr__pgmspace.html#gab8873f0cfca49b15e1a0588c6f1dfeec">pgm_read_int_far</a></div><div class="ttdeci">static int pgm_read_int_far(uint_farptr_t addr)</div></div>
<div class="ttc" id="agroup__avr__pgmspace_html_gae59d3b5091405672ec394d3903ee60c5"><div class="ttname"><a href="group__avr__pgmspace.html#gae59d3b5091405672ec394d3903ee60c5">PROGMEM_FAR</a></div><div class="ttdeci">#define PROGMEM_FAR</div><div class="ttdef"><b>Definition:</b> pgmspace.h:119</div></div>
<div class="ttc" id="agroup__avr__stdint_html_gaba7bc1797add20fe3efdf37ced1182c5"><div class="ttname"><a href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a></div><div class="ttdeci">unsigned char uint8_t</div><div class="ttdef"><b>Definition:</b> stdint.h:81</div></div>
<div class="ttc" id="apgmspace_8h_html"><div class="ttname"><a href="pgmspace_8h.html">pgmspace.h</a></div></div>
</div><!-- fragment --> For data in address-space <a class="el" href="group__avr__flash.html#ga23fa8e089930723df0ce4bbdbf8d02bc">__flashx</a> there are support functions in <a class="el" href="group__avr__flash.html">&lt;avr/flash.h&gt;</a>.  </dd>
<dt><a class="anchor" id="sec_dot_jumptables"></a><code>.jumptables*</code> </dt>
<dd>Used to place jump tables in some cases.  </dd>
</dl>
<h2><a class="anchor" id="sec_dot_data"></a>
The .data Output Section</h2>
<p>This section contains data in static storage which has an initializer that is not all zeroes. This includes the following input sections:</p>
<dl>
<dt><code>.data*</code> </dt>
<dd>Read-write data  </dd>
<dt><code>.rodata*</code> </dt>
<dd>Read-only data. These input sections are only included on devices that host read-only data in RAM.  </dd>
</dl>
<p>It is possible to tell the linker the SRAM address of the beginning of the <code>.data</code> section. This is accomplished by linking with </p><div class="fragment"><div class="line">avr-gcc ... -Tdata addr -Wl,--defsym,__DATA_REGION_START__=addr</div>
</div><!-- fragment --><p>Note that <code>addr</code> must be <a class="el" href="mem_sections.html#harvard_arch">offset</a> by adding 0x800000 to the real SRAM address so that the linker knows that the address is in the SRAM memory segment. Thus, if you want the <code>.data</code> section to start at <code>0x1100</code>, pass <code>0x801100</code> as the address to the linker.</p>
<dl class="section note"><dt>Note</dt><dd>When using <code>malloc()</code> in the application (which could even happen inside library calls), <a class="el" href="malloc.html#malloc_extram">additional adjustments</a> are required.</dd></dl>
<h2><a class="anchor" id="sec_dot_bss"></a>
The .bss Output Section</h2>
<p>Data in static storage that will be zeroed by the startup code. This are data objects without explicit initializer, and data objects with initializers that are all zeroes.</p>
<p>Input sections are <code>.bss*</code> and <code>COMMON</code>. Common symbols are defined with directives <code>.comm</code> or <code>.lcomm</code>.</p>
<h2><a class="anchor" id="sec_dot_noinit"></a>
The .noinit Output Section</h2>
<p>Data objects in static storage that should not be initialized by the startup code. As the C/C++ standard requires that <em>all</em> data in static storage is initialized &mdash; which includes data without explicit initializer, which will be initialized to all zeroes &mdash; such objects have to be put into section <code>.noinit</code> by hand: </p><div class="fragment"><div class="line">__attribute__ ((section (<span class="stringliteral">&quot;.noinit&quot;</span>)))</div>
<div class="line">int foo;</div>
</div><!-- fragment --><p> The only input section in this output section is <code>.noinit</code>. Only data without initializer can be put in this section.</p>
<h2><a class="anchor" id="sec_dot_rodata"></a>
The .rodata Output Section</h2>
<p>This section contains read-only data in static storage from <code>.rodata*</code> input sections. This output section is only present for devices where read-only data remains in program memory, which are the devices where (parts of) the program memory are visible in the RAM address space. This is currently the case for the emulations <code>avrtiny</code>, <code>avrxmega3</code>, <code>avrxmega2_flmap</code> and <code>avrxmega4_flmap</code>.</p>
<h2><a class="anchor" id="sec_dot_eeprom"></a>
The .eeprom Output Section</h2>
<p>This is where EEPROM variables are stored, for example variables declared with the <code><a class="el" href="group__avr__eeprom.html#ga79a42ec6c6c8bbbe6e34ed57a52aac59">EEMEM</a></code> attribute. The only input section (pattern) is <code>.eeprom*</code>.</p>
<h2><a class="anchor" id="sec_dot_fuse"></a>
The .fuse, .lock and .signature Output Sections</h2>
<p>These sections contain fuse bytes, lock bytes and device signature bytes, respectively. The respective input section patterns are <code>.fuse*</code>, <code>.lock*</code> and <code>.signature*</code>.</p>
<h2><a class="anchor" id="sec_dot_note"></a>
The .note.gnu.avr.deviceinfo Section</h2>
<p>This section is actually <em>not mentioned</em> in the default linker script, which means it is an <a class="el" href="mem_sections.html#sec_orphan">orphan section</a> and hence the respective output section is implicit.</p>
<p>The startup code from AVR-LibC puts device information in that section to be picked up by simulators or tools like <code>avr-size</code>, <code>avr-objdump</code>, <code>avr-readelf</code>, etc,</p>
<p>The section is contained in the ELF file but not loaded onto the target. Source of the device specific information are the device header file and compiler builtin macros. The layout conforms to the standard <a href="https://man7.org/linux/man-pages/man5/elf.5.html">ELF note section</a> layout and is laid out as follows.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;elf.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    Elf32_Word n_namesz;     <span class="comment">/* AVR_NOTE_NAME_LEN */</span></div>
<div class="line">    Elf32_Word n_descsz;     <span class="comment">/* size of avr_desc */</span></div>
<div class="line">    Elf32_Word n_type;       <span class="comment">/* 1 - the only AVR note type */</span></div>
<div class="line">} Elf32_Nhdr;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define AVR_NOTE_NAME_LEN 4</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>note_gnu_avr_deviceinfo</div>
<div class="line">{</div>
<div class="line">    Elf32_Nhdr nhdr;</div>
<div class="line">    <span class="keywordtype">char</span> note_name[AVR_NOTE_NAME_LEN]; <span class="comment">/* = &quot;AVR\0&quot; */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct</span></div>
<div class="line">    {</div>
<div class="line">        Elf32_Word flash_start;</div>
<div class="line">        Elf32_Word flash_size;</div>
<div class="line">        Elf32_Word sram_start;</div>
<div class="line">        Elf32_Word sram_size;</div>
<div class="line">        Elf32_Word eeprom_start;</div>
<div class="line">        Elf32_Word eeprom_size;</div>
<div class="line">        Elf32_Word offset_table_size;</div>
<div class="line">        <span class="comment">/* Offset table containing byte offsets into</span></div>
<div class="line"><span class="comment">           string table that immediately follows it.</span></div>
<div class="line"><span class="comment">           index 0: Device name byte offset */</span></div>
<div class="line">        Elf32_Off offset_table[1];</div>
<div class="line">        <span class="comment">/* Standard ELF string table.</span></div>
<div class="line"><span class="comment">           index 0 : NULL</span></div>
<div class="line"><span class="comment">           index 1 : Device name</span></div>
<div class="line"><span class="comment">           index 2 : NULL */</span></div>
<div class="line">        <span class="keywordtype">char</span> strtab[2 + <a class="code hl_function" href="group__avr__string.html#ga219836f542ce53545052bed5353820ca">strlen</a>(__AVR_DEVICE_NAME__)];</div>
<div class="line">    } avr_desc;</div>
<div class="line">};</div>
<div class="ttc" id="agroup__avr__string_html_ga219836f542ce53545052bed5353820ca"><div class="ttname"><a href="group__avr__string.html#ga219836f542ce53545052bed5353820ca">strlen</a></div><div class="ttdeci">size_t strlen(const char *)</div><div class="ttdoc">Calculate the length of a string.</div></div>
</div><!-- fragment --><p>The contents of this section can be displayed with</p>
<ul>
<li><code>avr-objdump -P avr-deviceinfo <em>file</em></code>, which is supported since Binutils v2.43.</li>
<li><code>avr-readelf -n <em>file</em></code>, which displays all notes.</li>
</ul>
<h1><a class="anchor" id="sec_symbols"></a>
Symbols in the Default Linker Script</h1>
<p>Most of the symbols like <code>main</code> are defined in the code of the application, but some symbols are defined in the default linker script.</p>
<p>The following two groups of symbols have architecture specific default values and can be adjusted by defining the respective symbol. One use case is to adjust the <code>.data</code> region when external RAM should be used. Most of the symbols get their default value from the startup code according to the memory layout of the respective device.</p>
<dl>
<dt><code>__<em>name</em>_REGION_ORIGIN__</code> </dt>
<dd><p class="startdd">Describes the physical properties of memory region <code><em>name</em></code>, where <code><em>name</em></code> is one of <code>TEXT</code> or <code>DATA</code>. The address is a VMA and offset as explained above. <br  />
 The linker script only supplies a default for the symbol values when they have not been defined by other means, like for example in the startup code or by <code><a class="el" href="using_tools.html#opt_defsym">--defsym</a></code>. For example, to let the code start at address <code>0x100</code>, one can link with </p><pre class="fragment">avr-gcc ... -Ttext=0x100 -Wl,--defsym,__TEXT_REGION_ORIGIN__=0x100</pre><p class="enddd">Notice that <code>__DATA_REGION_ORIGIN__</code> was only introduced since Binutils <a href="https://sourceware.org/PR29741">v2.40</a>. Prior to that, a core specific default value was used for the beginning of the data region, and thus defining this symbol had no effect.  </p>
</dd>
<dt><code>__<em>name</em>_REGION_LENGTH__</code> </dt>
<dd>Describes the physical properties of memory region <code><em>name</em></code>, where <code><em>name</em></code> is one of: <code>TEXT</code>, <code>DATA</code>, <code>EEPROM</code>, <code>LOCK</code>, <code>FUSE</code>, <code>SIGNATURE</code> or <code>USER_SIGNATURE</code>. <br  />
 Only a default is supplied when the symbol is not yet defined by other means. Most of these symbols are <a class="el" href="assembler.html#dot_weak">weakly</a> defined in the startup code.  </dd>
</dl>
<p>The following symbols are provided by the default linker script. The application can read them to infer properties of the binary.</p>
<dl>
<dt><code>__data_start</code> </dt>
<dd></dd>
<dt><code>__data_end</code> </dt>
<dd>Start and (one past the) end <a class="el" href="mem_sections.html#sec_vma">VMA</a> address of the <code><a class="el" href="mem_sections.html#sec_dot_data">.data</a></code> section in RAM.  </dd>
<dt><code>__data_load_start</code> </dt>
<dd></dd>
<dt><code>__data_load_end</code> </dt>
<dd>Start and (one past the) end <a class="el" href="mem_sections.html#sec_lma">LMA</a> address of the <code><a class="el" href="mem_sections.html#sec_dot_data">.data</a></code> section initializers located in program memory. Used together with the VMA addresses above by the <a class="el" href="mem_sections.html#sec_dot_init">startup code</a> to copy data initializers from program memory to RAM.  </dd>
<dt><code>__bss_start</code> </dt>
<dd></dd>
<dt><code>__bss_end</code> </dt>
<dd>Start and (one past the) end VMA address of the <code><a class="el" href="mem_sections.html#sec_dot_bss">.bss</a></code> section. The startup code clears this part of the RAM.  </dd>
<dt><code>__rodata_start</code> </dt>
<dd></dd>
<dt><code>__rodata_end</code> </dt>
<dd></dd>
<dt><code>__rodata_load_start</code> </dt>
<dd></dd>
<dt><code>__rodata_load_end</code> </dt>
<dd>Start and (one past the) end VMA resp. LMA address of the <code>.rodata</code> output section. These symbols are only defined when <code>.rodata</code> is not output to the <code>text</code> region, which is the case for emulations <code>avrxmega2_flmap</code> and <code>avrxmega4_flmap</code>.  </dd>
<dt><code>__heap_start</code> </dt>
<dd>One past the last object located in static storage. Immediately follows the <code><a class="el" href="mem_sections.html#sec_dot_noinit">.noinit</a></code> section (which immediately follows <code><a class="el" href="mem_sections.html#sec_dot_bss">.bss</a></code>, which immediately follows <code><a class="el" href="mem_sections.html#sec_dot_data">.data</a></code>). Used by <a class="el" href="malloc.html">malloc()</a> and friends.  </dd>
</dl>
<p>Code that computes a checksum over all relevant code and data in program memory has to consider:</p><ul>
<li>The range from the beginning of the <code>.text</code> section (address 0x0 in the default layout) up to <code>__data_load_end</code>.</li>
<li>For emulations that have the <code>rodata</code> <a class="el" href="mem_sections.html#sec_memory_regions">memory region</a> (<code>avrxmega2_flmap</code> and <code>avrxmega4_flmap</code>), the range from <code>__rodata_load_start</code> to <code>__rodata_load_end</code> has also to be taken into account, too.</li>
</ul>
<h1><a class="anchor" id="sec_size"></a>
Output Sections and Code Size</h1>
<p>The <code>avr-size</code> program (part of Binutils), coming from a Unix background, doesn't account for the <code><a class="el" href="mem_sections.html#sec_dot_data">.data</a></code> initialization space added to the <code><a class="el" href="mem_sections.html#sec_dot_text">.text</a></code> section, so in order to know how much flash the final program will consume, one needs to add the values for both, <code>.text</code> and <code>.data</code> (but not <code><a class="el" href="mem_sections.html#sec_dot_bss">.bss</a></code>), while the amount of pre-allocated SRAM is the sum of <code>.data</code> and <code>.bss</code>.</p>
<p>Memory usage and free memory can also be displayed with </p><pre class="fragment">avr-objdump -P mem-usage code.elf
</pre><h1><a class="anchor" id="sec_using"></a>
Using Sections</h1>
<h2><a class="anchor" id="c_sections"></a>
In C/C++ Code</h2>
<p>The following example shows how to read and reset the <code>MCUCR</code> special function register on ATmega328. This SFR holds to reset source like "watchdog reset" or "external reset", and should be read early, prior to the initialization of RAM and execution of static constructors which may take some time. This means the code has to be placed prior to <code><a class="el" href="mem_sections.html#sec_dot_init">.init4</a></code> which initializes static storage, but after <code>.init2</code> which initializes <code><a class="el" href="FAQ.html#zero_reg">__zero_reg__</a></code>. As the code runs prior to the initialization of static storage, variable <code>mcucr</code> must be placed in section <code><a class="el" href="mem_sections.html#sec_dot_noinit">.noinit</a></code> so that it won't be overridden by that part of the startup code:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io_8h.html">avr/io.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">__attribute__((section(<span class="stringliteral">&quot;.noinit&quot;</span>)))</div>
<div class="line"><a class="code hl_typedef" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> mcucr;</div>
<div class="line"> </div>
<div class="line">__attribute__((used, unused, naked, section(&quot;.init3&quot;)))</div>
<div class="line">static <span class="keywordtype">void</span> read_MCUCR (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    mcucr = MCUCR;</div>
<div class="line">    MCUCR = 0;</div>
<div class="line">}</div>
<div class="ttc" id="aio_8h_html"><div class="ttname"><a href="io_8h.html">io.h</a></div></div>
</div><!-- fragment --><ul>
<li>The <code>used</code> attribute tells the compiler that the function is used although it is never called.</li>
<li>The <code>unused</code> attribute tells the compiler that it is fine that the function is unused, and silences respective diagnostics about the seemingly unused functions.</li>
<li>The <code>naked</code> attribute is required because the code is located in an init section. The function <em>must not have a <code>RET</code> statement</em> because the function is never called. According to the GCC documentation, the only code supported in naked functions is inline assembly, but the code above is simple enough so that GCC can deal with it.</li>
</ul>
<h2><a class="anchor" id="asm_sections"></a>
In Assembly Code</h2>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io_8h.html">avr/io.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">.section .init3,<span class="stringliteral">&quot;ax&quot;</span>,@progbits</div>
<div class="line">    lds     r0, MCUCR</div>
<div class="line"> </div>
<div class="line">.pushsection .noinit,<span class="stringliteral">&quot;a&quot;</span>,@nobits</div>
<div class="line">mcucr:</div>
<div class="line">    .type   mcucr, @<span class="keywordtype">object</span></div>
<div class="line">    .size   mcucr, 1</div>
<div class="line">    .space  1</div>
<div class="line">.popsection                     ; Proceed with .init3</div>
<div class="line"> </div>
<div class="line">    sts     mcucr, r0</div>
<div class="line">    sts     MCUCR, __zero_reg__ ; Initialized in .init2</div>
<div class="line"> </div>
<div class="line">.text</div>
<div class="line">    .global main</div>
<div class="line">    .type   main, @function</div>
<div class="line">    lds     r24,    mcucr</div>
<div class="line">    clr     r25</div>
<div class="line">    rjmp    <a class="code hl_define" href="group__avr__stdio.html#ga61e2590ae5f2f2e351365640d2ac755a">putchar</a></div>
<div class="line">    .size main, .-main</div>
<div class="ttc" id="agroup__avr__stdio_html_ga61e2590ae5f2f2e351365640d2ac755a"><div class="ttname"><a href="group__avr__stdio.html#ga61e2590ae5f2f2e351365640d2ac755a">putchar</a></div><div class="ttdeci">#define putchar(__c)</div><div class="ttdef"><b>Definition:</b> stdio.h:656</div></div>
</div><!-- fragment --><ul>
<li>The <code>"ax"</code> <a class="el" href="mem_sections.html#sec_flags">flags</a> tells that the sections is <b>a</b>llocatable (consumes space on the target hardware) and is e<b>x</b>ecutable.</li>
<li>The <code>@progbits</code> <a class="el" href="mem_sections.html#sec_type">type</a> tells that the section contains bits that have to be uploaded to the target hardware.</li>
</ul>
<p>For more details, see the gas user manual on the <a href="https://sourceware.org/binutils/docs/as/Section.html#ELF-Version"><code>.section</code></a> directive. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 24 2025 16:09:12 for AVR-LibC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.6
</small></address>
</body>
</html>
