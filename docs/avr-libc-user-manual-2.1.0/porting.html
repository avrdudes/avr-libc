<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>avr-libc: Porting From IAR to AVR GCC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">avr-libc
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
   <div id="projectbrief">Standard C library for AVR-GCC</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table>
  <tr>
    <td align="left"><a href="http://www.nongnu.org/avr-libc/"><h2>AVR Libc Home Page</h2></a></td>
    <td align="center" colspan=4><img src="avrs.png" alt="AVRs" align="middle" border="0"></td>
    <td align="right"><a href="https://savannah.nongnu.org/projects/avr-libc/"><h2>AVR Libc Development Pages</h2></a></td>
  </tr>
  <tr>
    <td align="center" width="20%"><a href="index.html"><h2>Main Page</h2></a></td>
    <td align="center" width="20%"><a href="pages.html"><h2>User Manual</h2></a></td>
    <td align="center" width="20%"><a href="modules.html"><h2>Library Reference</h2></a></td>
    <td align="center" width="20%"><a href="FAQ.html"><h2>FAQ</h2></a></td>
    <td align="center" width="20%"><a href="group__demos.html"><h2>Example Projects</h2></a></td>
  </tr>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Porting From IAR to AVR GCC </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="iar_porting_intro"></a>
Introduction</h1>
<p>C language was designed to be a portable language. There two main types of porting activities: porting an application to a different platform (OS and/or processor), and porting to a different compiler. Porting to a different compiler can be exacerbated when the application is an embedded system. For example, the C language Standard, strangely, does not specify a standard for declaring and defining Interrupt Service Routines (ISRs). Different compilers have different ways of defining registers, some of which use non-standard language constructs.</p>
<p>This chapter describes some methods and pointers on porting an AVR application built with the IAR compiler to the GNU toolchain (AVR GCC). Note that this may not be an exhaustive list.</p>
<h1><a class="anchor" id="iar_porting_register"></a>
Registers</h1>
<p>IO header files contain identifiers for all the register names and bit names for a particular processor. IAR has individual header files for each processor and they must be included when registers are being used in the code. For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iom169.h&gt;</span> </div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>IAR does not always use the same register names or bit names that are used in the AVR datasheet.</dd></dl>
<p>AVR GCC also has individual IO header files for each processor. However, the actual processor type is specified as a command line flag to the compiler. (Using the <code>-mmcu=<em>processor</em></code> flag.) This is usually done in the Makefile. This allows you to specify only a single header file for any processor type:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io_8h.html">avr/io.h</a>&gt;</span> </div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The forward slash in the &lt;<a class="el" href="io_8h.html">avr/io.h</a>&gt; file name that is used to separate subdirectories can be used on Windows distributions of the toolchain and is the recommended method of including this file.</dd></dl>
<p>The compiler knows the processor type and through the single header file above, it can pull in and include the correct individual IO header file. This has the advantage that you only have to specify one generic header file, and you can easily port your application to another processor type without having to change every file to include the new IO header file.</p>
<p>The AVR toolchain tries to adhere to the exact names of the registers and names of the bits found in the AVR datasheet. There may be some descrepencies between the register names found in the IAR IO header files and the AVR GCC IO header files.</p>
<h1><a class="anchor" id="iar_porting_isr"></a>
Interrupt Service Routines (ISRs)</h1>
<p>As mentioned above, the C language Standard, strangely, does not specify a standard way of declaring and defining an ISR. Hence, every compiler seems to have their own special way of doing so.</p>
<p>IAR declares an ISR like so:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma vector=TIMER0_OVF_vect</span></div><div class="line">__interrupt <span class="keywordtype">void</span> MotorPWMBottom()</div><div class="line">{</div><div class="line">    <span class="comment">// code</span></div><div class="line">}</div></div><!-- fragment --><p>In AVR GCC, you declare an ISR like so: </p><div class="fragment"><div class="line"><a class="code" href="group__avr__interrupts.html#gad28590624d422cdf30d626e0a506255f">ISR</a>(PCINT1_vect)</div><div class="line">{ </div><div class="line">    <span class="comment">//code</span></div><div class="line">}</div></div><!-- fragment --><p>AVR GCC uses the <code>ISR</code> macro to define an ISR. This macro requries the header file:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span></div></div><!-- fragment --><p>The names of the various interrupt vectors are found in the individual processor IO header files that you must include with <code>&lt;<a class="el" href="io_8h.html">avr/io.h</a>&gt;</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The names of the interrupt vectors in AVR GCC has been changed to match the names of the vectors in IAR. This significantly helps in porting applications from IAR to AVR GCC.</dd></dl>
<h1><a class="anchor" id="iar_porting_intrinsic"></a>
Intrinsic Routines</h1>
<p>IAR has a number of intrinsic routine such as</p>
<p><code>__enable_interrupts()</code> <code>__disable_interrupts()</code> <code>__watchdog_reset()</code> </p>
<p>These intrinsic functions compile to specific AVR opcodes (SEI, CLI, WDR).</p>
<p>There are equivalent macros that are used in AVR GCC, however they are not located in a single include file.</p>
<p>AVR GCC has <code><a class="el" href="group__avr__interrupts.html#gaad5ebd34cb344c26ac87594f79b06b73">sei()</a></code> for <code>__enable_interrupts()</code>, and <code><a class="el" href="group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162">cli()</a></code> for <code>__disable_interrupts()</code>. Both of these macros are located in <code>&lt;<a class="el" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</code>.</p>
<p>AVR GCC has the macro <code><a class="el" href="group__avr__watchdog.html#ga9e52c54d10b6a6a7ce04aaaa4abea51f">wdt_reset()</a></code> in place of <code>__watchdog_reset()</code>. However, there is a whole Watchdog Timer API available in AVR GCC that can be found in <code>&lt;<a class="el" href="wdt_8h.html">avr/wdt.h</a>&gt;</code>.</p>
<h1><a class="anchor" id="iar_porting_flash"></a>
Flash Variables</h1>
<p>The C language was not designed for Harvard architecture processors with separate memory spaces. This means that there are various non-standard ways to define a variable whose data resides in the Program Memory (Flash).</p>
<p>IAR uses a non-standard keyword to declare a variable in Program Memory:</p>
<div class="fragment"><div class="line">__flash <span class="keywordtype">int</span> mydata[] = .... </div></div><!-- fragment --><p>AVR GCC uses Variable Attributes to achieve the same effect:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> mydata[] <a class="code" href="power_8h.html#a577a0eebac2a6c2d105e61d9c8f04140">__attribute__</a>((progmem)) </div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>See the GCC User Manual for more information about Variable Attributes.</dd></dl>
<p>avr-libc provides a convenience macro for the Variable Attribute:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</span></div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line">int mydata[] <a class="code" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> = ....</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The PROGMEM macro expands to the Variable Attribute of <code>progmem</code>. This macro requires that you include <code>&lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</code>. This is the canonical method for defining a variable in Program Space.</dd></dl>
<p>To read back flash data, use the <code>pgm_read_*</code>() macros defined in <code>&lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</code>. All Program Memory handling macros are defined there.</p>
<p>There is also a way to create a method to define variables in Program Memory that is common between the two compilers (IAR and AVR GCC). Create a header file that has these definitions:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if defined(__ICCAVR__) // IAR C Compiler</span></div><div class="line"><span class="preprocessor">#define FLASH_DECLARE(x) __flash x</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#if defined(__GNUC__) // GNU Compiler</span></div><div class="line"><span class="preprocessor">#define FLASH_DECLARE(x) x __attribute__((__progmem__))</span></div><div class="line"><span class="preprocessor">#endif </span></div></div><!-- fragment --><p>This code snippet checks for the IAR compiler or for the GCC compiler and defines a macro <code>FLASH_DECLARE(x)</code> that will declare a variable in Program Memory using the appropriate method based on the compiler that is being used. Then you would used it like so:</p>
<div class="fragment"><div class="line">FLASH_DECLARE(<span class="keywordtype">int</span> mydata[] = ...); </div></div><!-- fragment --><h1><a class="anchor" id="iar_porting_non_returning_main"></a>
Non-Returning main()</h1>
<p>To declare main() to be a non-returning function in IAR, it is done like this: </p><div class="fragment"><div class="line">__C_task <span class="keywordtype">void</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">// code</span></div><div class="line">}</div></div><!-- fragment --><p>To do the equivalent in AVR GCC, do this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>) <a class="code" href="power_8h.html#a577a0eebac2a6c2d105e61d9c8f04140">__attribute__</a>((noreturn));</div><div class="line">    </div><div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">//...</span></div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>See the GCC User Manual for more information on Function Attributes.</dd></dl>
<p>In AVR GCC, a prototype for main() is required so you can declare the function attribute to specify that the main() function is of type "noreturn". Then, define main() as normal. Note that the return type for main() is now <code>void</code>.</p>
<h1><a class="anchor" id="iar_porting_locking"></a>
Locking Registers</h1>
<p>The IAR compiler allows a user to lock general registers from r15 and down by using compiler options and this keyword syntax:</p>
<div class="fragment"><div class="line">__regvar __no_init <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> filteredTimeSinceCommutation @14;</div></div><!-- fragment --><p>This line locks r14 for use only when explicitly referenced in your code thorugh the var name "filteredTimeSinceCommutation". This means that the compiler cannot dispose of it at its own will.</p>
<p>To do this in AVR GCC, do this:</p>
<div class="fragment"><div class="line"><span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> counter <span class="keyword">asm</span>(<span class="stringliteral">&quot;r3&quot;</span>);</div></div><!-- fragment --><p>Typically, it should be possible to use r2 through r15 that way.</p>
<dl class="section note"><dt>Note</dt><dd>Do not reserve r0 or r1 as these are used internally by the compiler for a temporary register and for a zero value.</dd>
<dd>
Locking registers is not recommended in AVR GCC as it removes this register from the control of the compiler, which may make code generation worse. Use at your own risk. </dd></dl>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 29 2022 00:24:04 for avr-libc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
