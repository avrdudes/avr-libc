<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>Compiler optimization</title>
    <link href="dox.css" rel="stylesheet" type="text/css">
  </head>
<body>
<center>
<table width="80%">
  <tr>
    <td align="left"><a href="http://www.nongnu.org/avr-libc/">AVR Libc Home Page</a></td>
    <td align="center" colspan=4><img src="avrs.png" alt="AVRs" align="middle" border="0"></td>
    <td align="right"><a href="https://savannah.nongnu.org/projects/avr-libc/">AVR Libc Development Pages</a></td>
  </tr>
  <tr>
    <td align="center" width="13%"><a href="index.html">Main Page</a></td>
    <td align="center" width="13%"><a href="pages.html">User Manual</a></td>
    <td align="center" width="13%"><a href="modules.html">Library Reference</a></td>
    <td align="center" width="13%"><a href="FAQ.html">FAQ</a></td>
    <td align="center" width="13%"><a href="globals.html">Alphabetical Index</a></td>
    <td align="center" width="13%"><a href="group__demos.html">Example Projects</a></td>
  </tr>
</table>
</center>
<hr width="80%">
<!-- Generated by Doxygen 1.8.7 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Compiler optimization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="optim_code_reorder"></a>
Problems with reordering code</h1>
<dl class="section author"><dt>Author</dt><dd>Jan Waclawek</dd></dl>
<p>Programs contain sequences of statements, and a naive compiler would execute them exactly in the order as they are written. But an optimizing compiler is free to <em>reorder</em> the statements - or even parts of them - if the resulting "net effect" is the same. The "measure" of the "net effect" is what the standard calls "side
effects", and is accomplished exclusively through accesses (reads and writes) to variables qualified as <code>volatile</code>. So, as long as all volatile reads and writes are to the same addresses and in the same order (and writes write the same values), the program is correct, regardless of other operations in it. (One important point to note here is, that time duration between consecutive volatile accesses is not considered at all.)</p>
<p>Unfortunately, there are also operations which are not covered by volatile accesses. An example of this in avr-gcc/avr-libc are the <a class="el" href="group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162">cli()</a> and <a class="el" href="group__avr__interrupts.html#gaad5ebd34cb344c26ac87594f79b06b73">sei()</a> macros defined in &lt;<a class="el" href="interrupt_8h.html">avr/interrupt.h</a>&gt;, which convert directly to the respective assembler mnemonics through the <b>asm</b>() statement. These don't constitute a variable access at all, not even volatile, so the compiler is free to move them around. Although there is a "volatile" qualifier which can be attached to the <b>asm</b>() statement, its effect on (re)ordering is not clear from the documentation (and is more likely only to prevent complete removal by the optimiser), as it (among other) states:</p>
<p><em>Note that even a volatile asm instruction can be moved relative to other code, including across jump instructions. [...] Similarly, you can't expect a sequence of volatile asm instructions to remain perfectly consecutive.</em></p>
<dl class="section see"><dt>See also</dt><dd><a href="http://gcc.gnu.org/onlinedocs/gcc-4.3.4/gcc/Extended-Asm.html">http://gcc.gnu.org/onlinedocs/gcc-4.3.4/gcc/Extended-Asm.html</a></dd></dl>
<p>There is another mechanism which can be used to achieve something similar: <em>memory barriers</em>. This is accomplished through adding a special "memory" clobber to the inline <code>asm</code> statement, and ensures that all variables are flushed from registers to memory before the statement, and then re-read after the statement. The purpose of memory barriers is slightly different than to enforce code ordering: it is supposed to ensure that there are no variables "cached" in registers, so that it is safe to change the content of registers e.g. when switching context in a multitasking OS (on "big" processors with out-of-order execution they also imply usage of special instructions which force the processor into "in-order" state (this is not the case of AVRs)).</p>
<p>However, memory barrier works well in ensuring that all volatile accesses before and after the barrier occur in the given order with respect to the barrier. However, it does not ensure the compiler moving non-volatile-related statements across the barrier. Peter Dannegger provided a nice example of this effect:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define cli() __asm volatile( &quot;cli&quot; ::: &quot;memory&quot; )</span></div>
<div class="line"><span class="preprocessor">#define sei() __asm volatile( &quot;sei&quot; ::: &quot;memory&quot; )</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ivar;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> test2( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> val )</div>
<div class="line">{</div>
<div class="line">  val = 65535U / val;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162">cli</a>();</div>
<div class="line"></div>
<div class="line">  ivar = val;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="group__avr__interrupts.html#gaad5ebd34cb344c26ac87594f79b06b73">sei</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>compiles with optimisations switched on (-Os) to</p>
<pre class="fragment">00000112 &lt;test2&gt;:
 112:   bc 01           movw    r22, r24
 114:   f8 94           cli
 116:   8f ef           ldi     r24, 0xFF       ; 255
 118:   9f ef           ldi     r25, 0xFF       ; 255
 11a:   0e 94 96 00     call    0x12c   ; 0x12c &lt;__udivmodhi4&gt;
 11e:   70 93 01 02     sts     0x0201, r23
 122:   60 93 00 02     sts     0x0200, r22
 126:   78 94           sei
 128:   08 95           ret
</pre><p>where the potentially slow division is moved across <a class="el" href="group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162">cli()</a>, resulting in interrupts to be disabled longer than intended. Note, that the volatile access occurs in order with respect to <a class="el" href="group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162">cli()</a> or <a class="el" href="group__avr__interrupts.html#gaad5ebd34cb344c26ac87594f79b06b73">sei()</a>; so the "net effect" required by the standard is achieved as intended, it is "only" the timing which is off. However, for most of embedded applications, timing is an important, sometimes critical factor.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.mikrocontroller.net/topic/65923">https://www.mikrocontroller.net/topic/65923</a></dd></dl>
<p>Unfortunately, at the moment, in avr-gcc (nor in the C standard), there is no mechanism to enforce complete match of written and executed code ordering - except maybe of switching the optimization completely off (-O0), or writing all the critical code in assembly.</p>
<p>To sum it up:</p>
<ul>
<li>memory barriers ensure proper ordering of volatile accesses </li>
<li>memory barriers don't ensure statements with no volatile accesses to be reordered across the barrier </li>
</ul>
</div></div><!-- contents -->

<hr width="80%">
<p><center>Automatically generated by Doxygen 1.8.7 on Tue Aug 12 2014.</center></p>
</body>
</html>
