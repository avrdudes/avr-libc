<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>&lt;avr/pgmspace.h&gt;: Program Space Utilities</title>
    <link href="dox.css" rel="stylesheet" type="text/css">
  </head>
<body>
<center>
<table width="80%">
  <tr>
    <td align="left"><a href="http://www.nongnu.org/avr-libc/">AVR Libc Home Page</a></td>
    <td align="center" colspan=4><img src="avrs.png" alt="AVRs" align="middle" border="0"></td>
    <td align="right"><a href="https://savannah.nongnu.org/projects/avr-libc/">AVR Libc Development Pages</a></td>
  </tr>
  <tr>
    <td align="center" width="13%"><a href="index.html">Main Page</a></td>
    <td align="center" width="13%"><a href="pages.html">User Manual</a></td>
    <td align="center" width="13%"><a href="modules.html">Library Reference</a></td>
    <td align="center" width="13%"><a href="FAQ.html">FAQ</a></td>
    <td align="center" width="13%"><a href="globals.html">Alphabetical Index</a></td>
    <td align="center" width="13%"><a href="group__demos.html">Example Projects</a></td>
  </tr>
</table>
</center>
<hr width="80%">
<!-- Generated by Doxygen 1.8.7 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">&lt;avr/pgmspace.h&gt;: Program Space Utilities</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga75acaba9e781937468d0911423bc0c35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>&#160;&#160;&#160;__ATTR_PROGMEM__</td></tr>
<tr class="separator:ga75acaba9e781937468d0911423bc0c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga963f816fc88a5d8479c285ed4c630229"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga963f816fc88a5d8479c285ed4c630229">PGM_P</a>&#160;&#160;&#160;const char *</td></tr>
<tr class="separator:ga963f816fc88a5d8479c285ed4c630229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84a61d55b7efefabd8419e28f02704f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga84a61d55b7efefabd8419e28f02704f9">PGM_VOID_P</a>&#160;&#160;&#160;const void *</td></tr>
<tr class="separator:ga84a61d55b7efefabd8419e28f02704f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05ca900ebf7cd121be73c654d9ccb3eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga05ca900ebf7cd121be73c654d9ccb3eb">PSTR</a>(s)&#160;&#160;&#160;((const <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> char *)(s))</td></tr>
<tr class="separator:ga05ca900ebf7cd121be73c654d9ccb3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d7dd4863f87530e1a34ece430a587c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga88d7dd4863f87530e1a34ece430a587c">pgm_read_byte_near</a>(address_short)&#160;&#160;&#160;__LPM((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td></tr>
<tr class="separator:ga88d7dd4863f87530e1a34ece430a587c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf51eeaa847dd2668d2a66b70ecfb7398"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaf51eeaa847dd2668d2a66b70ecfb7398">pgm_read_word_near</a>(address_short)&#160;&#160;&#160;__LPM_word((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td></tr>
<tr class="separator:gaf51eeaa847dd2668d2a66b70ecfb7398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fa92c0a662403a643859e0f33b0a182"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga7fa92c0a662403a643859e0f33b0a182">pgm_read_dword_near</a>(address_short)&#160;&#160;&#160;__LPM_dword((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td></tr>
<tr class="separator:ga7fa92c0a662403a643859e0f33b0a182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga066040df814dabc7980cd1422508b46b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga066040df814dabc7980cd1422508b46b">pgm_read_float_near</a>(address_short)&#160;&#160;&#160;__LPM_float((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td></tr>
<tr class="separator:ga066040df814dabc7980cd1422508b46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcfd4df2e156efc1f6a380dfc58a5b81"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gadcfd4df2e156efc1f6a380dfc58a5b81">pgm_read_ptr_near</a>(address_short)&#160;&#160;&#160;(void*)__LPM_word((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td></tr>
<tr class="separator:gadcfd4df2e156efc1f6a380dfc58a5b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d4d7f6231716747c52b969d4febdeed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga0d4d7f6231716747c52b969d4febdeed">pgm_read_byte_far</a>(address_long)&#160;&#160;&#160;__ELPM((<a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td></tr>
<tr class="separator:ga0d4d7f6231716747c52b969d4febdeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7082c45c2c96f015c76eff1ad00a99a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gad7082c45c2c96f015c76eff1ad00a99a">pgm_read_word_far</a>(address_long)&#160;&#160;&#160;__ELPM_word((<a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td></tr>
<tr class="separator:gad7082c45c2c96f015c76eff1ad00a99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga309908c1b7430f0d140edb78fcf8f2b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga309908c1b7430f0d140edb78fcf8f2b9">pgm_read_dword_far</a>(address_long)&#160;&#160;&#160;__ELPM_dword((<a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td></tr>
<tr class="separator:ga309908c1b7430f0d140edb78fcf8f2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a5a593aa84062ca08b3f2d564a6f466"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga4a5a593aa84062ca08b3f2d564a6f466">pgm_read_float_far</a>(address_long)&#160;&#160;&#160;__ELPM_float((<a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td></tr>
<tr class="separator:ga4a5a593aa84062ca08b3f2d564a6f466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7756dce7bcc8ba46e648981fafebbf2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaa7756dce7bcc8ba46e648981fafebbf2">pgm_read_ptr_far</a>(address_long)&#160;&#160;&#160;(void*)__ELPM_word((<a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td></tr>
<tr class="separator:gaa7756dce7bcc8ba46e648981fafebbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73084a8bbde259ffae72980354b3f027"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga73084a8bbde259ffae72980354b3f027">pgm_read_byte</a>(address_short)&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga88d7dd4863f87530e1a34ece430a587c">pgm_read_byte_near</a>(address_short)</td></tr>
<tr class="separator:ga73084a8bbde259ffae72980354b3f027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32d8ab354156f4b1ffdb77a275ba6223"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga32d8ab354156f4b1ffdb77a275ba6223">pgm_read_word</a>(address_short)&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#gaf51eeaa847dd2668d2a66b70ecfb7398">pgm_read_word_near</a>(address_short)</td></tr>
<tr class="separator:ga32d8ab354156f4b1ffdb77a275ba6223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb68859ac5dfa6a09ac048b4037a83b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gabb68859ac5dfa6a09ac048b4037a83b6">pgm_read_dword</a>(address_short)&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga7fa92c0a662403a643859e0f33b0a182">pgm_read_dword_near</a>(address_short)</td></tr>
<tr class="separator:gabb68859ac5dfa6a09ac048b4037a83b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7911bddb066a8a038efc4b7857728fa8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga7911bddb066a8a038efc4b7857728fa8">pgm_read_float</a>(address_short)&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga066040df814dabc7980cd1422508b46b">pgm_read_float_near</a>(address_short)</td></tr>
<tr class="separator:ga7911bddb066a8a038efc4b7857728fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9f61931fd8cf4cf4764744dbaee81b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gac9f61931fd8cf4cf4764744dbaee81b6">pgm_read_ptr</a>(address_short)&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#gadcfd4df2e156efc1f6a380dfc58a5b81">pgm_read_ptr_near</a>(address_short)</td></tr>
<tr class="separator:gac9f61931fd8cf4cf4764744dbaee81b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gadb50761b9f19d45449445208778ee420"><td class="memItemLeft" align="right" valign="top">typedef void <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gadb50761b9f19d45449445208778ee420">prog_void</a></td></tr>
<tr class="separator:gadb50761b9f19d45449445208778ee420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa475b6b81fd8b34de45695da1da523b6"><td class="memItemLeft" align="right" valign="top">typedef char <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaa475b6b81fd8b34de45695da1da523b6">prog_char</a></td></tr>
<tr class="separator:gaa475b6b81fd8b34de45695da1da523b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d4701843a2019e3ef5a9866dc7586ed"><td class="memItemLeft" align="right" valign="top">typedef unsigned char <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga7d4701843a2019e3ef5a9866dc7586ed">prog_uchar</a></td></tr>
<tr class="separator:ga7d4701843a2019e3ef5a9866dc7586ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48c7cb011ea5f82f4b73df40e07dff46"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#gaef44329758059c91c76d334e8fc09700">int8_t</a> <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga48c7cb011ea5f82f4b73df40e07dff46">prog_int8_t</a></td></tr>
<tr class="separator:ga48c7cb011ea5f82f4b73df40e07dff46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39235a28487ae7790ce5f4c8178c8ed7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga39235a28487ae7790ce5f4c8178c8ed7">prog_uint8_t</a></td></tr>
<tr class="separator:ga39235a28487ae7790ce5f4c8178c8ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafc910d0b2c4d76afffa4710b98df6fa"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#ga932e6ccc3d54c58f761c1aead83bd6d7">int16_t</a> <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaafc910d0b2c4d76afffa4710b98df6fa">prog_int16_t</a></td></tr>
<tr class="separator:gaafc910d0b2c4d76afffa4710b98df6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93ec00229866bf6a125384ad08cefa73"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga93ec00229866bf6a125384ad08cefa73">prog_uint16_t</a></td></tr>
<tr class="separator:ga93ec00229866bf6a125384ad08cefa73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa839901aa518fb43d361588dd8d2b44b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#gadb828ef50c2dbb783109824e94cf6c47">int32_t</a> <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaa839901aa518fb43d361588dd8d2b44b">prog_int32_t</a></td></tr>
<tr class="separator:gaa839901aa518fb43d361588dd8d2b44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31bad0d22ead95a41e725c38ea63eb26"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a> <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga31bad0d22ead95a41e725c38ea63eb26">prog_uint32_t</a></td></tr>
<tr class="separator:ga31bad0d22ead95a41e725c38ea63eb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b1f9927f06d841e9ac07af62e71cfef"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#ga831d6234342279926bb11bad3a37add9">int64_t</a> <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga5b1f9927f06d841e9ac07af62e71cfef">prog_int64_t</a></td></tr>
<tr class="separator:ga5b1f9927f06d841e9ac07af62e71cfef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa50eebe90a40e0276bcc49ea0482b211"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#gad27ed092432b64ff558d2254c278720f">uint64_t</a> <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaa50eebe90a40e0276bcc49ea0482b211">prog_uint64_t</a></td></tr>
<tr class="separator:gaa50eebe90a40e0276bcc49ea0482b211"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga652cbaf54885c73c7ebbefe73524fa22"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga652cbaf54885c73c7ebbefe73524fa22">strtok_P</a> (char *s, <a class="el" href="group__avr__pgmspace.html#ga963f816fc88a5d8479c285ed4c630229">PGM_P</a> delim)</td></tr>
<tr class="separator:ga652cbaf54885c73c7ebbefe73524fa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80332272d69f05daab5f177723380175"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga80332272d69f05daab5f177723380175">memcmp_PF</a> (const void *, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>, size_t) __ATTR_PURE__</td></tr>
<tr class="separator:ga80332272d69f05daab5f177723380175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13cc6cd0692aeccaac2789350a16412b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga13cc6cd0692aeccaac2789350a16412b">memcpy_PF</a> (void *dest, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src, size_t len)</td></tr>
<tr class="separator:ga13cc6cd0692aeccaac2789350a16412b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga319ec42a66ba8333213fa10dbe06a606"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga319ec42a66ba8333213fa10dbe06a606">strcasecmp_PF</a> (const char *s1, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> s2) __ATTR_PURE__</td></tr>
<tr class="separator:ga319ec42a66ba8333213fa10dbe06a606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9530b4f628b49635c4085c269da8867a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga9530b4f628b49635c4085c269da8867a">strcat_PF</a> (char *dest, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src)</td></tr>
<tr class="separator:ga9530b4f628b49635c4085c269da8867a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad34d5b7d040fcb97939e939f19d88a5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gad34d5b7d040fcb97939e939f19d88a5f">strcmp_PF</a> (const char *s1, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> s2) __ATTR_PURE__</td></tr>
<tr class="separator:gad34d5b7d040fcb97939e939f19d88a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5af73767ca6defbec02736072dfb30"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gacd5af73767ca6defbec02736072dfb30">strcpy_PF</a> (char *dest, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src)</td></tr>
<tr class="separator:gacd5af73767ca6defbec02736072dfb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf632b479b04d0c98caf94de85dc11f3e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gaf632b479b04d0c98caf94de85dc11f3e">strlcat_PF</a> (char *dst, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src, size_t siz)</td></tr>
<tr class="separator:gaf632b479b04d0c98caf94de85dc11f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6674a08f95d5daedce3079b96be63008"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga6674a08f95d5daedce3079b96be63008">strlcpy_PF</a> (char *dst, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src, size_t siz)</td></tr>
<tr class="separator:ga6674a08f95d5daedce3079b96be63008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ce249cbcdb9ff968c76a2d917072da9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga4ce249cbcdb9ff968c76a2d917072da9">strlen_PF</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src)</td></tr>
<tr class="separator:ga4ce249cbcdb9ff968c76a2d917072da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga086db857a2372e4c84cc16204ac5292c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga086db857a2372e4c84cc16204ac5292c">strncasecmp_PF</a> (const char *s1, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> s2, size_t n) __ATTR_PURE__</td></tr>
<tr class="separator:ga086db857a2372e4c84cc16204ac5292c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga903fbfd9dcf93630e7a5da710d170da0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga903fbfd9dcf93630e7a5da710d170da0">strncat_PF</a> (char *dest, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src, size_t len)</td></tr>
<tr class="separator:ga903fbfd9dcf93630e7a5da710d170da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c3d78d72e8dc80e192d4bd6a65529e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga31c3d78d72e8dc80e192d4bd6a65529e">strncmp_PF</a> (const char *s1, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> s2, size_t n) __ATTR_PURE__</td></tr>
<tr class="separator:ga31c3d78d72e8dc80e192d4bd6a65529e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae01ef4b7da280c394f6d2ca37597b8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga4ae01ef4b7da280c394f6d2ca37597b8">strncpy_PF</a> (char *dest, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src, size_t len)</td></tr>
<tr class="separator:ga4ae01ef4b7da280c394f6d2ca37597b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d8784b274a123972f1b99a4a0a6a0f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga80d8784b274a123972f1b99a4a0a6a0f">strnlen_PF</a> (<a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> src, size_t len)</td></tr>
<tr class="separator:ga80d8784b274a123972f1b99a4a0a6a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0786ca7dc919f41f4586689aa77b04ef"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga0786ca7dc919f41f4586689aa77b04ef">strstr_PF</a> (const char *s1, <a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a> s2)</td></tr>
<tr class="separator:ga0786ca7dc919f41f4586689aa77b04ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io_8h.html">avr/io.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</span></div>
</div><!-- fragment --><p>The functions in this module provide interfaces for a program to access data stored in program space (flash memory) of the device. In order to use these functions, the target device must support either the <code>LPM</code> or <code>ELPM</code> instructions.</p>
<dl class="section note"><dt>Note</dt><dd>These functions are an attempt to provide some compatibility with header files that come with IAR C, to make porting applications between different compilers easier. This is not 100% compatibility though (GCC does not have full support for multiple address spaces yet).</dd>
<dd>
If you are working with strings which are completely based in ram, use the standard string functions described in <a class="el" href="group__avr__string.html">&lt;string.h&gt;: Strings</a>.</dd>
<dd>
If possible, put your constant tables in the lower 64 KB and use <a class="el" href="group__avr__pgmspace.html#ga88d7dd4863f87530e1a34ece430a587c">pgm_read_byte_near()</a> or <a class="el" href="group__avr__pgmspace.html#gaf51eeaa847dd2668d2a66b70ecfb7398">pgm_read_word_near()</a> instead of <a class="el" href="group__avr__pgmspace.html#ga0d4d7f6231716747c52b969d4febdeed">pgm_read_byte_far()</a> or <a class="el" href="group__avr__pgmspace.html#gad7082c45c2c96f015c76eff1ad00a99a">pgm_read_word_far()</a> since it is more efficient that way, and you can still use the upper 64K for executable code. All functions that are suffixed with a <code>_P</code> <em>require</em> their arguments to be in the lower 64 KB of the flash ROM, as they do not use ELPM instructions. This is normally not a big concern as the linker setup arranges any program space constants declared using the macros from this header file so they are placed right after the interrupt vectors, and in front of any executable code. However, it can become a problem if there are too many of these constants, or for bootloaders on devices with more than 64 KB of ROM. <em>All these functions will not work in that situation.</em></dd>
<dd>
For <b>Xmega</b> devices, make sure the NVM controller command register (<code>NVM.CMD</code> or <code>NVM_CMD</code>) is set to 0x00 (NOP) before using any of these functions. </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga963f816fc88a5d8479c285ed4c630229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PGM_P&#160;&#160;&#160;const char *</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to declare a variable that is a pointer to a string in program space. </p>

</div>
</div>
<a class="anchor" id="ga73084a8bbde259ffae72980354b3f027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_byte</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_short</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga88d7dd4863f87530e1a34ece430a587c">pgm_read_byte_near</a>(address_short)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a byte from the program space with a 16-bit (near) address.</p>
<dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d4d7f6231716747c52b969d4febdeed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_byte_far</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_long</td><td>)</td>
          <td>&#160;&#160;&#160;__ELPM((<a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a byte from the program space with a 32-bit (far) address.</p>
<dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="ga88d7dd4863f87530e1a34ece430a587c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_byte_near</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_short</td><td>)</td>
          <td>&#160;&#160;&#160;__LPM((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a byte from the program space with a 16-bit (near) address. </p><dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="gabb68859ac5dfa6a09ac048b4037a83b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_dword</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_short</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga7fa92c0a662403a643859e0f33b0a182">pgm_read_dword_near</a>(address_short)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a double word from the program space with a 16-bit (near) address.</p>
<dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="ga309908c1b7430f0d140edb78fcf8f2b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_dword_far</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_long</td><td>)</td>
          <td>&#160;&#160;&#160;__ELPM_dword((<a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a double word from the program space with a 32-bit (far) address.</p>
<dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fa92c0a662403a643859e0f33b0a182"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_dword_near</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_short</td><td>)</td>
          <td>&#160;&#160;&#160;__LPM_dword((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a double word from the program space with a 16-bit (near) address. </p><dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7911bddb066a8a038efc4b7857728fa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_float</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_short</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#ga066040df814dabc7980cd1422508b46b">pgm_read_float_near</a>(address_short)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a float from the program space with a 16-bit (near) address.</p>
<dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a5a593aa84062ca08b3f2d564a6f466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_float_far</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_long</td><td>)</td>
          <td>&#160;&#160;&#160;__ELPM_float((<a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a float from the program space with a 32-bit (far) address.</p>
<dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="ga066040df814dabc7980cd1422508b46b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_float_near</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_short</td><td>)</td>
          <td>&#160;&#160;&#160;__LPM_float((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a float from the program space with a 16-bit (near) address. </p><dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="gac9f61931fd8cf4cf4764744dbaee81b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_ptr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_short</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#gadcfd4df2e156efc1f6a380dfc58a5b81">pgm_read_ptr_near</a>(address_short)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a pointer from the program space with a 16-bit (near) address.</p>
<dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7756dce7bcc8ba46e648981fafebbf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_ptr_far</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_long</td><td>)</td>
          <td>&#160;&#160;&#160;(void*)__ELPM_word((<a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a pointer from the program space with a 32-bit (far) address.</p>
<dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="gadcfd4df2e156efc1f6a380dfc58a5b81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_ptr_near</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_short</td><td>)</td>
          <td>&#160;&#160;&#160;(void*)__LPM_word((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a pointer from the program space with a 16-bit (near) address. </p><dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="ga32d8ab354156f4b1ffdb77a275ba6223"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_word</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_short</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__avr__pgmspace.html#gaf51eeaa847dd2668d2a66b70ecfb7398">pgm_read_word_near</a>(address_short)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a word from the program space with a 16-bit (near) address.</p>
<dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="gad7082c45c2c96f015c76eff1ad00a99a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_word_far</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_long</td><td>)</td>
          <td>&#160;&#160;&#160;__ELPM_word((<a class="el" href="group__avr__stdint.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a word from the program space with a 32-bit (far) address.</p>
<dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf51eeaa847dd2668d2a66b70ecfb7398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_word_near</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">address_short</td><td>)</td>
          <td>&#160;&#160;&#160;__LPM_word((<a class="el" href="group__avr__stdint.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a word from the program space with a 16-bit (near) address. </p><dl class="section note"><dt>Note</dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div>
<a class="anchor" id="ga84a61d55b7efefabd8419e28f02704f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PGM_VOID_P&#160;&#160;&#160;const void *</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to declare a generic pointer to an object in program space. </p>

</div>
</div>
<a class="anchor" id="ga75acaba9e781937468d0911423bc0c35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROGMEM&#160;&#160;&#160;__ATTR_PROGMEM__</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attribute to use in order to declare an object being located in flash ROM. </p>

</div>
</div>
<a class="anchor" id="ga05ca900ebf7cd121be73c654d9ccb3eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSTR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s</td><td>)</td>
          <td>&#160;&#160;&#160;((const <a class="el" href="group__avr__pgmspace.html#ga75acaba9e781937468d0911423bc0c35">PROGMEM</a> char *)(s))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to declare a static pointer to a string in program space. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaa475b6b81fd8b34de45695da1da523b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#gaa475b6b81fd8b34de45695da1da523b6">prog_char</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>DEPRECATED</dd></dl>
<p>This typedef is now deprecated because the usage of the <b>progmem</b> attribute on a type is not supported in GCC. However, the use of the <b>progmem</b> attribute on a variable declaration is supported, and this is now the recommended usage.</p>
<p>The typedef is only visible if the macro <b>PROG_TYPES_COMPAT</b> has been defined before including &lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt; (either by a #define directive, or by a -D compiler option.)</p>
<p>Type of a "char" object located in flash ROM. </p>

</div>
</div>
<a class="anchor" id="gaafc910d0b2c4d76afffa4710b98df6fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#gaafc910d0b2c4d76afffa4710b98df6fa">prog_int16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>DEPRECATED</dd></dl>
<p>This typedef is now deprecated because the usage of the <b>progmem</b> attribute on a type is not supported in GCC. However, the use of the <b>progmem</b> attribute on a variable declaration is supported, and this is now the recommended usage.</p>
<p>The typedef is only visible if the macro <b>PROG_TYPES_COMPAT</b> has been defined before including &lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt; (either by a #define directive, or by a -D compiler option.)</p>
<p>Type of an "int16_t" object located in flash ROM. </p>

</div>
</div>
<a class="anchor" id="gaa839901aa518fb43d361588dd8d2b44b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#gaa839901aa518fb43d361588dd8d2b44b">prog_int32_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>DEPRECATED</dd></dl>
<p>This typedef is now deprecated because the usage of the <b>progmem</b> attribute on a type is not supported in GCC. However, the use of the <b>progmem</b> attribute on a variable declaration is supported, and this is now the recommended usage.</p>
<p>The typedef is only visible if the macro <b>PROG_TYPES_COMPAT</b> has been defined before including &lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt; (either by a #define directive, or by a -D compiler option.)</p>
<p>Type of an "int32_t" object located in flash ROM. </p>

</div>
</div>
<a class="anchor" id="ga5b1f9927f06d841e9ac07af62e71cfef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#ga5b1f9927f06d841e9ac07af62e71cfef">prog_int64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>DEPRECATED</dd></dl>
<p>This typedef is now deprecated because the usage of the <b>progmem</b> attribute on a type is not supported in GCC. However, the use of the <b>progmem</b> attribute on a variable declaration is supported, and this is now the recommended usage.</p>
<p>The typedef is only visible if the macro <b>PROG_TYPES_COMPAT</b> has been defined before including &lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt; (either by a #define directive, or by a -D compiler option.)</p>
<p>Type of an "int64_t" object located in flash ROM.</p>
<dl class="section note"><dt>Note</dt><dd>This type is not available when the compiler option -mint8 is in effect. </dd></dl>

</div>
</div>
<a class="anchor" id="ga48c7cb011ea5f82f4b73df40e07dff46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#ga48c7cb011ea5f82f4b73df40e07dff46">prog_int8_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>DEPRECATED</dd></dl>
<p>This typedef is now deprecated because the usage of the <b>progmem</b> attribute on a type is not supported in GCC. However, the use of the <b>progmem</b> attribute on a variable declaration is supported, and this is now the recommended usage.</p>
<p>The typedef is only visible if the macro <b>PROG_TYPES_COMPAT</b> has been defined before including &lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt; (either by a #define directive, or by a -D compiler option.)</p>
<p>Type of an "int8_t" object located in flash ROM. </p>

</div>
</div>
<a class="anchor" id="ga7d4701843a2019e3ef5a9866dc7586ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#ga7d4701843a2019e3ef5a9866dc7586ed">prog_uchar</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>DEPRECATED</dd></dl>
<p>This typedef is now deprecated because the usage of the <b>progmem</b> attribute on a type is not supported in GCC. However, the use of the <b>progmem</b> attribute on a variable declaration is supported, and this is now the recommended usage.</p>
<p>The typedef is only visible if the macro <b>PROG_TYPES_COMPAT</b> has been defined before including &lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt; (either by a #define directive, or by a -D compiler option.)</p>
<p>Type of an "unsigned char" object located in flash ROM. </p>

</div>
</div>
<a class="anchor" id="ga93ec00229866bf6a125384ad08cefa73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#ga93ec00229866bf6a125384ad08cefa73">prog_uint16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>DEPRECATED</dd></dl>
<p>This typedef is now deprecated because the usage of the <b>progmem</b> attribute on a type is not supported in GCC. However, the use of the <b>progmem</b> attribute on a variable declaration is supported, and this is now the recommended usage.</p>
<p>The typedef is only visible if the macro <b>PROG_TYPES_COMPAT</b> has been defined before including &lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt; (either by a #define directive, or by a -D compiler option.)</p>
<p>Type of an "uint16_t" object located in flash ROM. </p>

</div>
</div>
<a class="anchor" id="ga31bad0d22ead95a41e725c38ea63eb26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#ga31bad0d22ead95a41e725c38ea63eb26">prog_uint32_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>DEPRECATED</dd></dl>
<p>This typedef is now deprecated because the usage of the <b>progmem</b> attribute on a type is not supported in GCC. However, the use of the <b>progmem</b> attribute on a variable declaration is supported, and this is now the recommended usage.</p>
<p>The typedef is only visible if the macro <b>PROG_TYPES_COMPAT</b> has been defined before including &lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt; (either by a #define directive, or by a -D compiler option.)</p>
<p>Type of an "uint32_t" object located in flash ROM. </p>

</div>
</div>
<a class="anchor" id="gaa50eebe90a40e0276bcc49ea0482b211"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#gaa50eebe90a40e0276bcc49ea0482b211">prog_uint64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>DEPRECATED</dd></dl>
<p>This typedef is now deprecated because the usage of the <b>progmem</b> attribute on a type is not supported in GCC. However, the use of the <b>progmem</b> attribute on a variable declaration is supported, and this is now the recommended usage.</p>
<p>The typedef is only visible if the macro <b>PROG_TYPES_COMPAT</b> has been defined before including &lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt; (either by a #define directive, or by a -D compiler option.)</p>
<p>Type of an "uint64_t" object located in flash ROM.</p>
<dl class="section note"><dt>Note</dt><dd>This type is not available when the compiler option -mint8 is in effect. </dd></dl>

</div>
</div>
<a class="anchor" id="ga39235a28487ae7790ce5f4c8178c8ed7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#ga39235a28487ae7790ce5f4c8178c8ed7">prog_uint8_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>DEPRECATED</dd></dl>
<p>This typedef is now deprecated because the usage of the <b>progmem</b> attribute on a type is not supported in GCC. However, the use of the <b>progmem</b> attribute on a variable declaration is supported, and this is now the recommended usage.</p>
<p>The typedef is only visible if the macro <b>PROG_TYPES_COMPAT</b> has been defined before including &lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt; (either by a #define directive, or by a -D compiler option.)</p>
<p>Type of an "uint8_t" object located in flash ROM. </p>

</div>
</div>
<a class="anchor" id="gadb50761b9f19d45449445208778ee420"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#gadb50761b9f19d45449445208778ee420">prog_void</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>DEPRECATED</dd></dl>
<p>This typedef is now deprecated because the usage of the <b>progmem</b> attribute on a type is not supported in GCC. However, the use of the <b>progmem</b> attribute on a variable declaration is supported, and this is now the recommended usage.</p>
<p>The typedef is only visible if the macro <b>PROG_TYPES_COMPAT</b> has been defined before including &lt;<a class="el" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt; (either by a #define directive, or by a -D compiler option.)</p>
<p>Type of a "void" object located in flash ROM. Does not make much sense by itself, but can be used to declare a "void *" object in flash ROM. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga80332272d69f05daab5f177723380175"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int memcmp_PF </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare memory areas. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga80332272d69f05daab5f177723380175" title="Compare memory areas. ">memcmp_PF()</a> function compares the first <code>len</code> bytes of the memory areas <code>s1</code> and flash <code>s2</code>. The comparision is performed using unsigned char operations. It is an equivalent of memcmp_P() function, except that it is capable working on all FLASH including the exteded area above 64kB.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga80332272d69f05daab5f177723380175" title="Compare memory areas. ">memcmp_PF()</a> function returns an integer less than, equal to, or greater than zero if the first <code>len</code> bytes of <code>s1</code> is found, respectively, to be less than, to match, or be greater than the first <code>len</code> bytes of <code>s2</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga13cc6cd0692aeccaac2789350a16412b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memcpy_PF </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a memory block from flash to SRAM. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga13cc6cd0692aeccaac2789350a16412b" title="Copy a memory block from flash to SRAM. ">memcpy_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga5f60008005ea7557430149926cf583d7" title="Copy a memory area. ">memcpy()</a>, except the data is copied from the program space and is addressed using a far pointer </p><pre class="fragment">\param dst A pointer to the destination buffer
\param src A far pointer to the origin of data in flash memory
\param n The number of bytes to be copied
</pre><dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga13cc6cd0692aeccaac2789350a16412b" title="Copy a memory block from flash to SRAM. ">memcpy_PF()</a> function returns a pointer to <em>dst</em>. The contents of RAMPZ SFR are undefined when the function returns </dd></dl>

</div>
</div>
<a class="anchor" id="ga319ec42a66ba8333213fa10dbe06a606"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strcasecmp_PF </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings ignoring case. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga319ec42a66ba8333213fa10dbe06a606" title="Compare two strings ignoring case. ">strcasecmp_PF()</a> function compares the two strings <em>s1</em> and <em>s2</em>, ignoring the case of the characters</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>A pointer to the first string in SRAM </td></tr>
    <tr><td class="paramname">s2</td><td>A far pointer to the second string in Flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga319ec42a66ba8333213fa10dbe06a606" title="Compare two strings ignoring case. ">strcasecmp_PF()</a> function returns an integer less than, equal to, or greater than zero if <em>s1</em> is found, respectively, to be less than, to match, or be greater than <em>s2</em>. The contents of RAMPZ SFR are undefined when the function returns </dd></dl>

</div>
</div>
<a class="anchor" id="ga9530b4f628b49635c4085c269da8867a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcat_PF </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates two strings. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga9530b4f628b49635c4085c269da8867a" title="Concatenates two strings. ">strcat_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga1fd2a6e188f02599e5eeb17519f67f3e" title="Concatenate two strings. ">strcat()</a> except that the <em>src</em> string must be located in program space (flash) and is addressed using a far pointer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>A pointer to the destination string in SRAM </td></tr>
    <tr><td class="paramname">src</td><td>A far pointer to the string to be appended in Flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga9530b4f628b49635c4085c269da8867a" title="Concatenates two strings. ">strcat_PF()</a> function returns a pointer to the resulting string <em>dst</em>. The contents of RAMPZ SFR are undefined when the function returns </dd></dl>

</div>
</div>
<a class="anchor" id="gad34d5b7d040fcb97939e939f19d88a5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strcmp_PF </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two strings. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#gad34d5b7d040fcb97939e939f19d88a5f" title="Compares two strings. ">strcmp_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga46f3cbd2de457c0fb340a1f379fc33ba" title="Compare two strings. ">strcmp()</a> except that <em>s2</em> is a far pointer to a string in program space</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>A pointer to the first string in SRAM </td></tr>
    <tr><td class="paramname">s2</td><td>A far pointer to the second string in Flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#gad34d5b7d040fcb97939e939f19d88a5f" title="Compares two strings. ">strcmp_PF()</a> function returns an integer less than, equal to, or greater than zero if <em>s1</em> is found, respectively, to be less than, to match, or be greater than <em>s2</em>. The contents of RAMPZ SFR are undefined when the function returns </dd></dl>

</div>
</div>
<a class="anchor" id="gacd5af73767ca6defbec02736072dfb30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcpy_PF </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a string. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#gacd5af73767ca6defbec02736072dfb30" title="Duplicate a string. ">strcpy_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga54e4f23104fa6f722f9459d2673a1eba" title="Copy a string. ">strcpy()</a> except that <em>src</em> is a far pointer to a string in program space</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>A pointer to the destination string in SRAM </td></tr>
    <tr><td class="paramname">src</td><td>A far pointer to the source string in Flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#gacd5af73767ca6defbec02736072dfb30" title="Duplicate a string. ">strcpy_PF()</a> function returns a pointer to the destination string <em>dst</em>. The contents of RAMPZ SFR are undefined when the funcion returns </dd></dl>

</div>
</div>
<a class="anchor" id="gaf632b479b04d0c98caf94de85dc11f3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlcat_PF </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two strings. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#gaf632b479b04d0c98caf94de85dc11f3e" title="Concatenate two strings. ">strlcat_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga63e609bfa0d354dcd7e35b297c2e6fdd" title="Concatenate two strings. ">strlcat()</a>, except that the <em>src</em> string must be located in program space (flash) and is addressed using a far pointer</p>
<p>Appends src to string dst of size <em>n</em> (unlike <a class="el" href="group__avr__string.html#gafa4a8701698b766f40180c735726cfe7" title="Concatenate two strings. ">strncat()</a>, <em>n</em> is the full size of <em>dst</em>, not space left). At most <em>n-1</em> characters will be copied. Always NULL terminates (unless <em>n</em> &lt;= strlen(<em>dst</em>))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>A pointer to the destination string in SRAM </td></tr>
    <tr><td class="paramname">src</td><td>A far pointer to the source string in Flash </td></tr>
    <tr><td class="paramname">n</td><td>The total number of bytes allocated to the destination string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#gaf632b479b04d0c98caf94de85dc11f3e" title="Concatenate two strings. ">strlcat_PF()</a> function returns strlen(<em>src</em>) + MIN(<em>n</em>, strlen(initial <em>dst</em>)). If retval &gt;= <em>n</em>, truncation occurred. The contents of RAMPZ SFR are undefined when the funcion returns </dd></dl>

</div>
</div>
<a class="anchor" id="ga6674a08f95d5daedce3079b96be63008"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlcpy_PF </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string from progmem to RAM. </p>
<p>Copy src to string dst of size siz. At most siz-1 characters will be copied. Always NULL terminates (unless siz == 0).</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga6674a08f95d5daedce3079b96be63008" title="Copy a string from progmem to RAM. ">strlcpy_PF()</a> function returns strlen(src). If retval &gt;= siz, truncation occurred. The contents of RAMPZ SFR are undefined when the function returns </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ce249cbcdb9ff968c76a2d917072da9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlen_PF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the length of a string. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga4ce249cbcdb9ff968c76a2d917072da9" title="Obtain the length of a string. ">strlen_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga7fd4936b86eb6b87e98587044c562715" title="Calculate the length of a string. ">strlen()</a>, except that <em>s</em> is a far pointer to a string in program space</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A far pointer to the string in flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga4ce249cbcdb9ff968c76a2d917072da9" title="Obtain the length of a string. ">strlen_PF()</a> function returns the number of characters in <em>s</em>. The contents of RAMPZ SFR are undefined when the function returns </dd></dl>

</div>
</div>
<a class="anchor" id="ga086db857a2372e4c84cc16204ac5292c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strncasecmp_PF </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings ignoring case. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga086db857a2372e4c84cc16204ac5292c" title="Compare two strings ignoring case. ">strncasecmp_PF()</a> function is similar to <a class="el" href="group__avr__pgmspace.html#ga319ec42a66ba8333213fa10dbe06a606" title="Compare two strings ignoring case. ">strcasecmp_PF()</a>, except it only compares the first <em>n</em> characters of <em>s1</em> and the string in flash is addressed using a far pointer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>A pointer to a string in SRAM </td></tr>
    <tr><td class="paramname">s2</td><td>A far pointer to a string in Flash </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of bytes to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga086db857a2372e4c84cc16204ac5292c" title="Compare two strings ignoring case. ">strncasecmp_PF()</a> function returns an integer less than, equal to, or greater than zero if <em>s1</em> (or the first <em>n</em> bytes thereof) is found, respectively, to be less than, to match, or be greater than <em>s2</em>. The contents of RAMPZ SFR are undefined when the function returns </dd></dl>

</div>
</div>
<a class="anchor" id="ga903fbfd9dcf93630e7a5da710d170da0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strncat_PF </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two strings. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga903fbfd9dcf93630e7a5da710d170da0" title="Concatenate two strings. ">strncat_PF()</a> function is similar to <a class="el" href="group__avr__string.html#gafa4a8701698b766f40180c735726cfe7" title="Concatenate two strings. ">strncat()</a>, except that the <em>src</em> string must be located in program space (flash) and is addressed using a far pointer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>A pointer to the destination string in SRAM </td></tr>
    <tr><td class="paramname">src</td><td>A far pointer to the source string in Flash </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of bytes to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga903fbfd9dcf93630e7a5da710d170da0" title="Concatenate two strings. ">strncat_PF()</a> function returns a pointer to the resulting string <em>dst</em>. The contents of RAMPZ SFR are undefined when the function returns </dd></dl>

</div>
</div>
<a class="anchor" id="ga31c3d78d72e8dc80e192d4bd6a65529e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strncmp_PF </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two strings with limited length. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga31c3d78d72e8dc80e192d4bd6a65529e" title="Compare two strings with limited length. ">strncmp_PF()</a> function is similar to <a class="el" href="group__avr__pgmspace.html#gad34d5b7d040fcb97939e939f19d88a5f" title="Compares two strings. ">strcmp_PF()</a> except it only compares the first (at most) <em>n</em> characters of <em>s1</em> and <em>s2</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>A pointer to the first string in SRAM </td></tr>
    <tr><td class="paramname">s2</td><td>A far pointer to the second string in Flash </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of bytes to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga31c3d78d72e8dc80e192d4bd6a65529e" title="Compare two strings with limited length. ">strncmp_PF()</a> function returns an integer less than, equal to, or greater than zero if <em>s1</em> (or the first <em>n</em> bytes thereof) is found, respectively, to be less than, to match, or be greater than <em>s2</em>. The contents of RAMPZ SFR are undefined when the function returns </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ae01ef4b7da280c394f6d2ca37597b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strncpy_PF </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a string until a limited length. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga4ae01ef4b7da280c394f6d2ca37597b8" title="Duplicate a string until a limited length. ">strncpy_PF()</a> function is similar to <a class="el" href="group__avr__pgmspace.html#gacd5af73767ca6defbec02736072dfb30" title="Duplicate a string. ">strcpy_PF()</a> except that not more than <em>n</em> bytes of <em>src</em> are copied. Thus, if there is no null byte among the first <em>n</em> bytes of <em>src</em>, the result will not be null-terminated</p>
<p>In the case where the length of <em>src</em> is less than that of <em>n</em>, the remainder of <em>dst</em> will be padded with nulls</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>A pointer to the destination string in SRAM </td></tr>
    <tr><td class="paramname">src</td><td>A far pointer to the source string in Flash </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga4ae01ef4b7da280c394f6d2ca37597b8" title="Duplicate a string until a limited length. ">strncpy_PF()</a> function returns a pointer to the destination string <em>dst</em>. The contents of RAMPZ SFR are undefined when the function returns </dd></dl>

</div>
</div>
<a class="anchor" id="ga80d8784b274a123972f1b99a4a0a6a0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strnlen_PF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the length of a fixed-size string. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga80d8784b274a123972f1b99a4a0a6a0f" title="Determine the length of a fixed-size string. ">strnlen_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga3d3e512a095039a7e2f86859537d761b" title="Determine the length of a fixed-size string. ">strnlen()</a>, except that <em>s</em> is a far pointer to a string in program space</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A far pointer to the string in Flash </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of length to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The strnlen_PF function returns strlen_P(<em>s</em>), if that is less than <em>len</em>, or <em>len</em> if there is no '\0' character among the first <em>len</em> characters pointed to by <em>s</em>. The contents of RAMPZ SFR are undefined when the function returns </dd></dl>

</div>
</div>
<a class="anchor" id="ga0786ca7dc919f41f4586689aa77b04ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strstr_PF </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__inttypes.html#ga72b6692e3f3123903c1a0d9a960c59b1">uint_farptr_t</a>&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate a substring. </p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga0786ca7dc919f41f4586689aa77b04ef" title="Locate a substring. ">strstr_PF()</a> function finds the first occurrence of the substring <code>s2</code> in the string <code>s1</code>. The terminating '\0' characters are not compared. The <a class="el" href="group__avr__pgmspace.html#ga0786ca7dc919f41f4586689aa77b04ef" title="Locate a substring. ">strstr_PF()</a> function is similar to <a class="el" href="group__avr__string.html#ga6a441da9211eb85881d99c60b1003552" title="Locate a substring. ">strstr()</a> except that <code>s2</code> is a far pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga0786ca7dc919f41f4586689aa77b04ef" title="Locate a substring. ">strstr_PF()</a> function returns a pointer to the beginning of the substring, or NULL if the substring is not found. If <code>s2</code> points to a string of zero length, the function returns <code>s1</code>. The contents of RAMPZ SFR are undefined when the function returns </dd></dl>

</div>
</div>
<a class="anchor" id="ga652cbaf54885c73c7ebbefe73524fa22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* strtok_P </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__avr__pgmspace.html#ga963f816fc88a5d8479c285ed4c630229">PGM_P</a>&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the string into tokens. </p>
<p><a class="el" href="group__avr__pgmspace.html#ga652cbaf54885c73c7ebbefe73524fa22" title="Parses the string into tokens. ">strtok_P()</a> parses the string <code>s</code> into tokens. The first call to <a class="el" href="group__avr__pgmspace.html#ga652cbaf54885c73c7ebbefe73524fa22" title="Parses the string into tokens. ">strtok_P()</a> should have <code>s</code> as its first argument. Subsequent calls should have the first argument set to NULL. If a token ends with a delimiter, this delimiting character is overwritten with a '\0' and a pointer to the next character is saved for the next call to <a class="el" href="group__avr__pgmspace.html#ga652cbaf54885c73c7ebbefe73524fa22" title="Parses the string into tokens. ">strtok_P()</a>. The delimiter string <code>delim</code> may be different for each call.</p>
<p>The <a class="el" href="group__avr__pgmspace.html#ga652cbaf54885c73c7ebbefe73524fa22" title="Parses the string into tokens. ">strtok_P()</a> function is similar to <a class="el" href="group__avr__string.html#ga6ace85338eafe22a0ff52c00eb9779b8" title="Parses the string s into tokens. ">strtok()</a> except that <code>delim</code> is pointer to a string in program space.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga652cbaf54885c73c7ebbefe73524fa22" title="Parses the string into tokens. ">strtok_P()</a> function returns a pointer to the next token or NULL when no more tokens are found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__avr__pgmspace.html#ga652cbaf54885c73c7ebbefe73524fa22" title="Parses the string into tokens. ">strtok_P()</a> is NOT reentrant. For a reentrant version of this function see strtok_rP(). </dd></dl>

</div>
</div>
</div><!-- contents -->

<hr width="80%">
<p><center>Automatically generated by Doxygen 1.8.7 on Tue Aug 12 2014.</center></p>
</body>
</html>
