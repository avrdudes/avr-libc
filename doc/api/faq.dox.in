/* Copyright (c) 2002-2007 Joerg Wunsch
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
   * Neither the name of the copyright holders nor the names of
     contributors may be used to endorse or promote products derived
     from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

/* @configure_input@ */

/** \page FAQ Frequently Asked Questions

\section faq_index FAQ Index

\addindex FAQ

- <b>Interrupts</b>
  - \ref faq_volatile
  - \ref faq_16bitio
  - \ref faq_isr_names
  - \ref faq_reentrant
  - \ref faq_spman
  - \ref faq_intbits
  - \ref faq_cvt
  - \ref faq_local_isr

- <b>C/C++</b>
  - \ref faq_cplusplus
  - \ref faq_optflags
  - \ref faq_varinit
  - \ref faq_flashstrings
  - \ref faq_rom_array
  - \ref faq_startup
  - \ref faq_port_pass
  - \ref faq_call_asm
  - \ref faq_regbind
  - \ref faq_assign_chain
  - \ref faq_use_bv
  - \ref faq_tinyavr_c
  - \ref faq_AVRrc

- <b>(Inline) Assembly</b>

  - \ref faq_asmconst "How do I use a \#define'd constant in an asm statement?"<!-- The explicit text is necessary since doxygen stumbles on the #define otherwise. -->
  - \ref faq_asmops
  - \ref faq_call_asm
  - \ref faq_nonabi

- <b>Binary Interface</b>
  - \ref faq_reg_usage
  - \ref faq_funcptr_gt128kib
  - \ref faq_eind
  - \ref faq_rampx

- <b>Linking and Binaries</b>
  - \ref faq_reloc_code
  - \ref faq_binarydata
    - \ref faq_binarydata_embed "Using \#embed"
    - \ref faq_binarydata_incbin
    - \ref faq_binarydata_objcopy
  - \ref faq_linkerscripts

- <b>Static Analysis</b>
  - \ref faq_headers
  - \ref faq_macros
  - \ref faq_ramoverlap

- <b>Debugging</b>
  - \ref faq_gdboptimize
  - \ref faq_asmstabs

- <b>Hardware</b>
  - \ref faq_softreset
  - \ref faq_eeprom_corruption
  - \ref faq_fuses
  - \ref faq_fuselow
  - \ref faq_ext_ram

- <b>Toolchain</b>
  - \ref faq_toolchain_version

- <b>Other</b>
  - \ref faq_wrong_baud_rate
  - \ref faq_clockskew

\section faq_volatile Why doesn't my program recognize a variable updated in an interrupt routine?

When using the optimizer, in a loop like the following one:

\code
uint8_t flag; // volatile is missing

ISR(SOME_vect)
{
  flag = 1;
}
...

    while (flag == 0)
    {
        ...
    }
\endcode

the compiler will typically access \c flag only once, and optimize further
accesses completely away,
since its code path analysis shows that nothing inside the loop
could change the value of \c flag anyway.  To tell the compiler that
this variable could be changed outside the scope of its code path
analysis (e. g. from within an interrupt routine), the variable needs
to be qualified as volatile:

\code
volatile uint8_t flag;
\endcode

<small>Back to \ref faq_index.</small>


\section faq_regbind How to permanently bind a variable to a register?

This can be done with

\code
register uint8_t counter __asm("r3");
\endcode

Typically, it should be safe to use r2 through r7 that way.

Registers r8 through r25 can be used for argument passing by the
compiler in case many or long arguments are being passed to callees.
If this is not the case throughout the entire application, these
registers could be used for register variables as well.

\warning Extreme care should be taken that the entire application is
compiled with a consistent set of register-allocated variables
including possibly used library functions.  This can be achieved
by compiling each module with \c -ffixed-r3 or \c -ffixed-3.
Notice that when you are using library functions from libgcc
(the avr-gcc runtime library) or AVR-LibC, then these libraries
were generated \e without the requirement to avoid specific registers.
Hence when you are using libraries from the distribution, you must
make sure that none of the reserved registers is used in the generated
binary.

\warning Also notice that global register variables can't be volatile,
because only variables in memory can be volatile, and register variables
are not located in memory.

<small>Back to \ref faq_index.</small>


\section faq_startup How to modify MCUCR or WDTCR early?

Basically, write a small function which looks like this:

\code
#include <avr/io.h>

static __attribute__((used, unused, naked, section(".init3")))
void init_MCUCR (void);

void init_MCUCR (void)
{
    MCUCR = _BV(SRE) | _BV(SRW);
}
\endcode

Do not call this function by hand! This piece of code will be inserted in
\ref sec_dot_init "startup code", which is run right after reset.
For the meaning of the attributes, see \ref faq_softreset

The advantage of this method is that you can insert any initialization
code you want (just remember that this is very early startup -- no
stack and no <tt>\ref zero_reg "__zero_reg__"</tt> yet),
and no program memory space is wasted if this feature is not used.

There should be no need to modify linker scripts anymore, except for
some very special cases.  It is best to leave <tt>__stack</tt> at its
default value (end of internal SRAM -- faster, and required on some
devices like ATmega161 because of errata), and add
<tt>-Wl,-Tdata,0x801100</tt> to start the data section above the
stack.

For more information on using sections,
see \ref mem_sections.
There is also an example for \ref c_sections.
Note that in C code, any such function would
preferably be placed into section <code>.init3</code> as the code in
<code>.init2</code>
ensures the internal register <tt>__zero_reg__</tt> is already cleared.

<small>Back to \ref faq_index.</small>


\section faq_cplusplus Can I use C++ on the AVR?

Basically yes, C++ is supported (assuming your compiler has been
configured and compiled to support it, of course).  Source files
ending in \c \.cc, \c \.cpp or \c \.C will automatically cause the
compiler frontend to invoke the C++ compiler.  Alternatively, the C++
compiler could be explicitly called by the name \c avr-c++.

However, there's currently no support for \c libstdc++, the standard
support library needed for a complete C++ implementation.  This
imposes a number of restrictions on the C++ programs that can be
compiled.  Among them are:

- Obviously, none of the C++ related standard functions, classes,
  and template classes are available.

- The operators \c new and \c delete are not implemented, attempting
  to use them will cause the linker to complain about undefined
  external references.  (This could perhaps be fixed.)

- Some of the supplied include files are not C++ safe, i. e. they need
  to be wrapped into \code extern "C" { ... } \endcode
  (This could certainly be fixed, too.)

- Exceptions are not supported.  Since exceptions are enabled by
  default in the C++ frontend, they explicitly need to be turned
  off using \c -fno-exceptions in the compiler options.  Failing
  this, the linker will complain about an undefined external
  reference to \c __gxx_personality_sj0.

Constructors and destructors \e are supported though, including global
ones.

When programming C++ in space- and runtime-sensitive environments like
microcontrollers, extra care should be taken to avoid unwanted side
effects of the C++ calling conventions like implied copy constructors
that could be called upon function invocation etc.  These things could
easily add up into a considerable amount of time and program memory
wasted.  Thus, casual inspection of the generated assembler code
(using the \ref opt_save_temps "-save-temps" compiler option)
seems to be warranted.

<small>Back to \ref faq_index.</small>


\section faq_asmconst How do I use a \#define&apos;d constant in an asm statement?

So you tried this:

\code
asm volatile ("sbi 0x18, 7" ::: "memory");
\endcode

Which works. When you do the same thing but replace the address of the port
by its macro name, like this:

\code
asm volatile ("sbi PORTB, 7" ::: "memory");
\endcode

you get a syntax error from the assembler:
<tt>"Error: constant value required"</tt>.

\c PORTB is a precompiler definition included in the processor specific file
included in \c avr/io.h. As you may know, the precompiler will not touch
strings, and <tt>PORTB</tt> gets passed to the
assembler instead of <tt>0x18</tt>. One way to avoid this problem is:

\code
asm volatile ("sbi %0, 7" :: "I" (_SFR_IO_ADDR(PORTB)) : "memory");
\endcode

\note For C programs, rather use the standard C bit operators instead,
so the above would be expressed as <tt>PORTB |= (1 &lt;&lt; 7)</tt>.  The
optimizer will take care to transform this into a single SBI
instruction, assuming the operands allow for this.

There are situation though where the address of a special function register
(SFR) is required in inline assembly.  When the register can be accessed by
\c LDS and \c STS, one can use the RAM address of the SFR:

\code
asm volatile ("sts %0, __zero_reg__" :: "n" (& PORTB) : "memory");
\endcode

When the I/O address of the register is required, one way is to use
\c _SFR_IO_ADDR to get the I/O address like in the example above.
A different approach is to use inline asm \ref inline_asm_print_modifiers
"print modifier" <tt>%i</tt> supported since avr-gcc v4.7:

\code
asm volatile ("out %i0, __zero_reg__" :: "n" (& PORTB) : "memory");
\endcode

The <tt>%i0</tt> will print the address of \c PORTB as an I/O address.

<small>Back to \ref faq_index.</small>


\section faq_gdboptimize Why does the PC randomly jump around when single-stepping through my program in avr-gdb?

When compiling a program with both optimization (\c -O) and debug
information (\c -g) which is fortunately possible in \c avr-gcc, the
code watched in the debugger is optimized code.
It is guaranteed that the code runs with the exact same
optimizations as it would run without the \c -g switch.

Since the compiler is free to
reorder code execution as long as the semantics do not change, code
is often rearranged in order to make it possible to use a single
branch instruction for conditional operations.  Branch instructions
can only cover a short range for the target PC (-63 through +64 words
from the current PC).  If a branch instruction cannot be used
directly, the compiler needs to work around it by combining a skip
instruction together with a relative jump (\c rjmp) instruction, which
will need one additional word of ROM.

Another side effect of optimization is that variable usage is
restricted to the area of code where it is actually used.  So if a
variable was placed in a register at the beginning of some function,
this same register can be re-used later on if the compiler notices
that the first variable is no longer used inside that function, even
though the variable is still in lexical scope.  When trying to examine
the variable in \c avr-gdb, the displayed result will then look
garbled.

So in order to avoid these side effects, optimization can be turned
off while debugging, or at least optimization level \c -Og can be used
which was introduced to improve good debugging experience while it still
provides a reasonable amount of optimization.

However, some of these optimizations might also
have the side effect of uncovering bugs that would otherwise not be
obvious, so it must be noted that turning off optimization can easily
change the bug pattern. In most cases, you are better off leaving
optimizations enabled while debugging.

<small>Back to \ref faq_index.</small>


\section faq_asmstabs How do I trace an assembler file in avr-gdb?

When using the \c -g compiler option, <tt>avr-gcc</tt> only generates
line number and other debug information for C (and C++) files that
pass the compiler.  Functions that don't have line number information
will be completely skipped by a single \c step command in \c gdb.
This includes functions linked from a standard library, but by default
also functions defined in an assembler source file, since the \c -g
compiler switch does not apply to the assembler.

So in order to debug an assembler input file (possibly one that has to
be passed through the C preprocessor), it's the assembler that needs
to be told to include line-number information into the output file.
(Other debug information like data types and variable allocation
cannot be generated, since unlike a compiler, the assembler basically
doesn't know about this.)  This is done using the (GNU) assembler
option \c \--gstabs.

Example:

\verbatim
$ avr-as -mmcu=atmega128 --gstabs -o foo.o foo.s
\endverbatim

When the assembler is not called directly but through the C compiler
frontend (either implicitly by passing a source file ending in <code>.S</code>,
or explicitly using <tt>-x assembler-with-cpp</tt>), the compiler
frontend needs to be told to pass the \c \--gstabs option down to the
assembler.  This is done using <tt>-Wa,\--gstabs</tt>.  Please take
care to \e only pass this option when compiling an assembler input
file.  Otherwise, the assembler code that results from the C
compilation stage will also get line number information, which
confuses the debugger.

\note You can also use <tt>-Wa,-gstabs</tt> since the compiler will add the
extra \c '-' for you.

Example:

\verbatim
$ EXTRA_OPTS="-Wall -mmcu=atmega128 -x assembler-with-cpp"
$ avr-gcc -Wa,--gstabs ${EXTRA_OPTS} -c -o foo.o foo.S
\endverbatim

Also note that the debugger might get confused when entering a piece
of code that has a non-local label before, since it then takes this
label as the name of a new function that appears to have been entered.
Thus, the best practice to avoid this confusion is to only use
non-local labels when declaring a new function, and restrict anything
else to local labels.  Local labels consist just of a number only.
References to these labels consist of the number, followed by the
letter \b b for a backward reference, or \b f for a forward reference.
These local labels may be re-used within the source file, references
will pick the closest label with the same number and given direction.

Example:

\verbatim
myfunc:
    push    r16
    push    r17
    push    r18
    push    YL
    push    YH
    ...
    clr     r16             ; start loop
    ldi     YL, lo8(sometable)
    ldi     YH, hi8(sometable)
    rjmp    2f              ; jump to loop test at end
1:  ld      r17, Y+         ; loop continues here
    ...
    breq    3f              ; return from myfunc prematurely
    ...
    inc     r16
2:  cmp     r16, r18
    brlo    1b              ; jump back to top of loop
3:  pop     YH
    pop     YL
    pop     r18
    pop     r17
    pop     r16
    ret
\endverbatim

<small>Back to \ref faq_index.</small>


\section faq_port_pass How do I pass an IO port as a parameter to a function?

Consider this example code:

\code
#include <stdint.h>
#include <avr/io.h>

void
set_bits_func_wrong (volatile uint8_t port, uint8_t mask)
{
    port |= mask;
}

void
set_bits_func_correct (volatile uint8_t *port, uint8_t mask)
{
    *port |= mask;
}

#define set_bits_macro(port, mask) ((port) |= (mask))

int main (void)
{
    set_bits_func_wrong (PORTB, 0xaa);
    set_bits_func_correct (&PORTB, 0x55);
    set_bits_macro (PORTB, 0xf0);

    return (0);
}
\endcode

The first function will generate object code which is not even close to what
is intended. The major problem arises when the function is called. When the
compiler sees this call, it will actually pass the value of the \c PORTB
register (using an \c IN instruction), instead of passing the address of \c
PORTB (e.g. memory mapped io addr of \c 0x38, io port \c 0x18 for the
mega128). This is seen clearly when looking at the disassembly of the call:

\verbatim
    set_bits_func_wrong (PORTB, 0xaa);
 10a:   6a ea           ldi     r22, 0xAA
 10c:   88 b3           in      r24, 0x18
 10e:   0e 94 65 00     call    0xca
\endverbatim

So, the function, once called, only sees the value of the port register and
knows nothing about which port it came from. At this point, whatever object
code is generated for the function by the compiler is irrelevant. The
interested reader can examine the full disassembly to see that the function's
body is completely fubar.

The second function shows how to pass (by reference) the memory mapped address
of the io port to the function so that you can read and write to it in the
function. Here's the object code generated for the function call:

\verbatim
    set_bits_func_correct (&PORTB, 0x55);
 112:   65 e5           ldi     r22, 0x55
 114:   88 e3           ldi     r24, 0x38
 116:   90 e0           ldi     r25, 0x00
 118:   0e 94 7c 00     call    0xf8
\endverbatim

You can clearly see that \c 0x0038 is correctly passed for the address of the
io port. Looking at the disassembled object code for the body of the function,
we can see that the function is indeed performing the operation we intended:

\verbatim
void
set_bits_func_correct (volatile uint8_t *port, uint8_t mask)
{
  f8:   fc 01           movw    r30, r24
    *port |= mask;
  fa:   80 81           ld      r24, Z
  fc:   86 2b           or      r24, r22
  fe:   80 83           st      Z, r24
}
 100:   08 95           ret
\endverbatim

Notice that we are accessing the io port via the \c LD and \c ST instructions.

The \c port parameter must be volatile to avoid a compiler warning.

\note Because of the nature of the \c IN and \c OUT assembly instructions,
they can not be used inside the function when passing the port in this way.
Readers interested in the details should consult the <em>Instruction Set</em>
datasheet.

Finally we come to the macro version of the operation. In this contrived
example, the macro is the most efficient method with respect to both execution
speed and code size:

\verbatim
    set_bits_macro (PORTB, 0xf0);
 11c:   88 b3           in      r24, 0x18
 11e:   80 6f           ori     r24, 0xF0
 120:   88 bb           out     0x18, r24
\endverbatim

Of course, in a real application, you might be doing a lot more in your
function which uses a passed by reference io port address and thus the use of
a function over a macro could save you some code space, but still at a cost of
execution speed.

Care should be taken when such an indirect port access is going to one
of the 16-bit IO registers where the order of write access is critical
(like some timer registers).  All versions of avr-gcc up to 3.3 will
generate instructions that use the wrong access order in this
situation (since with normal memory operands where the order doesn't
matter, this sometimes yields shorter code).

See
http://mail.gnu.org/archive/html/avr-libc-dev/2003-01/msg00044.html
for a possible workaround.

avr-gcc versions after 3.3 have been fixed in a way where this
optimization will be disabled if the respective pointer variable is
declared to be \c volatile, so the correct behaviour for 16-bit IO
ports can be forced that way.

<small>Back to \ref faq_index.</small>


\section faq_reg_usage What registers are used by the compiler?

See also the
<a href="https://gcc.gnu.org/wiki/avr-gcc#Type_Layout">Type Layout</a>,
<a href="https://gcc.gnu.org/wiki/avr-gcc#Register_Layout">Register Layout</a> and
<a href="https://gcc.gnu.org/wiki/avr-gcc#Calling_Convention">Calling Convention</a>
sections in the avr-gcc Wiki.

<dl>
<dt>Data types</dt>
<dd>
  \c char is 8 bits, \c int and \c short are 16 bits, \c long is 32 bits,
  \c long \c long is 64 bits, \c float is 32 bits,
  \c double and \c long \c double are 32 bits or 64 bits,
  pointers are 16 bits (function pointers are word
  addresses to allow addressing up to 128K program memory space).

  - There is a \c -mint8 option (see \ref using_avr_gcc) to
  make \c int and \c short 8 bits, \c long 16 bits and \c long \c long 32 bits.
  But that is not supported by AVR-LibC (except for \c stdint.h and
  \c avr/pgmspace.h, but no 64-bit integer types are available)
  and violates C standards (\c int \e must be at least 16 bits).
</dd>

<dt>Call-used registers (r18-r27, r30-r31)</dt>
<dd>
  May be allocated by gcc for local data.
  You \e may use them freely in assembly subroutines.
  Calling C subroutines can clobber any of them -
  the caller is responsible for saving and restoring.

   For the AVR_TINY architecture (ATtiny10 and relatives),
   r20-r27 and r30-31 are call-clobbered.
</dd>

<dt>Call-saved registers (r2-r17, r28-r29)</dt>
<dd>
  May be allocated by gcc for local data.
  Calling C subroutines leaves them unchanged.
  Assembly subroutines are responsible for saving
  and restoring these registers, if changed.
  r29:r28 (Y pointer) is used as a frame pointer
  (points to local data on stack) if necessary.
  The requirement for the callee to save/preserve
  the contents of these registers even applies in
  situations where the compiler assigns them for
  argument passing.

  For the AVR_TINY architecture (ATtiny10 etc.),
  r18-r19 and  r28-r29 are call-saved.
  Registers r0 through r15 do not exist.
</dd>

<dt>\anchor zero_reg \anchor tmp_reg Fixed registers (r0, r1)</dt>
<dd>
  Never allocated by gcc for local data, but often
  used for fixed purposes:

  - <strong>r0</strong> (\c __tmp_reg__) --- temporary register,
  can be clobbered by any code (except interrupt handlers which save it),
  \e may be used to remember something for a while
  within one piece of assembly code

  - <strong>r1</strong> (\c __zero_reg__) --- assumed to be always zero
  in any C code,
  \e may be used to remember something for a while
  within one piece of assembler code, but \e must
  then be cleared after use (<tt>clr __zero_reg__</tt>).  This
  includes any use of the <tt>[f]mul[s[u]]</tt> instructions,
  which return their result in r1:r0.
  Interrupt handlers save and clear \c __zero_reg__ on entry,
  and restore it on exit (in case it was non-zero).

  - <strong>T flag</strong> --- the \c T flag in the status register (\c SREG)
  can be used the same way like \c __tmp_reg__.

  For the AVR_TINY architecture (ATtiny10 etc.),
  \c __tmp_reg__ is r16, and \c __zero_reg__ is r17.
</dd>

<dt>Function call conventions</dt>
<dd>
  Arguments - allocated left to right, r25 to r8.
  All arguments are aligned to start in even-numbered
  registers (odd-sized arguments, including \c char, have
  one free register above them).  This allows making better
  use of the \c movw instruction on the enhanced core.

  If too many, those that don't fit are passed on the stack.

  On AVR_TINY, r25 to r20 are used to pass values.

- Return values: 8-bit in r24, 16-bit in r25:r24,
  up to 32 bits in r22-r25, up to 64 bits in r18-r25.

- Arguments to functions with a variable number of lists like
  \c printf get all their values on the stack.
  \c char is extended to \c int, and \c float is extended to \c double.

- When an argument is passed on the stack, all subsequent arguments are
  also passed on the stack.

- An argument is either passed completely in registers or completely on
  the stack.

- Arguments with a size of zero or with a size larger than 8 bytes
  (4 bytes on AVR_TINY) are returned in memory.  The caller provides
  the memory location as implicit first argument to the callee.

- When an argument is returned in registers, its size is padded to the
  next power of 2.
.
</dd>
</dl>

<small>Back to \ref faq_index.</small>


\section faq_rampx How are the RAMPX, RAMPY, RAMPZ and RAMPD registers handled?

See <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#ramp"
       >The RAMPX, RAMPY, RAMPZ and RAMPD special function registers</a>
in the GCC documentation.

<small>Back to \ref faq_index.</small>


\section faq_eind How is the EIND special function register handled?

See <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#eind"
       >The EIND special function register</a>
in the GCC documentation.

<small>Back to \ref faq_index.</small>


\section faq_ext_ram How to use external RAM?

Well, there is no universal answer to this question; it depends on
what the external RAM is going to be used for.

Basically, the bit \c SRE (SRAM enable) in the \c MCUCR register needs
to be set in order to enable the external memory interface.  Depending
on the device to be used, and the application details, further
registers affecting the external memory operation like \c XMCRA and
\c XMCRB, and/or further bits in \c MCUCR might be configured.
Refer to the datasheet for details.

If the external RAM is going to be used to store the variables from
the C program (i. e., the <code>.data</code> and/or <code>.bss</code> segment)
in that
memory area, it is essential to set up the external memory interface
early during the \ref sec_dot_init "device initialization" so the
initialization of these variable will take place.  Refer to
\ref faq_startup for a description how to do this using few lines of
assembler code, or to the chapter about memory sections for an
\ref c_sections "example written in C".

The explanation of malloc() contains a \ref malloc_where "discussion"
about the use of internal RAM vs. external RAM in particular with
respect to the various possible locations of the \e heap (area
reserved for malloc()).  It also explains the linker command-line
options that are required to move the memory regions away from their
respective standard locations in internal RAM.

Finally, if the application simply wants to use the additional RAM for
private data storage kept outside the domain of the C compiler
(e. g. through a <tt>char *</tt> variable initialized directly to a
particular address), it would be sufficient to defer the
initialization of the external RAM interface to the beginning of
<tt><b>main</b><b>()</b></tt>,
so no tweaking of the <code>.init3</code> section is necessary.  The
same applies if only the heap is going to be located there, since the
application start-up code does not affect the heap.

It is not recommended to locate the stack in external RAM.  In
general, accessing external RAM is slower than internal RAM, and
errata of some AVR devices even prevent this configuration from
working properly at all.

<small>Back to \ref faq_index.</small>


\section faq_optflags Which -O flag to use?

There's a common misconception that larger numbers behind the \c -O
option might automatically cause "better" optimization.  First,
there's no universal definition for "better", with optimization often
being a speed vs. code size trade off.  See the
\ref gcc_optO "detailed discussion" for which option affects which
part of the code generation.

A test case was run on an ATmega128 to judge the effect of compiling
the library itself using different optimization levels.  The following
table lists the results.  The test case consisted of around 2 KB of
strings to sort.  Test \#1 used qsort() using the standard library
strcmp(), test \#2 used a function that sorted the strings by their
size (thus had two calls to strlen() per invocation).

When comparing the resulting code size, it should be noted that a
floating point version of fvprintf() was linked into the binary (in
order to print out the time elapsed) which is entirely not affected by
the different optimization levels, and added about 2.5 KB to the code.

<table>
 <tr>
  <th>Optimization Flags
  <th>Size of .text
  <th>Time for Test \#1
  <th>Time for Test \#2
 </tr>
 <tr>
  <td>-O3</td>
  <td>6898</td>
  <td>903 &mu;s</td>
  <td>19.7 ms</td>
 </tr>
 <tr>
  <td>-O2</td>
  <td>6666</td>
  <td>972 &mu;s</td>
  <td>20.1 ms</td>
 </tr>
 <tr>
  <td>-Os</td>
  <td>6618</td>
  <td>955 &mu;s</td>
  <td>20.1 ms</td>
 </tr>
 <tr>
  <td>-Os -mcall-prologues</td>
  <td>6474</td>
  <td>972 &mu;s</td>
  <td>20.1 ms</td>
 </tr>
</table>

(The difference between 955 &mu;s and 972 &mu;s was just a single
timer-tick, so take this with a grain of salt.)

So generally, it seems <tt>-Os -mcall-prologues</tt> is the most
universal "best" optimization level.  Only applications that need to
get the last few percent of speed benefit from using \c -O3.

<small>Back to \ref faq_index.</small>


\section faq_reloc_code How do I relocate code to a fixed address?

First, put the function into a new, orphan
\ref sec_named "named section".
This is done with a \c section attribute that specifies the name of
the \ref sec_input "input section" with the prototype of the function:

\code
__attribute__ ((noinline, noclone, section (".bootloader")))
void boot (void);
\endcode

The \c noinline and \c noclone attributes are required to make sure
that the function is not (partially) inlined into the caller,
which does not have a respective section attribute.

Second, locate the section to the desired fixed address by means
of linking with, say
\verbatim
-Wl,--section-start,.bootloader=0x1E000
\endverbatim
see the \ref gcc_minusW "-Wl compiler option".
The name after \c \--section-start is the name of the section to be
located, and the number specifies the beginning address of the named section.

This will only work when the section is an \ref sec_orphan "orphan section",
i.e. a
section that is not mentioned in the linker script.  For sections
that <em>are</em> mentioned in the linker script, like for example
<code>.text.bootloader</code>, this will not work because
\c \--section-start refers to an output section, but the
output section for input section <code>.text.bootloader</code> is the
<code>.text</code> section.

To verify that everything went as expected,
generate the disassembly with <tt>avr-objdump ... -j .bootloader</tt>.
The top of the list file will show
\verbatim
  1 .bootloader   00000004  00002000  00002000  00000204  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
\endverbatim
Or display section properties with <tt>avr-readelf \--section-details</tt>
\verbatim
$ avr-readelf -t main.elf
Section Headers:
  [Nr] Name
       Type            Addr     Off    Size   ES   Lk Inf Al
       Flags
  [ 2] .bootloader
       PROGBITS        00002000 000204 000004 00   0   0  1
       [00000006]: ALLOC, EXEC
\endverbatim

A different way to locate the section is by means of a custom linker
script. The
<a href="https://gcc.gnu.org/wiki/avr-gcc#Address_Spaces">avr-gcc Wiki</a>
has an example that locates the <code>.progmem2.data</code> section which
is used by the compiler for variables in address-space \c __flash2.

<small>Back to \ref faq_index.</small>


\section faq_fuses My UART is generating nonsense!  My ATmega128 keeps crashing! Port F is completely broken!

Well, certain odd problems arise out of the situation that the AVR
devices as shipped by Atmel often come with a default fuse bit
configuration that doesn't match the user's expectations.  Here is a
list of things to care for:

- All devices that have an internal RC oscillator ship with the fuse
enabled that causes the device to run off this oscillator, instead of
an external crystal.  This often remains unnoticed until the first
attempt is made to use something critical in timing, like UART
communication.
- The ATmega128 ships with the fuse enabled that turns this device
into ATmega103 compatibility mode.  This means that some ports are not
fully usable, and in particular that the internal SRAM is located at
lower addresses.  Since by default, the stack is located at the top of
internal SRAM, a program compiled for an ATmega128 running on such a
device will immediately crash upon the first function call (or rather,
upon the first function return).
- Devices with a JTAG interface have the \c JTAGEN fuse programmed by
default.  This will make the respective port pins that are used for
the JTAG interface unavailable for regular IO.

<small>Back to \ref faq_index.</small>


\section faq_16bitio Why do some 16-bit timer registers sometimes get trashed?

Some of the timer-related 16-bit IO registers use a temporary register
(called TEMP in the AVR datasheet) to guarantee an atomic access to
the register despite the fact that two separate 8-bit IO transfers are
required to actually move the data.  Typically, this includes access
to the current timer/counter value register (<tt>TCNT</tt><em>n</em>),
the input capture register (<tt>ICR</tt><em>n</em>), and write access
to the output compare registers (<tt>OCR</tt><em>nM</em>).  Refer to
the actual datasheet for each device's set of registers that involves
the TEMP register.

When accessing one of the registers that use TEMP from the main
application, and possibly any other one from within an interrupt
routine, care must be taken that no access from within an interrupt
context could clobber the TEMP register data of an in-progress
transaction that has just started elsewhere.

To protect interrupt routines against other interrupt routines, it's
usually best to use the ISR() macro when declaring the interrupt
function, and to ensure that interrupts are still disabled when
accessing those 16-bit timer registers.

Within the main program, access to those registers could be
encapsulated in calls to the cli() and sei() macros.  If the status of
the global interrupt flag before accessing one of those registers is
uncertain, something like the following example code can be used.

\code
#include <avr/io.h>

uint16_t read_timer1 (void)
{
    uint8_t sreg = SREG;
    uint16_t val;

    cli();
    val = TCNT1;
    SREG = sreg;

    return val;
}
\endcode

<small>Back to \ref faq_index.</small>


\section faq_varinit Shouldn't I initialize all my variables?

Variables in static storage are guaranteed to be initialized by the C standard.
This includes global and static variables without explicit initializer,
which are initialized to 0.
\c avr-gcc does this by placing the appropriate code
into section <tt>\ref sec_dot_init ".init4"</tt>.  With respect to the
standard, this sentence is somewhat simplified (because the standard
allows for machines where the actual bit pattern used differs
from all bits being 0), but for the AVR target, in general, all integer-type
variables are set to 0, all pointers to a NULL pointer, and all
floating-point variables to 0.0.

As long as these variables are not explicitly initialized, or their
initializer is all zeros, they go into the \ref sec_dot_bss ".bss"
output section.  This section simply records the size of the
variable, but otherwise doesn't consume space, neither within the
object file nor within flash memory.  (Of course, being a variable, it
will consume space in the target's SRAM.)

<small>Back to \ref faq_index.</small>


\section faq_flashstrings Why do all my string literals eat up the SRAM?

By default, string literals are handled like all other initialized
constants in static storage: They are put into a \c \.rodata
\ref sec_input_output "input section".

On old devices, the \c \.rodata input sections are allocated to the
\ref sec_dot_data ".data" output section, which means that such objects
occupy memory in the flash ROM \e and in the SRAM according to the
following rules:

<table>
<caption>Non-Zero Data in Static Storage</caption>
<tr>
  <th>Read-Only
  <th>Input Section
  <th>Output Section
  <th>Memory Region(s)
  <th>Case
</tr>
<tr>
  <td>No  <td>.data   <td>.data  <td>text \e and data <td>All
</tr><tr>
  <td rowspan="3">Yes <td rowspan="3">.rodata
           <td><b>.data</b> <td>text \e and data <td>3
</tr><tr>
           <td>.rodata <td>text <td>1
</tr><tr>
           <td>.rodata <td>rodata <td>2
</tr>
</table>

<b>Cases</b>
-# Devices that see all of program memory in the RAM address space:
  <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrtiny">avrtiny</a>
  (AVRrc),
  <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#avrxmega3">avrxmega3</a>
  (AVR16 and AVR32 devices, 0-series, 1-series and 2-series).
-# Devices that see only a part of program memory in the RAM address space:
  AVR64 and AVR128 devices without
  <a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#index-mrodata-in-ram"
     ><tt>-mrodata-in-ram</tt></a>.
-# All other devices, i.e. devices that don't see (parts of) the program
  memory in the RAM address space, or when \c -mrodata-in-ram is specified.
  The place in the flash ROM (\c \.text) is occupied by the initializer
  values that are used by the startup code to initialize the objects
  in the \c \.data output section.

The question remains: Why is case 3. allocating constant variables into
the SRAM?  For a better understanding, consider the following code:

\code
char get_first_char (const char *str)
{
    return str[0];
}
\endcode

What code should the compiler generate for that function?
Notice that it is perfectly fine to pass a string that is not constant
through the <tt>const char *str</tt> parameter, which only states that
\c get_first_char won't change \c str like in the following use cases:

\code
char func1 (int i)
{
    char str[10];
    sprintf (str, "%d", i);
    return get_first_char (str);
}

char func2 (void)
{
    return get_first_char ("Hello");
}
\endcode

In any case the compiler will generate code like this:
\code
get_first_char:
    movw r30, r24
    ld   r24, Z
    ret
\endcode

For the devices from 1. and 2. the <tt>"ld r24,Z"</tt> will read from flash
or from SRAM depending on the address passed in R24.
But on the old 3. devices only LPM can read from flash, and therefore
the tools place \c "Hello" in RAM so that the code works for all
possible string addresses.  The same applies to all other constants
in static storage.

Of course, this is going to waste a lot of SRAM on the old devices.

For ways how to place string literals in flash ROM (and to access them),
see also the next section \ref faq_rom_array.

\note What follows is only needed when the \c \.rodata
\ref sec_input_output "input sections"
are located in RAM, which is only the case for the "old" AVR devices.
See the table above.

\subsection faq_flashstrings_progmem Use PROGMEM

In \ref avr_pgmspace "Program Space String Utilities",
a method is described how such
constant data can be moved out to flash ROM.  However, a constant
string located in flash ROM is no longer a valid argument to pass to a
function that expects a <tt>const char*</tt>-type string, since the
old AVR devices need the special instruction \c LPM to access these
strings.  Thus, separate functions are needed that take this into
account.  Many of the standard C library functions have equivalents
available where one of the string arguments can be located in flash
ROM.  Private functions in the applications need to handle this, too.
For example, the following can be used to implement simple debugging
messages that will be sent through a UART:

\code
#include <avr/io.h>
#include <avr/pgmspace.h>

int uart_putchar (char c)
{
  if (c == '\n')
    uart_putchar ('\r');
  loop_until_bit_is_set (USR, UDRE);
  UDR = c;
  return 0; // So it could be used for fdevopen(), too.
}

void debug_P (const char *addr)
{
  char c;

  while ((c = pgm_read_char(addr++)))
    uart_putchar (c);
}

int main (void)
{
  ioinit();  // Initialize UART, ...
  debug_P (PSTR ("foo was here\n"));
  return 0;
}
\endcode

\note By convention, the suffix \b _P to the function name is used as
an indication that this function is going to accept a "program-space
string".  Note also the use of the \c #PSTR macro.

\subsection faq_flashstrings_flash Use __flash

As an alternative, the GNU-C named address-space \c #__flash can be used.
Notice the proper address-space qualification of \c debug_F, the usage
of #FSTR instead of \c PSTR, and that reading from a \c #__flash address
can be accomplished by open-coded C code like in <tt>*addr++</tt>.

\code
#include <avr/io.h>
#include <avr/flash.h>

void debug_F (const __flash char *addr)
{
  char c;

  while ((c = *addr++))
    uart_putchar (c);
}

int main (void)
{
  ioinit(); // initialize UART, ...
  debug_F (FSTR ("foo was here\n"));
  return 0;
}
\endcode

<small>Back to \ref faq_index.</small>


\section faq_rom_array How do I put an array of strings completely in ROM?

There are times when you may need an array of strings which will never be
modified. In this case, you don't want to waste RAM storing the constant
strings.  For the rationale behind storing constant strings in RAM,
see the previos section \ref faq_flashstrings

\subsection faq_rom_array_progmem With PROGMEM

The most obvious (and incorrect) thing to do is this:

\code
#include <avr/pgmspace.h>

// array[] will be in flash ROM, but "Foo" and "Bar" are still in RAM.
const char* const array[2] PROGMEM =
{
    "Foo", "Bar"
};

int main (void)
{
    char buf[32];
    strcpy_P (buf, array[1]);
    return 0;
}
\endcode

The result is not what you want though. What you end up with is the array
stored in ROM, while the individual strings end up in RAM (in some
<code>.rodata</code> input section).

To work around this, you need to do something like this:

\code
#include <avr/pgmspace.h>

static const char s_foo[] PROGMEM = "Foo";
static const char s_bar[] PROGMEM = "Bar";

const char* const array[2] PROGMEM =
{
    s_foo, s_bar
};

void func (uint8_t i)
{
    char buf[32];

    const char *p = pgm_read_ptr (&array[i]);
    strcpy_P (buf, p);
}
\endcode

Looking at the disassembly of the resulting object file we see that array is
in flash as such:

\verbatim
00000026 <array>:
  26:   2e 00 2a 00

0000002a <bar>:
  2a:   42 61 72 00          Bar.

0000002e <foo>:
  2e:   46 6f 6f 00          Foo.
\endverbatim

\c foo is at address 0x002e.<br>
\c bar is at address 0x002a.<br>
\c array is at address 0x0026.<br>


\subsection faq_rom_array_as With named address-spaces

An alternative is to use the named address-space \c #__flash,
which is supported since avr-gcc v4.7 and in GNU-C99 (\c -std=gnu99) and up:

\code
#include <avr/flash.h>

const __flash char* const __flash array[] =
{
    FLIT("Foo"), FLIT("Bar")
};

int compare (const char *str, uint8_t i)
{
    return strcmp_F (str, array[i]);
}
\endcode

Moreover, there is no more need for <tt>pgm_read_xxx()</tt>: The (addresses of)
the string literals can be read directly by means of <tt>array[i]</tt>.

<small>Back to \ref faq_index.</small>


\section faq_ramoverlap How to detect RAM memory and variable overlap problems?

You can simply run <tt>avr-nm</tt> on your output (ELF) file.
Run it with the <tt>-n</tt> option, and it will sort the symbols
numerically (by default, they are sorted alphabetically).

Look for the symbol \c _end, that's the first address in
RAM that is not allocated by a variable. (avr-gcc
internally adds 0x800000 to all data/bss variable
addresses, so please ignore this offset.) Then, the
run-time initialization code initializes the stack
pointer (by default) to point to the last available
address in (internal) SRAM. Thus, the region between
\c _end and the end of SRAM is what is available for stack.
(If your application uses malloc(), which e. g. also
can happen inside printf(), the heap for dynamic
memory is also located there. See \ref malloc.)

The amount of stack required for your application
cannot be determined that easily. For example, if
you recursively call a function and forget to break
that recursion, the amount of stack required is
infinite. :-) You can look at the generated assembler
code (<tt>avr-gcc ... \ref opt_save_temps "-save-temps"</tt>),
there's a comment in each
generated assembler file that tells you the frame
size for each generated function.

GCC also supports \c -fstack-usage that generates an \c \.su text
file for each compilation unit:

\code
int main (void)
{
    return 0;
}

$ avr-gcc -c main.c -Os -fstack-usage
$ cat main.su

main.c:3:5:main	2	static
\endcode

That's the amount of stack required for this function, you have to add
up that for all functions where you know that the calls could be nested.

<small>Back to \ref faq_index.</small>


\section faq_tinyavr_c Is it really impossible to program the ATtinyXX in C?

While some small AVRs are not directly supported by the C compiler
since they do not have a RAM-based stack (and some do not even have
RAM at all), it is possible anyway to use the general-purpose
registers as a RAM replacement since they are mapped into the data
memory region.

Bruce D. Lightner wrote an excellent description of how to do this,
and offers this together with a toolkit on his web page:

http://lightner.net/avr/ATtinyAvrGcc.html

<small>Back to \ref faq_index.</small>


\section faq_AVRrc What features are (not) supported on AVRrc Reduced Core devices?

On the reduced AVRrc core with only 16 general purpose registers, the following
features are not supported:

- The printf and scanf families of functions
- Floating-point arithmetic
- Fixed-point arithmetic (though 8-bit and 16-bit arithmetic should work
  with GCC v15+)
- Arithmetic involving 64-bit computations
- Named address-spaces like \c #__flash

<small>Back to \ref faq_index.</small>


\section faq_clockskew What is this "clock skew detected" message?

It's a known problem of the MS-DOS FAT file system. Since the FAT file
system has only a granularity of 2 seconds for maintaining a file's
timestamp, and it seems that some MS-DOS derivative (Win9x) perhaps
rounds up the current time to the next second when calculating the
timestamp of an updated file in case the current time cannot be
represented in FAT's terms, this causes a situation where \c make sees
a "file coming from the future".

Since all make decisions are based on file timestamps, and their
dependencies, make warns about this situation.

Solution: don't use inferior file systems / operating systems.
Neither Unix file systems nor HPFS (aka NTFS) do experience that
problem.

Workaround: after saving the file, wait a second before starting \c
make. Or simply ignore the warning.  If you are paranoid, execute a
<tt>make clean all</tt> to make sure everything gets rebuilt.

In networked environments where the files are accessed from a file
server, this message can also happen if the file server's clock
differs too much from the network client's clock.  In this case, the
solution is to use a proper time keeping protocol on both systems,
like NTP.  As a workaround, synchronize the client's clock frequently
with the server's clock.

<small>Back to \ref faq_index.</small>


\section faq_intbits Why are (many) interrupt flags cleared by writing a logical 1?

Usually, each interrupt has its own interrupt flag bit in some control
register, indicating the specified interrupt condition has been met by
representing a logical 1 in the respective bit position.  When working
with interrupt handlers, this interrupt flag bit usually gets cleared
automatically in the course of processing the interrupt, sometimes by
just calling the handler at all, sometimes (e. g. for the U[S]ART) by
reading a particular hardware register that will normally happen
anyway when processing the interrupt.

From the hardware's point of view, an interrupt is asserted as long as
the respective bit is set, while global interrupts are enabled.  Thus,
it is essential to have the bit cleared before interrupts get
re-enabled again (which usually happens when returning from an
interrupt handler).

Only few subsystems require an explicit action to clear the interrupt
request when using interrupt handlers.  (The notable exception is the
TWI interface, where clearing the interrupt indicates to proceed with
the TWI bus hardware handshake, so it's never done automatically.)

However, if no normal interrupt handlers are to be used, or in order
to make extra sure any pending interrupt gets cleared before
re-activating global interrupts (e. g. an external edge-triggered
one), it can be necessary to explicitly clear the respective hardware
interrupt bit by software.  This is usually done by writing a logical
1 into this bit position.  This seems to be illogical at first, the
bit position already carries a logical 1 when reading it, so why does
writing a logical 1 to it <i>clear</i> the interrupt bit?

The solution is simple: writing a logical 1 to it requires only a
single \c OUT instruction, and it is clear that only this single
interrupt request bit will be cleared.  There is no need to perform a
read-modify-write cycle (like, an \c SBI instruction), since all bits
in these control registers are interrupt bits, and writing a logical 0
to the remaining bits (as it is done by the simple \c OUT instruction)
will not alter them, so there is no risk of any race condition that
might accidentally clear another interrupt request bit.  So instead of
writing

\code
TIFR |= _BV(TOV0); /* wrong! */
\endcode

simply use

\code
TIFR = _BV(TOV0);
\endcode

<small>Back to \ref faq_index.</small>


\section faq_cvt How to use a Compact Vector Table?

Some devices support a Compact Vector Table:

- Devices from the 0-series, 1-series, 2-series
- AVR-Dx, AVR-Ex and AVR-SD devices

A CVT consists of only four vectors: 0=Reset, 1=NMI, 2=Prio1 IRQ, 3=Prio0 IRQs.
The easiest way is to link and compile with
<a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#index-mcvt"
   ><code>-mcvt</code></a>
which is supported since avr-gcc v15.  This will link the
<code>crt<i>mcu</i>-cvt.o</code> variant of the startup code
that provides a CVT and activates it by setting the
<code>CPUINT_CTRLA.CPUINT_CVT</code> bit.  A C code will look something like:
\code
#include <avr/interrupt.h>

ISR (__vector_2)
{
    /* Code for Prio1 IRQ */
}

ISR_N (3)
static void prio0_isr (void)
{
    /* Code for Prio0 IRQs */
}
\endcode

When you are using an older compiler but at least AVR-LibC v2.3,
you can link with <tt>-nostartfiles <i>path</i>/crt<i>mcu</i>-cvt.o</tt>
where:
- <tt><i>mcu</i></tt> is the name of the device like <tt>attiny202</tt> for
ATtiny202.
- <tt><i>path</i></tt> is of the form
<tt><i>prefix</i>/avr/lib/<i>mlib</i></tt> where
  - <tt><i>prefix</i></tt> is the install path
  - <tt><i>mlib</i></tt> is the multilib path that can be inferred
  with <tt>$(avr-gcc -mmcu=<i>mcu</i> -print-multi-directory)</tt> like
  <tt>avrxmega3/short-calls</tt> for <tt>-mmcu=attiny202</tt>.

<dl>
<dt>Building <tt>crt<i>mcu</i>-cvt.o</tt></dt>
<dd>When you are using AVR-LibC older than v2.3, then you can build
<tt>crt<i>mcu</i>-cvt.o</tt> yourself from the current
<a href="https://github.com/avrdudes/avr-libc/blob/main/crt1/gcrt1.S"
   ><tt>gcrt1.S</tt></a>
source with <tt>-D USE_COMPACT_VECTOR_TABLE</tt>, and you have to activate
the CVT by hand (or you can implement <tt>__init_cvt</tt> as, say,
a static constructor or as a naked function in section <tt>.init3</tt>).
</dd>
<dt>Downloading <tt>crt<i>mcu</i>-cvt.o</tt></dt>
<dd>An alternative to building <tt>crt<i>mcu</i>-cvt.o</tt> yourself is to
download a pre-built toolchain like avr-gcc-15.1 from the
<a href="https://sourceforge.net/projects/winavr/files/avr-gcc"
   >WinAVR repo</a>.
Notice that you can use that tarball on any operating system since you are
only going to use target-specific files.  Unpack the downloaded archive as
explained there to some folder <tt><i>prefix</i></tt> on your machine.

Then link with
<tt>-nostartfiles <i>path</i>/crt<i>mcu</i>-cvt.o -L <i>path</i></tt>
where <tt><i>path</i></tt> is like above.
The &quot;-L <tt><i>path</i></tt>&quot; is needed so that
<tt>lib<i>mcu</i>.a</tt> from the downloaded toolchain is used.
It contains parts of the startup code like <tt>__init_cvt</tt>
and <tt>__call_main</tt>.
</dd>
</dl>

<small>Back to \ref faq_index.</small>


\section faq_local_isr How to use a local (static, namespace) function as ISR?

In order to use a non-global function as an ISR, there is #ISR_N from
<tt>avr/interrupts.h</tt>:

\code
#include <avr/interrupt.h>

ISR_N (INT0_vect_num)
static void int0_isr ()
{
    // Code
}

namespace
{
    ISR_N (ADC_vect_num)
    void adc0_isr ()
    {
        // Code
    }
};
\endcode

#ISR_N was added in AVR-LibC v2.3.  It uses the
<a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Function-Attributes.html#index-signal_0028num_0029-function-attribute_002c-AVR"
   ><tt>signal(N)</tt></a> function attribute added in
<a href="https://gcc.gnu.org/gcc-15/changes.html#avr">GCC v15</a>.

<small>Back to \ref faq_index.</small>


\section faq_fuselow Why have "programmed" fuses the bit value 0?

Basically, fuses are just a bit in a special EEPROM area.  For
technical reasons, erased E[E]PROM cells have all bits set to the
value 1, so unprogrammed fuses also have a logical 1.  Conversely,
programmed fuse cells read out as bit value 0.

<small>Back to \ref faq_index.</small>


\section faq_asmops Which AVR-specific assembler operators are available?

See \ref ass_pseudoops "Pseudo-Ops" and \ref assembly_operand_modifiers.

<small>Back to \ref faq_index.</small>


\section faq_call_asm How to call an assembly function from C/C++?

Just declare the function like you would in C/C++:
\code
extern     uint16_t asm_add (uint16_t a, uint8_t b); // in C
extern "C" uint16_t asm_add (uint16_t a, uint8_t b); // in C++
\endcode

and then call it like any ordinary C/C++ function:
\code
uint16_t use_asm_func (uint16_t a)
{
    return asm_add (a, 42);
}
\endcode

An example implementation of an assembly function that returns \a a + \a b
would read something like:
\code
#ifdef __AVR_TINY__
#define zero_reg r17
#else
#define zero_reg r1
#endif
.text
/* According to the AVR GCC ABI:
   - Param a is passed in R25:R24.
   - Param b is passed in R22.
   - Return value is in R25:R24.
   - zero_reg always contains a value of zero.  */
.global asm_add
.type asm_add, @function
asm_add:
    add r24, r22
    adc r24, zero_reg
    ret
.size asm_add, . - asm_add
\endcode

Notice that the assemnbly function complies to the
<a href="https://gcc.gnu.org/wiki/avr-gcc#Calling_Convention"
   >avr-gcc calling convention</a>.

See also
- \ref faq_reg_usage
- \ref faq_nonabi

<small>Back to \ref faq_index.</small>


\section faq_nonabi How can I use a function that doesn't comply to the ABI?

Suppose you have a function \c f_nonabi written in assembly that
doesn't comply to the \ref faq_reg_usage "avr-gcc ABI".
How can such a function be used from C/C++?

For the matter of the discussion, suppose that the function \c f_nonabi

- Takes a 16-bit integer value in R31:R30
- Returns a 16-bit integer value in R23:R22
- Clobbers R1 and R2
- Changes memory contents

There are basically two approaches:  Write an interface function in assembly,
or write an interface in inline assembly.

\subsection faq_nonabi_asm Interface in Assembly

The iterface function would look something like this, assuming that the
AVR device supports the \c MOVW and \c CALL instructions:

\code{.asm}
.global call_f_nonabi
.type call_f_nonabi,"function"
call_f_nonabi:
    push r2         ; ABI: R2 is callee-saved
    movw r30, r24   ; ABI: int is passed in R25:R24
    call f_nonabi
    movw r24, r22   ; ABI: Return result in R25:R24
    clr r1          ; ABI: R1 (__zero_reg__) must hold 0.
    pop r2          ; ABI: R2 is callee-saved
    ret
\endcode

Then provide C/C++ with an interface to \c call_f_nonabi:

\code
extern     int call_f_nonabi (int);  // C
extern "C" int call_f_nonabi (int);  // C++
\endcode

\subsection faq_nonabi_inline_asm Interface in Inline Assembly

GCC supports
<a href="ttps://gcc.gnu.org/onlinedocs/gcc/Local-Register-Variables.html"
   >local register variables</a> as a GNU extension:
\code
static inline __attribute__((__always_inline__))
int call_f_nonabi (int arg)
{
    register int r22 __asm("r22");
    __asm volatile ("%~call f_nonabi"   "\n\t"
                    "clr __zero_reg__"
                    : "=r" (r22) : "z" (arg) : "r2", "memory");
    return r22;
}
\endcode

Notes:
- Whether or not \c volatile and the <tt>"memory"</tt> clobber are
  needed depend on what \c f_nonabi actually does.
- There's no need for a local register variable for \c num since
  the <tt>"z"</tt> \ref inline_asm_constraints "constraint"
  is R30 and R31.
- R1 is a fixed register, and therefore clobbering it has no effect.
  The value of 0 in R1 has to be restored by hand.
- For the meaning of <tt>"%~call"</tt> see \ref inline_asm_special_sequences
  "inline asm special sequences".
- GCC v16 introduces
<a href="https://gcc.gnu.org/onlinedocs/gcc/Hard-Register-Constraints.html"
   >hard-register constraints</a>
as an alternative to local register variables. Using that feature,
the function would look like this:
\code
static inline __attribute__((__always_inline__))
int call_f_nonabi (int arg)
{
    int ret;
    __asm volatile ("%~call f_nonabi"   "\n\t"
                    "clr __zero_reg__"
                    : "={r22}" (ret) : "z" (arg) : "r2", "memory");
    return ret;
}
\endcode

<small>Back to \ref faq_index.</small>


\section faq_spman Why are interrupts re-enabled in the middle of writing the stack pointer?

When setting up space for local variables on the stack, the compiler
generates code like this:

\verbatim
/* prologue: frame size=20 */
	push r28
	push r29
	in r28,__SP_L__
	in r29,__SP_H__
	sbiw r28,20
	in __tmp_reg__,__SREG__
	cli
	out __SP_H__,r29
	out __SREG__,__tmp_reg__
	out __SP_L__,r28
/* prologue end (size=10) */
\endverbatim

It reads the current stack pointer value, decrements it by the
required amount of bytes, then disables interrupts, writes back the
high part of the stack pointer, writes back the saved \c SREG (which
will eventually re-enable interrupts if they have been enabled
before), and finally writes the low part of the stack pointer.

At the first glance, there's a race between restoring \c SREG, and
writing \c SPL.  However, after enabling interrupts (either explicitly
by setting the \c I flag, or by restoring it as part of the entire
\c SREG), the AVR hardware executes (at least) the next instruction
still with interrupts disabled, so the write to \c SPL is guaranteed
to be executed with interrupts disabled still.  Thus, the emitted
sequence ensures interrupts will be disabled only for the minimum
time required to guarantee the integrity of this operation.

<small>Back to \ref faq_index.</small>

\section faq_linkerscripts Why are there five different linker scripts?

From a comment in the source code:

Which one of the five linker script files is actually used depends on command
line options given to ld.

A .x script file is the default script
A .xr script is for linking without relocation (-r flag)
A .xu script is like .xr but *do* create constructors (-Ur flag)
A .xn script is for linking with -n flag (mix text and data on same page).
A .xbn script is for linking with -N flag (mix text and data on same page).

<small>Back to \ref faq_index.</small>


\section faq_binarydata How to add a raw binary image to linker output?

\subsection faq_binarydata_embed Using #embed

Before answering this question, lets mention the <tt>\#embed</tt>
directive introduced in C23.  While <tt>\#embed</tt> doesn't strictly
conform to the requirement of the question, it is so much more convenient
that you still may want to use it.  <tt>\#embed</tt> embeds the contents
of a file into a compilation unit. Here is an example:
\code
#include <stdio.h>
#include <avr/pgmspace.h>

static const char abba_txt[] PROGMEM =
{
#embed "abba.txt"
    // Append \0 so that abba_txt becomes a proper C string
    // (assuming abba.txt is a text file).
    , '\0'
};

int main (void)
{
    printf ("== abba.txt has %d bytes ==\n%S\n",
            (int) sizeof (abba_txt) - 1, abba_txt);
}
\endcode


\subsection faq_binarydata_incbin Using .incbin

The GNU assembler supports the
<a href="https://sourceware.org/binutils/docs/as/Incbin.html"
   ><tt>.incbin</tt></a> directive, which includes
the content of a file verbatim as if it was specified by \c \.byte
directives:
\code
.macro ARRAY_START name
    .pushsection .progmem.data.\name,"a","progbits"
    .global \name
    .type \name,"object"
    \name:
.endm

.macro ARRAY_END name
    .global \name\()_size
    \name\()_size = . - \name
    .size \name, . - \name
    .popsection
.endm

/* Defines abba_txt[] from the bytes of abba.txt. */
ARRAY_START abba_txt
    .incbin "abba.txt"
    /* Append a \0 to the array. */
    .byte 0
ARRAY_END abba_txt
\endcode

The code defines the assembly macros \c ARRAY_START and \c ARRAY_END for
convenience.  They define the array and a symbol for the array size.
A C header file provides the symbols to a C program:

\code
#ifndef ABBA_H
#define ABBA_H
extern char abba_txt[];
// Notice that abba_txt_size is just a symbol
// that doesn't occupy memory.
extern char abba_txt_size[];
#endif /* ABBA_H */
\endcode

This header is then included in order to use the data:

\code
#include <stdio.h>
#include <stdint.h>
#include "abba.h"

int main (void)
{
    printf ("start: 0x%x\n", (uintptr_t) abba_txt);
    printf ("size:  %u\n", (uintptr_t) abba_txt_size);
    printf ("array: \"%S\"\n", abba_txt);
    return 0;
}
\endcode

The simplest way to assemble the assembly module is by letting avr-gcc
do the work:
\verbatim
$ avr-gcc -x assembler-with-cpp abba.asm -x none -o abba.o -mmcu=...
\endverbatim
The <tt>"-x assembler-with-cpp"</tt> and <tt>"-x none"</tt> are only
needed when the file extension of the assembly file is neither \c \.S nor
\c \.sx.  In such cases, avr-gcc must be provided with the
\ref opt_x "input language".


\subsection faq_binarydata_objcopy Using objcopy

The GNU linker <tt>avr-ld</tt> cannot handle binary data
directly. However, there's a companion tool called
<a href="https://sourceware.org/binutils/docs/binutils/objcopy.html"
   ><tt>avr-objcopy</tt></a>.
This is already known from the output side: it's used to extract
the contents of the linked ELF file into an Intel Hex load file.

<tt>avr-objcopy</tt> can create a relocatable object file from
arbitrary binary input, like

\verbatim
$ avr-objcopy -I binary -O elf32-avr foo.bin foo.o
\endverbatim

This will create a file named <tt>foo.o</tt> with the contents of
<tt>foo.bin</tt>.  The contents will default to section .data, and two
symbols will be created named \c _binary_foo_bin_start and \c
_binary_foo_bin_end. These symbols can be referred to inside a C
source to access these data.

If the goal is to have those data go to flash ROM (similar to having
used the PROGMEM attribute in C source code), the sections have to be
renamed while copying, and it's also useful to set the section flags:

\verbatim
$ avr-objcopy --rename-section .data=.progmem.data,contents,alloc,load,readonly,data -I binary -O elf32-avr foo.bin foo.o
\endverbatim

Note that all this could be conveniently wired into a Makefile, so
whenever <tt>foo.bin</tt> changes, it will trigger the recreation of
<tt>foo.o</tt>, and a subsequent relink of the final ELF file.

Below are two Makefile fragments that provide rules to convert a .txt file
to an object file, and to convert a .bin file to an object file:

\verbatim
$(OBJDIR)/%.o : %.txt
	@echo Converting $<
	@cp $(<) $(*).tmp
	@echo -n 0 | tr 0 '\000' >> $(*).tmp
	@$(OBJCOPY) -I binary -O elf32-avr \
	--rename-section .data=.progmem.data,contents,alloc,load,readonly,data \
	--redefine-sym _binary_$*_tmp_start=$* \
	--redefine-sym _binary_$*_tmp_end=$*_end \
	--redefine-sym _binary_$*_tmp_size=$*_size_sym \
	$(*).tmp $(@)
	@echo "extern const char" $(*)"[] PROGMEM;" > $(*).h
	@echo "extern const char" $(*)_end"[] PROGMEM;" >> $(*).h
	@echo "extern const char" $(*)_size_sym"[];" >> $(*).h
	@echo "#define $(*)_size ((int)$(*)_size_sym)" >> $(*).h
	@rm $(*).tmp

$(OBJDIR)/%.o : %.bin
	@echo Converting $<
	@$(OBJCOPY) -I binary -O elf32-avr \
	--rename-section .data=.progmem.data,contents,alloc,load,readonly,data \
	--redefine-sym _binary_$*_bin_start=$* \
	--redefine-sym _binary_$*_bin_end=$*_end \
	--redefine-sym _binary_$*_bin_size=$*_size_sym \
	$(<) $(@)
	@echo "extern const char" $(*)"[] PROGMEM;" > $(*).h
	@echo "extern const char" $(*)_end"[] PROGMEM;" >> $(*).h
	@echo "extern const char" $(*)_size_sym"[];" >> $(*).h
	@echo "#define $(*)_size ((int)$(*)_size_sym)" >> $(*).h
\endverbatim

<small>Back to \ref faq_index.</small>


\section faq_softreset How do I perform a software reset of the AVR?

The canonical way to perform a software reset of non-XMega AVR's is to use the
watchdog timer. Enable the watchdog timer to the shortest timeout setting,
then go into an infinite, do-nothing loop. The watchdog will then reset the
processor.

XMega parts have a specific bit <tt>RST_SWRST_bm</tt> in the
<tt>RST.CTRL</tt> register, that generates a hardware reset.
RST_SWRST_bm is protected by the XMega Configuration Change Protection
system.

The reason why using the watchdog timer or <tt>RST_SWRST_bm</tt> is
preferable over jumping to the reset vector, is that when the watchdog
or <tt>RST_SWRST_bm</tt> resets the AVR, the registers will be reset
to their known, default settings. Whereas jumping to the reset vector
will leave the registers in their previous state, which is generally
not a good idea.

<dl>
<dt>CAUTION!</dt>
<dd>
  Older AVRs will have the watchdog timer disabled on a reset. For these older
  AVRs, doing a soft reset by enabling the watchdog is easy, as the watchdog
  will then be disabled after the reset. On newer AVRs, once the watchdog
  is enabled, then it <b>stays enabled, even after a reset</b>! For these
  newer AVRs a function needs to be added to the <code>.init3</code> section
  (i.e. during
  the startup code, before main()) to disable the watchdog early enough so
  it does not continually reset the AVR.
</dd>
</dl>

Here is some example code that creates a macro that can be called to perform
a soft reset:

\code
#include <avr/wdt.h>

static inline __attribute__((__always_inline__))
void soft_reset (void)
{
    wdt_enable (WDTO_15MS);
    for(;;) {}
}
\endcode

For newer AVRs (such as the ATmega1281) also add this function to your code
to then disable the watchdog after a reset (e.g., after a soft reset):

\code
#include <avr/wdt.h>

// Function Pototype
static  __attribute__((used, unused, naked, section(".init3")))
void wdt_init (void);

// Function Implementation
void wdt_init (void)
{
    MCUSR = 0;
    wdt_disable();
}
\endcode
The code is placed in section <tt>\ref sec_dot_init ".init3"</tt>
so that it is executed as part of the
normal startup procedure.  The \c naked attribute is required so that the
code does not <tt>ret</tt>urn (Code in init sections is executed as it
is located; the code is not called, and code from one init section
falls through to the code in the next one).
The \c used attribute makes sure that the
compiler does not throw the seemingly unused function away.
The \c unused attributes avoids warnings about unused code.

<small>Back to \ref faq_index.</small>


\section faq_reentrant What pitfalls exist when writing reentrant code?

Reentrant code means the ability for a piece of code to be
called simultaneously from two or more threads.  Attention
to re-enterability is needed when using a multi-tasking
operating system, or when using interrupts since an
interrupt is really a temporary thread.

The code generated natively by gcc is reentrant.  But, only
some of the libraries in AVR-LibC are explicitly reentrant,
and some are known not to be reentrant.  In general, any
library call that reads and writes global variables
(including I/O registers) is not reentrant.
This is because more than one thread could read or write the
same storage at the same time, unaware that other threads
are doing the same, and create inconsistent and/or erroneous
results.

A library call that is known not to be reentrant will work
if it is used only within one thread <em>and</em> no other
thread makes use of a library call that shares common
storage with it.

Below is a table of library calls with known issues.

<table>
 <tr>
  <th>Library Call
  <th>Reentrant Issue
  <th>Workaround / Alternative
 </tr>
 <tr>
  <td><tt>#rand</tt>, <tt>#random</tt></td>
  <td>Uses global variables to keep state information.</td>
  <td>Use special reentrant versions: #rand_r, #random_r.</td>
 </tr>
 <tr>
  <td><tt>#strtof</tt>, <tt>#strtod</tt>, <tt>#strtol</tt>,
    <tt>#strtoul</tt></td>
  <td>Uses the global variable \c errno to return success/failure.</td>
  <td>Ignore \c errno, or protect calls with #cli/#sei
      or #ATOMIC_BLOCK
      if the application can tolerate it.  Or use #scanf or #scanf_P
      if possible.
  </td>
 </tr>
 <tr>
  <td><tt>#malloc</tt>, <tt>#realloc</tt>, <tt>#calloc</tt>, <tt>#free</tt></td>
  <td>Uses the stack pointer and global variables to allocate and
      free memory.</td>
  <td>Protect calls with #cli/#sei or #ATOMIC_BLOCK if the application
      can tolerate it.  If using an OS,
      use the OS provided memory allocator since the OS is likely modifying
      the stack pointer anyway.
  </td>
 </tr>
 <tr>
  <td><tt>#fdevopen</tt>, <tt>#fclose</tt></td>
  <td>Uses #calloc and #free.</td>
  <td>Protect calls with #cli/#sei or
    #ATOMIC_BLOCK if the application
    can tolerate it.  Or use #fdev_setup_stream or #FDEV_SETUP_STREAM.
      <br>
      Note: #fclose will only call #free if the stream has been opened with #fdevopen.
  </td>
 </tr>
 <tr>
  <td><tt>\ref avr_eeprom "eeprom_*"</tt>,
    <tt>\ref avr_boot "boot_*"</tt></td>
  <td>Accesses I/O registers.</td>
  <td>Protect calls with #cli/#sei, #ATOMIC_BLOCK, or use OS locking.</td>
 </tr>
 <tr>
  <td><tt>\ref avr_pgmspace "pgm_*_far"</tt></td>
  <td>Accesses I/O register RAMPZ.</td>
  <td>Starting with GCC 4.3, RAMPZ is automatically saved for \ref ISR "ISRs",
      so nothing further is needed if only using interrupts.
      <br>Some OSes may automatically preserve RAMPZ during context switching.
      Check the OS documentation before assuming it does.
      <br>Otherwise, protect calls with #cli/#sei, #ATOMIC_BLOCK, or use
          explicit OS locking.
  </td>
 </tr>
 <tr>
  <td><tt>#printf</tt>, <tt>#printf_P</tt>, <tt>#vprintf</tt>,
    <tt>#puts</tt>, <tt>#puts_P</tt></td>
  <td>Alters flags and character count in global FILE \c stdout.</td>
  <td>Use only in one thread.  Or if returned character count is unimportant,
      do not use the *_P versions.
      <br>Note: Formatting to a string output, e.g. #sprintf, #sprintf_P,
      #snprintf, #snprintf_P, #vsprintf, #vsprintf_P, #vsnprintf, #vsnprintf_P,
      is thread safe.  The formatted string could then be followed by an
      #fwrite which simply calls the lower layer to send the string.
  </td>
 </tr>
 <tr>
  <td><tt>#fprintf</tt>, <tt>#fprintf_P</tt>, <tt>#vfprintf</tt>,
    <tt>#vfprintf_P</tt>, <tt>#fputs</tt>, <tt>#fputs_P</tt></td>
  <td>Alters flags and character count in the FILE argument.
      Problems can occur if a global FILE is used from multiple threads.
  </td>
  <td>Assign each thread its own FILE for output.  Or if returned character
      count is unimportant, do not use the *_P versions.
  </td>
 </tr>
 <tr>
  <td><tt>#clearerr</tt></td>
  <td>Alters flags in the FILE argument.
  </td>
  <td>Assign each thread its own FILE for output.
  </td>
 </tr>

 <tr>
  <td><tt>#getchar</tt>, <tt>#gets</tt></td>
  <td>Alters flags, character count, and unget buffer in global FILE \c stdin.</td>
  <td>Use only in one thread. ***</td>
 </tr>

 <tr>
  <td><tt>#fgetc</tt>, <tt>#ungetc</tt>, <tt>#fgets</tt>,
    <tt>#scanf</tt>, <tt>#scanf_P</tt>, <tt>#fscanf</tt>,
    <tt>#fscanf_P</tt>, <tt>#vscanf</tt>, <tt>#vfscanf</tt>,
    <tt>#vfscanf_P</tt>, <tt>#fread</tt>
  <td>Alters flags, character count, and unget buffer in the FILE argument.</td>
  <td>Assign each thread its own FILE for input. ***
      <br>Note: Scanning from a string, e.g. #sscanf and #sscanf_P,
      are thread safe.
  </td>
 </tr>

 <tr>
   <td><tt>time.h</tt>
   <td>Uses global state in \c __latitude, \c __longitude, \c __utc_offset,
       \c __asc_store, \c __tm_store, \c __dst_ptr, \c __system_time.
   <td>Some functions have reentrant versions, like:
        \c #asctime_r, \c #ctime_r, \c #gmtime_r, \c #iso_week_date_r,
        \c #isotime_r, \c #localtime_r.
 </tr>
</table>

\note It's not clear one would ever want to do character
input simultaneously from more than one thread anyway, but
these entries are included for completeness.

An effort will be made to keep this table up to date if any
new issues are discovered or introduced.

<small>Back to \ref faq_index.</small>


\section faq_eeprom_corruption  Why are some addresses of the EEPROM corrupted (usually address zero)?

The two most common reason for EEPROM corruption is either writing to
the EEPROM beyond the datasheet endurance specification, or resetting
the AVR while an EEPROM write is in progress.

EEPROM writes can take up to tens of milliseconds to complete.  So
that the CPU is not tied up for that long of time, an internal
state-machine handles EEPROM write requests.  The EEPROM state-machine
expects to have all of the EEPROM registers setup, then an EEPROM write
request to start the process.  Once the EEPROM state-machine has
started, changing EEPROM related registers during an EEPROM write is
guaranteed to corrupt the EEPROM write process.  The datasheet always
shows the proper way to tell when a write is in progress, so that the
registers are not changed by the user's program.  The EEPROM
state-machine will \b always complete the write in progress unless
power is removed from the device.

As with all EEPROM technology, if power fails during an EEPROM write
the state of the byte being written is undefined.

In older generation AVRs the EEPROM Address Register (EEAR) is
initialized to zero on reset, be it from Brown Out Detect, Watchdog or
the Reset Pin.  If an EEPROM write has just started at the time of the
reset, the write will be completed, but now at address zero instead of
the requested address.  If the reset occurs later in the write process
both the requested address and address zero may be corrupted.

To distinguish which AVRs may exhibit the corrupt of address zero
while a write is in process during a reset, look at the "initial
value" section for the EEPROM Address Register.  If EEAR shows the
initial value as 0x00 or 0x0000, then address zero and possibly the
one being written will be corrupted.  Newer parts show the initial
value as "undefined", these will not corrupt address zero during a
reset (unless it was address zero that was being written).

EEPROMs have limited write endurance.  The datasheet specifies the
number of EEPROM writes that are guaranteed to function across the
full temperature specification of the AVR, for a given byte.  A read
should always be performed before a write, to see if the value in the
EEPROM actually needs to be written, so not to cause unnecessary EEPROM
wear.

The failure mechanism for an overwritten byte is generally one of
"stuck" bits, i. e. a bit will stay at a one or zero state regardless of
the byte written.  Also a write followed by a read may return the
correct data, but the data will change with the passage of time, due
the EEPROM's inability to hold a charge from the excessive write wear.

<small>Back to \ref faq_index.</small>


\section faq_wrong_baud_rate  Why is my baud rate wrong?

Some AVR datasheets give the following formula for calculating baud rates:

\code
(F_CPU / (UART_BAUD_RATE * 16L) - 1)
\endcode

Unfortunately that formula does not work with all combinations of
clock speeds and baud rates due to integer truncation during the
division operator.

When doing integer division it is usually better to round to the nearest
integer, rather than to the lowest.  To do this add 0.5 (i. e. half the
value of the denominator) to the numerator before the division, resulting
in the formula:

\code
((F_CPU + UART_BAUD_RATE * 8L) / (UART_BAUD_RATE * 16L) - 1)
\endcode

This is also the way it is implemented in \ref util_setbaud.

<small>Back to \ref faq_index.</small>


\section faq_funcptr_gt128kib On a device with more than 128 KiB of flash, how to make function pointers work?

Function pointers beyond the "magical" 128 KiB barrier(s) on larger
devices are supposed to be resolved through so-called
<em>trampolines</em> by the linker, so the actual pointers used in
the code can remain 16 bits wide.

In order for this to work, the option <tt>-mrelax</tt> must be given
on the compiler command-line that is used to link the final ELF file.

See also the avr-gcc online documentation on the
<a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#eind"
   >\c EIND special function register</a> and indirect calls.

<small>Back to \ref faq_index.</small>


\section faq_assign_chain Why is assigning ports in a "chain" a bad idea?

Suppose a number of IO port registers should get the value \c 0xff
assigned.  Conveniently, it is implemented like this:

\code
  DDRB = DDRD = 0xff;
\endcode

According to the rules of the C language, this causes 0xff to be
assigned to \c DDRD, then \c DDRD is read back, and the value is
assigned to \c DDRB.  The compiler stands no chance to optimize the
readback away, as an IO port register is declared "volatile".  Thus,
chaining that kind of IO port assignments would better be avoided,
using explicit assignments instead:

\code
  DDRB = 0xff;
  DDRD = 0xff;
\endcode

Even worse ist this, e. g. on an ATmega1281:

\code
  DDRA = DDRB = DDRC = DDRD = DDRE = DDRF = DDRG = 0xff;
\endcode

The same happens as outlined above.  However, when reading back
register \c DDRG, this register only implements 6 out of the 8 bits,
so the two topmost (unimplemented) bits read back as 0!  Consequently,
all remaining <tt>DDR</tt><em>x</em> registers get assigned the value
0x3f, which does not match the intention of the developer in any way.


\section faq_headers Which header files are included in my program?

Suppose we have a simple program like
\code
#include <avr/pgmspace.h>

int main (void)
{
    return 0;
}
\endcode

and we want to know which files this \c \#include triggers.
Just add option \c -H to the compiler options and check what is printed
on standard output:
\verbatim
$ avr-gcc -H -S main.c -mmcu=atmega8
. <install>/avr/include/avr/pgmspace.h
.. <install>/avr/include/inttypes.h
... <install>/lib/gcc/avr/<version>/include/stdint.h
.... <install>/avr/include/stdint.h
.. <install>/lib/gcc/avr/<version>/include/stddef.h
.. <install>/avr/include/avr/io.h
... <install>/avr/include/avr/sfr_defs.h
... <install>/avr/include/avr/iom8.h
... <install>/avr/include/avr/portpins.h
...
\endverbatim
where <tt>&lt;install&gt;</tt> denotes the installation path,
<tt>&lt;version&gt;</tt> denotes the GCC version,
and the number of dots indicates the include level,
e.g. \c inttypes.h is included by
<tt>pgmspace.h</tt>.

When \c -v is added to the compiler options, then the search paths are also
displayed (amongst other stuff):
\verbatim
#include "..." search starts here:
#include <...> search starts here:
 <install>/bin/../lib/gcc/avr/<version>/include
 <install>/bin/../lib/gcc/avr/<version>/include-fixed
 <install>/bin/../lib/gcc/avr/<version>/../../../../avr/include
End of search list.
\endverbatim
After resolving the <tt>..</tt>'s for <em>"parent directory"</em>,
the last directory becomes<br>
<tt>&lt;install&gt;/avr/include</tt>.

<small>Back to \ref faq_index.</small>


\section faq_macros Which macros are defined in my program? Where are they defined, and to what value?

For a documentation of compiler built-in macros see
<a href="https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#AVR-Built-in-Macros"
   >AVR built-in macros</a> in the GCC online documentation.

One way to find all the defined macros is to add
<tt>\ref opt_save_temps "-save-temps"</tt> and <tt>\ref opt_g "-g3"</tt>
to the compiler options.  This saves the temporary files like the
pre-processed source code in an \c \.i file (for C sources),
an \c \.ii (for C++), or a \c \.s (for assembly).
A debug level of DWARF3 or higher is required to include the macro
definitions in the file. With lower debug levels, only the preprocessed
source will be present.

For a module with a simple <tt>\#include <avr/pgmspace.h></tt>, the
saved intermediate file might look something like:

\verbatim
# 0 "<built-in>"
#define __STDC__ 1
\endverbatim

&rArr; The \c __STDC__ macro is defined built-in in the compiler.

\verbatim
# 0 "<command-line>"
#define __AVR_DEVICE_NAME__ atmega8
\endverbatim

&rArr; The \c __AVR_DEVICE_NAME__ macro is defined on the command line by
means of <tt>-D __AVR_DEVICE_NAME__=atmega8</tt>. In this special case,
the \c -D option is added by the specs file <tt>specs-atmega8</tt>.

\verbatim
# 81 "<install>/avr/include/avr/pgmspace.h" 3
#define __PGMSPACE_H_ 1


#define __need_size_t
\endverbatim

&rArr; The \c __PGMSPACE_H_ macro is defined in line 81 of that header file.
When there is no line note directly above the definition, go up until
you find a line note and add the respective number of lines.
For example, the \c __need_size_t macro is defined in line 84 of that file.

<small>Back to \ref faq_index.</small>


\section faq_isr_names What ISR names are available for my device?

The HTML documentation comes with exhaustive
\ref avr_signames "Vector &rarr; AVRs" and
\ref avr_mcu_signames "AVR &rarr; Vectors" tables.
In order to get a vector
number for the \c ISR_N macro, just append \c _num to the vector
name as used with \c ISR.  For example use \c ISR_N(ADC0_vect_num)
instead of ISR(ADC0_vect).

One way to find the available vector names is to pre-process a small
file, and to grep for possible names, like in:

\verbatim
$ echo "#include <avr/io.h>" | avr-gcc -xc - -mmcu=atmega8 -E -dM  | grep _VECTOR
#define INT0_vect _VECTOR(1)
#define INT1_vect _VECTOR(2)
#define TIMER2_COMP_vect _VECTOR(3)
#define TIMER2_OVF_vect _VECTOR(4)
#define TIMER1_CAPT_vect _VECTOR(5)
...
\endverbatim

Explanation:
<dl>
<dt><tt>echo "#include <avr/io.h>"</tt></dt>
<dd>
  This prints <tt>\#include &lt;avr/io.h&gt;</tt>
  to the standard output, which is picked up by the following command
  as a C program to be preprocessed.
</dd>

<dt><tt>avr-gcc -xc - -mmcu=atmega8 -E -dM</tt></dt>
<dd>
  Set the \ref opt_x "input language" to C,
  read the program from standard input (specified by a dash), preprocess,
  and print all macro definitions to the standard output.
</dd>

<dt><tt>grep _VECTOR</tt></dt>
<dd>
  Only print lines with \c _VECTOR in them.<br>
  The output above was actually generated with an additional
  <tt>| sort -t '(' -k 2n</tt> so that the vectors are printed in order.

  In order to find the respective vector numbers, use <tt>grep _vect_num</tt>
  instead.
</dd>
</dl>

<small>Back to \ref faq_index.</small>


\section faq_toolchain_version What are the Versions of the Tools in my Toolchain?

The versions of the tools can be obtained by running the following
commands and taking the first line of the standard output:

<table>
<caption>Commands to obtain Tool Versions</caption>
<tr><th>Version of            <th>Command
<tr><td>Compiler              <td><tt>avr-gcc \--version</tt>
<tr><td>Assembler             <td><tt>avr-as \--version</tt>
<tr><td>LD Linker<sup>1</sup> <td><tt>avr-ld \--version</tt>
<tr><td>CC Linker<sup>2</sup>
    <td><tt>echo "" | avr-gcc -xc - -Wl,\--version 2&gt; /dev/null</tt>
<tr><td>AVR-LibC
    <td><tt>echo "#include <avr/version.h>" | avr-gcc -xc - -E -dM | grep AVR_LIBC_VERSION_STRING</tt>
</table>

Linker<sup>1</sup> is the linker as called directly (<tt>avr-ld</tt>)
whereas Linker<sup>2</sup> is the linker as called though the compiler
driver <tt>avr-gcc</tt>.  The latter is the usual way to invoke the linker.
When these two versions are not the same, then the resulting toolchain may
have inconsistencies.

When you have more then one toolchain installed, then make sure you are
calling the command from the intended toolchain, e.g. by specifying
the absolute path to the tool.

Also notice that software may come with vendor specific patches,
so that the tool behaves differently than the stock version.

\ifnot GIT_BRANCH_IS_ONLINEDOCS

The FAQ document you are reading right now is part of an AVR-LibC
that has been configured for the following tool versions:

<table>
<caption>Tool Versions</caption>
<tr><th>Software   <th>Version
<tr><td>Compiler   <td><tt>@CC_VERSION_STRING@</tt>
<tr><td>Assembler  <td><tt>@AS_VERSION_STRING@</tt>
<tr><td>LD Linker  <td><tt>@LD_VERSION_STRING@</tt>
<tr><td>CC Linker  <td><tt>@CCLD_VERSION_STRING@</tt>
<tr><td>AVR-LibC   <td><tt>@AVR_LIBC_VERSION@</tt>
</table>

\anchor faq_toolchain_support

The following features have been detected when building AVR-LibC.
They influence how pars of the library behave.

<table>
<caption>Toolchain Features affecting AVR-LibC</caption>
<tr><th>Feature <th>Supported <th>Affects
<tr>
  <td>\c __builtin_avr_delay_cycles()
  <td> @HAS_DELAY_CYCLES_yesno@
  <td> \c <util/delay.h>
<tr>
  <td> \ref sec_memory_regions "text" starts at \c __TEXT_REGION_ORIGIN__
  <td> @HAVE_LDSCRIPT_PR31177_yesno@
  <td> Starup code
<tr>
  <td> \ref sec_memory_regions "data" starts at \c __DATA_REGION_ORIGIN__
  <td> @HAVE_LDSCRIPT_PR29741_yesno@
  <td> Starup code
<tr>
  <td> 64-bit floating-point
  <td> @DOX_MULTI_OPT@
  <td> \c <math.h>, Libraries
<tr>
  <td>
\if STDFIX_AVRLIBC_H_NOT_INCLUDED
    Fixed-point<sup>1</sup>
\else
    Fixed-point
\endif
  <td> @HAS_FIXED_POINT_yesno@
  <td> <tt>&lt;\ref stdfix_h "stdfix.h"&gt;</tt>, Libraries
<tr>
  <td> Device library <tt>lib<i>mcu</i>.a</tt>
  <td> @HAS_DEV_LIB_yesno@
  <td> Startup code, Libraries
</table>

\if STDFIX_AVRLIBC_H_NOT_INCLUDED
<sup>1</sup>You must include \c <stdfix-avrlibc.h> by hand after
\c <stdfix.h> for AVR-LibC fixed-point support.
\endif

\endif

<small>Back to \ref faq_index.</small>


\section faq_use_bv What is all this _BV() stuff about?

When performing low-level output work, which is a very central point
in microcontroller programming, it is quite common that a particular
bit needs to be set or cleared in some IO register.  While the device
documentation provides mnemonic names for the various bits in the IO
registers, and the \ref avr_io "AVR device-specific IO definitions" reflect these names in definitions for
numerical constants, a way is needed to convert a bit number (usually
within a byte register) into a byte value that can be assigned
directly to the register.  However, sometimes the direct bit numbers
are needed as well (e. g. in an <tt>SBI()</tt> instruction), so the
definitions cannot usefully be made as byte values in the first place.

So in order to access a particular bit number as a byte value, use the
<tt>_BV()</tt> macro.  Of course, the implementation of this macro is
just the usual bit shift (which is done by the compiler anyway, thus
doesn't impose any run-time penalty), so the following applies:

\code
_BV(3) => 1 << 3 => 0x08
\endcode

However, using the macro often makes the program better readable.

"BV" stands for "bit value", in case someone might ask you. :-)

Example:

\code
// Clock timer 2 with full IO clock (CS2x = 0b001).
// Toggle OC2 output on compare match (COM2x = 0b01).
// Clear timer on compare match (CTC2 = 1).
TCCR2 = _BV(COM20) | _BV(CTC2) | _BV(CS20);

// Make OC2 (PD7) an output.
DDRD = _BV(PD7);
\endcode

<small>Back to \ref faq_index.</small>
<!-- The _BV section is the very last since their unbalanced <<'s
     confuse the syntax highlighter. -->
*/
