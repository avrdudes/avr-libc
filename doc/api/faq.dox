/* Copyright (c) 2002, Joerg Wunsch
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

/* $Id$ */

/** \page FAQ Frequently Asked Questions

\section faq_index FAQ Index

\addindex FAQ

-# \ref faq_volatile
-# \ref faq_libm
-# \ref faq_regbind
-# \ref faq_startup
-# \ref faq_use_bv
-# \ref faq_cplusplus
-# \ref faq_varinit
-# \ref faq_16bitio
-# \ref faq_asmconst
-# \ref faq_gdboptimize
-# \ref faq_asmstabs
-# \ref faq_port_pass
-# \ref faq_reg_usage
-# \ref faq_rom_array
-# \ref faq_ext_ram
-# \ref faq_optflags

\section faq_volatile My program doesn't recognize a variable updated within an interrupt routine

When using the optimizer, in a loop like the following one:

\code
uint8_t flag;
...

	while (flag == 0) {
		...
	}
\endcode

the compiler will typically optimize the access to \c flag completely
away, since its code path analysis shows that nothing inside the loop
could change the value of \c flag anyway.  To tell the compiler that
this variable could be changed outside the scope of its code path
analysis (e. g. from within an interrupt routine), the variable needs
to be declared like:

\code
volatile uint8_t flag;
\endcode

<small>Back to \ref faq_index.
</small>

\section faq_libm I get "undefined reference to..." for functions like "sin()"

In order to access the mathematical functions that are declared in
<tt>\<math.h\></tt>, the linker needs to be told to also link the
mathematical library, <tt>libm.a</tt>.

Typically, system libraries like <tt>libm.a</tt> are given to the
final C compiler command line that performs the linking step by adding
a flag <tt>-lm</tt> at the end.  (That is, the initial \a lib and the
filename suffix from the library are written immediately after a \a -l
flag.  So for a <tt>libfoo.a</tt> library, <tt>-lfoo</tt> needs to be
provided.)  This will make the linker search the library in a path
known to the system.

An alternative would be to specify the full path to the
<tt>libm.a</tt> file at the same place on the command line, i. e. \a
after all the object files (<tt>*.o</tt>).  However, since this
requires knowledge of where the build system will exactly find those
library files, this is deprecated for system libraries.

<small>Back to \ref faq_index.
</small>

\section faq_regbind How to permanently bind a variable to a register?

This can be done with

\code
register unsigned char counter asm("r3");
\endcode

See \ref c_names_in_asm for more details.

<small>Back to \ref faq_index.
</small>

\section faq_startup How to modify MCUCR or WDTCR early?

The method of early initialization (<tt>MCUCR</tt>, <tt>WDTCR</tt> or
anything else) is different (and more flexible) in the current
version.  Basically, write a small assembler file which looks like
this:

\code
;; begin xram.S

#include <avr/io.h>

        .section .init1,"ax",@progbits

        ldi r16,_BV(SRE) | _BV(SRW)
        out _SFR_IO_ADDR(MCUCR),r16

;; end xram.S
\endcode

Assemble it, link the resulting <tt>xram.o</tt> with other files in
your program, and this piece of code will be inserted in
initialization code, which is run right after reset.  See the linker
script for comments about the new <tt>.init</tt><em>N</em> sections
(which one to use, etc.).

The advantage of this method is that you can insert any initialization
code you want (just remember that this is very early startup -- no
stack and no <tt>__zero_reg__</tt> yet), and no program memory space
is wasted if this feature is not used.

There should be no need to modify linker scripts anymore, except for
some very special cases.  It is best to leave <tt>__stack</tt> at its
default value (end of internal SRAM -- faster, and required on some
devices like ATmega161 because of errata), and add
<tt>-Wl,-Tdata,0x801100</tt> to start the data section above the
stack.

For more information on using sections, including how to use them from C code,
see \ref mem_sections.

<small>Back to \ref faq_index.
</small>

\section faq_use_bv What is all this _BV() stuff about?

When performing low-level output work, which is a very central point
in microcontroller programming, it is quite common that a particular
bit needs to be set or cleared in some IO register.  While the device
documentation provides mnemonic names for the various bits in the IO
registers, and the \ref avr_io reflect these names in definitions for
numerical constants, a way is needed to convert a bit number (usually
within a byte register) into a byte value that can be assigned
directly to the register.  However, sometimes the direct bit numbers
are needed as well (e. g. in an <tt>sbi()</tt> call), so the
definitions cannot usefully be made as byte values in the first place.

So in order to access a particular bit number as a byte value, use the
<tt>_BV()</tt> macro.  Of course, the implementation of this macro is
just the usual bit shift (which is done by the compiler anyway, thus
doesn't impose any run-time penalty), so the following applies:

\code
_BV(3) => 1 << 3 => 0x08
\endcode

However, using the macro often makes the program better readable.

"BV" stands for "bit value", in case someone might ask you. :-)

<b>Example:</b> clock timer 2 with full IO clock
(<tt>CS2</tt><em>x</em> = 0b001), toggle OC2 output on compare match
(<tt>COM2</tt><em>x</em> = 0b01), and clear timer on compare match
(<tt>CTC2</tt> = 1).  Make OC2 (<tt>PD7</tt>) an output.

\code
	TCCR2 = _BV(COM20)|_BV(CTC2)|_BV(CS20);
	DDRD = _BV(PD7);
\endcode

<small>Back to \ref faq_index.
</small>

\section faq_cplusplus Can I use C++ on the AVR?

Basically yes, C++ is supported (assuming your compiler has been
configured and compiled to support it, of course).  Source files
ending in \c .cc, \c .cpp or \c .C will automatically cause the
compiler frontend to invoke the C++ compiler.  Alternatively, the C++
compiler could be explicitly called by the name \c avr-c++.

However, there's currently no support for \c libstdc++, the standard
support library needed for a complete C++ implementation.  This
imposes a number of restrictions on the C++ programs that can be
compiled.  Among them are:

- Obviously, none of the C++ related standard functions, classes,
  and template classes are available.

- The operators \c new and \c delete are not implemented, attempting
  to use them will cause the linker to complain about undefined
  external references.  (This could perhaps be fixed.)

- Some of the supplied include files are not C++ safe, i. e. they need
  to be wrapped into \code extern "C" { . . . } \endcode
  (This could certainly be fixed, too.)

- Exceptions are not supported.  Since exceptions are enabled by
  default in the C++ frontend, they explicitly need to be turned
  off using \c -fno-exceptions in the compiler options.  Failing
  this, the linker will complain about an undefined external
  reference to \c __gxx_personality_sj0.

Constructors and destructors \e are supported though, including global
ones.

When programming C++ in space- and runtime-sensitive environments like
microcontrollers, extra care should be taken to avoid unwanted side
effects of the C++ calling conventions like implied copy constructors
that could be called upon function invocation etc.  These things could
easily add up into a considerable amount of time and program memory
wasted.  Thus, casual inspection of the generated assembler code
(using the \c -S compiler option) seems to be warranted.

<small>Back to \ref faq_index.
</small>

\section faq_varinit Shouldn't I initialize all my variables?

Global and static variables are guaranteed to be initialized to 0 by
the C standard.  \c avr-gcc does this by placing the appropriate code
into section \c .init4 (see \ref sec_dot_init).  With respect to the
standard, this sentence is somewhat simplified (because the standard
allows for machines where the actual bit pattern used differs
from all bits being 0), but for the AVR target, in general, all integer-type
variables are set to 0, all pointers to a NULL pointer, and all
floating-point variables to 0.0.

As long as these variables are not initialized (i. e. they don't have
an equal sign and an initialization expression to the right within the
definition of the variable), they go into the \ref sec_dot_bss ".bss"
section of the file.  This section simply records the size of the
variable, but otherwise doesn't consume space, neither within the
object file nor within flash memory.  (Of course, being a variable, it
will consume space in the target's SRAM.)

In contrast, global and static variables that have an initializer go
into the \ref sec_dot_data ".data" section of the file.  This will
cause them to consume space in the object file (in order to record the
initializing value), \e and in the flash ROM of the target device.
The latter is needed since the flash ROM is the only way that the
compiler can tell the target device the value this variable is going
to be initialized to.

Now if some programmer "wants to make doubly sure" their variables
really get a 0 at program startup, and adds an initializer just
containing 0 on the right-hand side, they waste space.  While this
waste of space applies to virtually any platform C is implemented on,
it's usually not noticeable on larger machines like PCs, while the
waste of flash ROM storage can be very painful on a small
microcontroller like the AVR.

So in general, variables should only be explicitly initialized if the initial
value is non-zero.

<small>Back to \ref faq_index.
</small>

\section faq_16bitio Why do some 16-bit timer registers sometimes get trashed?

Some of the timer-related 16-bit IO registers use a temporary register
(called TEMP in the Atmel datasheet) to guarantee an atomic access to
the register despite the fact that two separate 8-bit IO transfers are
required to actually move the data.  Typically, this includes access
to the current timer/counter value register (<tt>TCNT</tt><em>n</em>),
the input capture register (<tt>ICR</tt><em>n</em>), and write access
to the output compare registers (<tt>OCR</tt><em>nM</em>).  Refer to
the actual datasheet for each device's set of registers that involves
the TEMP register.

When accessing one of the registers that use TEMP from the main
application, and possibly any other one from within an interrupt
routine, care must be taken that no access from within an interrupt
context could clobber the TEMP register data of an in-progress
transaction that has just started elsewhere.

To protect interrupt routines against other interrupt routines, it's
usually best to use the SIGNAL() macro when declaring the interrupt
function, and to ensure that interrupts are still disabled when
accessing those 16-bit timer registers.

Within the main program, access to those registers could be
encapsulated in calls to the cli() and sei() macros.  If the status of
the global interrupt flag before accessing one of those registers is
uncertain, something like the following example code can be used.

\code
uint16_t
read_timer1(void)
{
	uint8_t sreg;
	uint16_t val;

	sreg = SREG;
	cli();
	val = TCNT1;
	SREG = sreg;

	return val;
}
\endcode

<small>Back to \ref faq_index.
</small>

\section faq_asmconst How do I use a #define'd constant in an asm statement?

So you tried this:

\code
asm volatile("sbi 0x18,0x07;");
\endcode

Which works. When you do the same thing but replace the address of the port
by its macro name, like this:

\code
asm volatile("sbi PORTB,0x07;");
\endcode

you get a compilation error: <tt>"Error: constant value required"</tt>.

\c PORTB is a precompiler definition included in the processor specific file
included in \c avr/io.h. As you may know, the precompiler will not touch
strings and <tt>PORTB</tt>, instead of <tt>0x18</tt>, gets passed to the
assembler. One way to avoid this problem is:

\code
asm volatile("sbi %0, 0x07" : "I" (PORTB):);
\endcode

\note \c avr/io.h already provides a sbi() macro definition, which can be used
in C programs.

<small>Back to \ref faq_index.
</small>

\section faq_gdboptimize Why does the PC randomly jump around when single-stepping through my program in avr-gdb?

When compiling a program with both optimization (\c -O) and debug
information (\c -g) which is fortunately possible in \c avr-gcc, the
code watched in the debugger is optimized code.  While it is not
guaranteed, very often this code runs with the exact same
optimizations as it would run without the \c -g switch.

This can have unwanted side effects.  Since the compiler is free to
reorder code execution as long as the semantics do not change, code
is often rearranged in order to make it possible to use a single
branch instruction for conditional operations.  Branch instructions
can only cover a short range for the target PC (-63 through +64 words
from the current PC).  If a branch instruction cannot be used
directly, the compiler needs to work around it by combining a skip
instruction together with a relative jump (\c rjmp) instruction, which
will need one additional word of ROM.

Another side effect of optimzation is that variable usage is
restricted to the area of code where it is actually used.  So if a
variable was placed in a register at the beginning of some function,
this same register can be re-used later on if the compiler notices
that the first variable is no longer used inside that function, even
though the variable is still in lexical scope.  When trying to examine
the variable in \c avr-gdb, the displayed result will then look
garbled.

So in order to avoid these side effects, optimization can be turned
off while debugging.  However, some of these optimizations might also
have the side effect of uncovering bugs that would otherwise not be
obvious, so it must be noted that turning off optimization can easily
change the bug pattern. In most cases, you are better off leaving
optimizations enabled while debugging.

<small>Back to \ref faq_index.
</small>

\section faq_asmstabs How do I trace an assembler file in avr-gdb?

When using the \c -g compiler option, <tt>avr-gcc</tt> only generates
line number and other debug information for C (and C++) files that
pass the compiler.  Functions that don't have line number information
will be completely skipped by a single \c step command in \c gdb.
This includes functions linked from a standard library, but by default
also functions defined in an assembler source file, since the \c -g
compiler switch does not apply to the assembler.

So in order to debug an assembler input file (possibly one that has to
be passed through the C preprocessor), it's the assembler that needs
to be told to include line-number information into the output file.
(Other debug information like data types and variable allocation
cannot be generated, since unlike a compiler, the assembler basically
doesn't know about this.)  This is done using the (GNU) assembler
option \c --gstabs.

Example:

\verbatim
  $ avr-as -mmcu=atmega128 --gstabs -o foo.o foo.s
\endverbatim

When the assembler is not called directly but through the C compiler
frontend (either implicitly by passing a source file ending in \c .S,
or explicitly using <tt>-x assembler-with-cpp</tt>), the compiler
frontend needs to be told to pass the \c --gstabs option down to the
assembler.  This is done using <tt>-Wa,--gstabs</tt>.  Please take
care to \e only pass this option when compiling an assembler input
file.  Otherwise, the assembler code that results from the C
compilation stage will also get line number information, which
confuses the debugger.

\note You can also use <tt>-Wa,-gstabs</tt> since the compiler will add the
extra \c '-' for you.

Example:

\verbatim
  $ EXTRA_OPTS="-Wall -mmcu=atmega128 -x assembler-with-cpp"
  $ avr-gcc -Wa,--gstabs ${EXTRA_OPTS} -c -o foo.o foo.S
\endverbatim

Also note that the debugger might get confused when entering a piece
of code that has a non-local label before, since it then takes this
label as the name of a new function that appears to have been entered.
Thus, the best practice to avoid this confusion is to only use
non-local labels when declaring a new function, and restrict anything
else to local labels.  Local labels consist just of a number only.
References to these labels consist of the number, followed by the
letter \b b for a backward reference, or \b f for a forward reference.
These local labels may be re-used within the source file, references
will pick the closest label with the same number and given direction.

Example:

\code
myfunc:	push	r16
	push	r17
	push	r18
	push	YL
	push	YH
	...
	eor	r16, r16	; start loop
	ldi	YL, lo8(sometable)
	ldi	YH, hi8(sometable)
	rjmp	2f		; jump to loop test at end
1:	ld	r17, Y+		; loop continues here
	...
	breq	1f		; return from myfunc prematurely
	...
	inc	r16
2:	cmp	r16, r18
	brlo	1b		; jump back to top of loop

1:	pop	YH
	pop	YL
	pop	r18
	pop	r17
	pop	r16
	ret
\endcode

<small>Back to \ref faq_index.
</small>

\section faq_port_pass How do I pass an IO port as a parameter to a function?

Consider this example code:

\code
#include <inttypes.h>
#include <avr/io.h>

void
set_bits_func_wrong (volatile uint8_t port, uint8_t mask)
{
    port |= mask;
}

void
set_bits_func_correct (volatile uint8_t *port, uint8_t mask)
{
    *port |= mask;
}

#define set_bits_macro(port,mask) ((port) |= (mask))

int main (void)
{
    set_bits_func_wrong (PORTB, 0xaa);
    set_bits_func_correct (&PORTB, 0x55);
    set_bits_macro (PORTB, 0xf0);

    return (0);
}
\endcode

The first function will generate object code which is not even close to what
is intended. The major problem arises when the function is called. When the
compiler sees this call, it will actually pass the value in the the \c PORTB
register (using an \c IN instruction), instead of passing the address of \c
PORTB (e.g. memory mapped io addr of \c 0x38, io port \c 0x18 for the
mega128). This is seen clearly when looking at the disassembly of the call:

\verbatim
    set_bits_func_wrong (PORTB, 0xaa);
 10a:   6a ea           ldi     r22, 0xAA       ; 170
 10c:   88 b3           in      r24, 0x18       ; 24
 10e:   0e 94 65 00     call    0xca
\endverbatim

So, the function, once called, only sees the value of the port register and
knows nothing about which port it came from. At this point, whatever object
code is generated for the function by the compiler is irrelevant. The
interested reader can examine the full disassembly to see the the function's
body is completely fubar.

The second function shows how to pass (by reference) the memory mapped address
of the io port to the function so that you can read and write to it in the
function. Here's the object code generated for the function call:

\verbatim
    set_bits_func_correct (&PORTB, 0x55);
 112:   65 e5           ldi     r22, 0x55       ; 85
 114:   88 e3           ldi     r24, 0x38       ; 56
 116:   90 e0           ldi     r25, 0x00       ; 0
 118:   0e 94 7c 00     call    0xf8
\endverbatim

You can clearly see that \c 0x0038 is correctly passed for the address of the
io port. Looking at the disassembled object code for the body of the function,
we can see that the function is indeed performing the operation we intended:

\verbatim
void
set_bits_func_correct (volatile uint8_t *port, uint8_t mask)
{
  f8:   fc 01           movw    r30, r24
    *port |= mask;
  fa:   80 81           ld      r24, Z
  fc:   86 2b           or      r24, r22
  fe:   80 83           st      Z, r24
}
 100:   08 95           ret 
\endverbatim

Notice that we are accessing the io port via the \c LD and \c ST instructions.

The \c port parameter must be volatile to avoid a compiler warning.

\note Because of the nature of the \c IN and \c OUT assembly instructions,
they can not be used inside the function when passing the port in this way.
Readers interested in the details should consult the <em>Instruction Set</em>
data sheet.

Finally we come to the macro version of the operation. In this contrived
example, the macro is the most efficient method with respect to both execution
speed and code size:

\verbatim
    set_bits_macro (PORTB, 0xf0);
 11c:   88 b3           in      r24, 0x18       ; 24
 11e:   80 6f           ori     r24, 0xF0       ; 240
 120:   88 bb           out     0x18, r24       ; 24
\endverbatim

Of course, in a real application, you might be doing a lot more in your
function which uses a passed by reference io port address and thus the use of
a function over a macro could save you some code space, but still at a cost of
execution speed.

<small>Back to \ref faq_index.</small>

\section faq_reg_usage What registers are used by the C compiler?

- <strong>Data types:</strong><br>
\c char is 8 bits, \c int is 16 bits, \c long is 32 bits, \c long long
is 64 bits, \c float and \c double are 32 bits (this is the only
supported floating point format), pointers are 16 bits (function
pointers are word addresses, to allow addressing the whole 128K
program memory space on the ATmega devices with &gt; 64 KB of flash
ROM).  There is a \c -mint8 option (see \ref using_avr_gcc) to make
\c int 8 bits, but that is not supported by avr-libc and violates C
standards (\c int \e must be at least 16 bits).  It may be removed in
a future release.

- <strong>Call-used registers (r18-r27, r30-r31):</strong><br>
May be allocated by gcc for local data.
You \e may use them freely in assembler subroutines.
Calling C subroutines can clobber any of them -
the caller is responsible for saving and restoring.

- <strong>Call-saved registers (r2-r17, r28-r29):</strong><br>
May be allocated by gcc for local data.
Calling C subroutines leaves them unchanged.
Assembler subroutines are responsible for saving
and restoring these registers, if changed.
r29:r28 (Y pointer) is used as a frame pointer
(points to local data on stack) if necessary.

- <strong>Fixed registers (r0, r1):</strong><br>
Never allocated by gcc for local data, but often
used for fixed purposes:
<p>
r0 - temporary register, can be clobbered by any
C code (except interrupt handlers which save it),
\e may be used to remember something for a while
within one piece of assembler code
</p>
<p>
r1 - assumed to be always zero in any C code,
\e may be used to remember something for a while
within one piece of assembler code, but \e must
then be cleared after use (<tt>clr r1</tt>).  This
includes any use of the <tt>[f]mul[s[u]]</tt> instructions,
which return their result in r1:r0.
Interrupt handlers save and clear r1 on entry,
and restore r1 on exit (in case it was non-zero).
</p>

- <strong>Function call conventions:</strong><br>
Arguments - allocated left to right, r25 to r8.
All arguments are aligned to start in even-numbered
registers (odd-sized arguments, including \c char, have
one free register above them).  This allows making better
use of the \c movw instruction on the enhanced core.
<p>
If too many, those that don't fit are passed on
the stack.
</p>
<p>
Return values: 8-bit in r24 (not r25!), 16-bit in r25:r24,
up to 32 bits in r22-r25, up to 64 bits in r18-r25.
8-bit return values are zero/sign-extended to
16 bits by the caller (<tt>unsigned char</tt> is more
efficient than <tt>signed char</tt> - just <tt>clr r25</tt>).
Arguments to functions with variable argument lists
(printf etc.) are all passed on stack, and \c char
is extended to \c int.
</p>
\warning
There was no such alignment before 2000-07-01,
including the old patches for gcc-2.95.2.  Check your old
assembler subroutines, and adjust them accordingly.

<small>Back to \ref faq_index.</small>

\section faq_rom_array How do I put an array of strings completely in ROM?

There are times when you may need an array of strings which will never be
modified. In this case, you don't want to waste ram storing the constant
strings. This most obvious thing to do is this:

\code
#include <avr/pgmspace.h>

PGM_P array[2] PROGMEM = {
    "Foo",
    "Bar"
};

int main (void)
{
    char buf[32];
    strcpy_P (buf, array[1]);
    return 0;
}
\endcode

The result is not want you want though. What you end up with is the array
stored in ROM, while the individual strings end up in RAM (in the \c .data
section).

To work around this, you need to do something like this:

\code
#include <avr/pgmspace.h>

const char foo[] PROGMEM = "Foo";
const char bar[] PROGMEM = "Bar";

PGM_P array[2] PROGMEM = {
    foo,
    bar
};

int main (void)
{
    char buf[32];
    strcpy_P (buf, array[1]);
    return 0;
}
\endcode

Looking at the disassembly of the resulting object file we see that array is 
in flash as such:

\code
0000008c <foo>:
  8c:   46 6f           ori r20, 0xF6   ; 246
  8e:   6f 00           .word   0x006f  ; ????

00000090 <bar>:
  90:   42 61           ori r20, 0x12   ; 18
  92:   72 00           .word   0x0072  ; ????

00000094 <array>:
  94:   8c 00           .word   0x008c  ; ????
  96:   90 00           .word   0x0090  ; ????
\endcode

\c foo is at addr 0x008c.<br>
\c bar is at addr 0x0090.<br>
\c array is at addr 0x0094.<br>

Then in main we see this:

\code
    strcpy_P (buf, array[1]);   /* copy bar into buf */
  de:   60 e9           ldi r22, 0x90   ; 144
  e0:   70 e0           ldi r23, 0x00   ; 0
  e2:   ce 01           movw    r24, r28
  e4:   01 96           adiw    r24, 0x01   ; 1
  e6:   0e 94 79 00     call    0xf2
\endcode

The addr of bar (0x0090) is loaded into the r23:r22 pair which is the second
parameter passed to strcpy_P. The r25:r24 pair is the addr of buf.


<small>Back to \ref faq_index.</small>

\section faq_ext_ram How to use external RAM?

Well, there is no universal answer to this question; it depends on
what the external RAM is going to be used for.

Basically, the bit \c SRE (SRAM enable) in the \c MCUCR register needs
to be set in order to enable the external memory interface.  Depending
on the device to be used, and the application details, further
registers affecting the external memory operation like \c XMCRA and
\c XMCRB, and/or further bits in \c MCUCR might be configured.
Refer to the datasheet for details.

If the external RAM is going to be used to store the variables from
the C program (i. e., the \c .data and/or \c .bss segment) in that
memory area, it is essential to set up the external memory interface
early during the \ref sec_dot_init "device initialization" so the
initialization of these variable will take place.  Refer to
\ref faq_startup for a description how to do this using few lines of
assembler code, or to the chapter about memory sections for an
\ref c_sections "example written in C".

The explanation of malloc() contains a \ref malloc_where "discussion"
about the use of internal RAM vs. external RAM in particular with
respect to the various possible locations of the \e heap (area
reserved for malloc()).  It also explains the linker command-line
options that are required to move the memory regions away from their
respective standard locations in internal RAM.

Finally, if the application simply wants to use the additional RAM for
private data storage kept outside the domain of the C compiler
(e. g. through a <tt>char *</tt> variable initialized directly to a
particular address), it would be sufficient to defer the
initialization of the external RAM interface to the beginning of
<tt><b>main</b><b>()</b></tt>, 
so no tweaking of the \c .init1 section is necessary.  The
same applies if only the heap is going to be located there, since the
application start-up code does not affect the heap.

It is not recommended to locate the stack in external RAM.  In
general, accessing external RAM is slower than internal RAM, and
errata of some AVR devices even prevent this configuration from
working properly at all.

<small>Back to \ref faq_index.</small>

\section faq_optflags Which -O flag to use?

There's a common misconception that larger numbers behind the \c -O
option might automatically cause "better" optimization.  First,
there's no universal definition for "better", with optimization often
being a speed vs. code size tradeoff.  See the
\ref gcc_optO "detailed discussion" for which option affects which
part of the code generation.

A test case was run on an ATmega128 to judge the effect of compiling
the library itself using different optimization levels.  The following
table lists the results.  The test case consisted of around 2 KB of
strings to sort.  Test #1 used qsort() using the standard library
strcmp(), test #2 used a function that sorted the strings by their
size (thus had two calls to strlen() per invocation).

When comparing the resulting code size, it should be noted that a
floating point version of fvprintf() was linked into the binary (in
order to print out the time elapsed) which is entirely not affected by
the different optimization levels, and added about 2.5 KB to the code.

<table>
 <tr>
  <td><strong>Optimization flags</strong></td>
  <td><strong>Size of .text</strong></td>
  <td><strong>Time for test #1</strong></td>
  <td><strong>Time for test #2</strong></td>
 </tr>
 <tr>
  <td>-O3</td>
  <td>6898</td>
  <td>903 탎</td>
  <td>19.7 ms</td>
 </tr>
 <tr>
  <td>-O2</td>
  <td>6666</td>
  <td>972 탎</td>
  <td>20.1 ms</td>
 </tr>
 <tr>
  <td>-Os</td>
  <td>6618</td>
  <td>955 탎</td>
  <td>20.1 ms</td>
 </tr>
 <tr>
  <td>-Os -mcall-prologues</td>
  <td>6474</td>
  <td>972 탎</td>
  <td>20.1 ms</td>
 </tr>
</table>

(The difference between 955 탎 and 972 탎 was just a single
timer-tick, so take this with a grain of salt.)

So generally, it seems <tt>-Os -mcall-prologues</tt> is the most
universal "best" optimization level.  Only applications that need to
get the last few percent of speed benefit from using \c -O3.

<small>Back to \ref faq_index.</small>

*/
